var x: int = 1;
print(x);

callMeMaybe("Can call functions defined below.");
consumer callMeMaybe(userMessage: string) {
  print("This was the user message!:");
  print(userMessage);
}

function helloFunWorld(message: string, someInt: int) -> string {
  # For what it's worth, note that this function does not have access to the things declared above it.
  # Uncomment this line to see an exception.
#  print(x + someInt);
  print(someInt);

  # Swap the commented res declaration and you'll see a return type error message.
  var res: string = message;
  # var res: int = 1;

  # Prompt the user for something and see if we should call the other function.
  var userResponse = input("Should we call the other function? (y/n): ");
  if (userResponse == "y") {
    callMeMaybe(input("What's your message?: "));
    print("Please ignore this next bit...Claro doesn't allow dead code so I'm using it....");
  } else {
    print("We're not gonna call the other function cuz your response was the following instead of 'y'");
    print(userResponse);
  }

  return res;
}

provider gimmeInt() -> int {
   return 9;
}
# Example of defining a Provider w/o using the `function` keyword.
provider gimmeAnothaInt() -> int {
  return -9;
}
var providedInt = gimmeInt();
print("Here's a provided result!");
print(providedInt);
print(gimmeAnothaInt());

consumer takeThis(arg: string) {
  print(arg);
}
# Example of defining a Consumer w/o using the `function` keyword.
consumer takeAnothaOne(arg: int) {
  print(arg);
}
takeThis("we're calling takeThis!");
takeAnothaOne(99);


var helloFunWorldRes = helloFunWorld("Functions in compiled java source Claro code!", 10);
print(helloFunWorldRes);

var y: string = "not in function's scope";
print("Just gonna use y for the sake of satisfying the compiler on this one");
print(y);

print("This is what it looks like to print out the function reference itself");
print(gimmeInt);
var helloFunWorld2: function<|string, int| -> string> = helloFunWorld;
print(helloFunWorld2);

print("We can actually call functions via indirection!");
var gimmeInt2: provider<int> = gimmeInt;
print(gimmeInt2());
type(gimmeInt2);

print("Higher Order functions exist!");
consumer higher(consumerFn: consumer<int>, x: int) {
  consumerFn(x);
  print(consumerFn);
  type(consumerFn);
}
higher(takeAnothaOne, 999);

# Validate that scopes are preserved, and a function can internal hide variables defined in outer scopes.
var test99: string = "THIS IS A STRING";
consumer checkVariableHiding(test99: int) {
  print(test99);
}
higher(checkVariableHiding, 3);
takeThis(test99);


# Procedures support multiple return statements.
print(testMultipleReturns(0));
# Try uncommenting the below invalid return stmt (not w/in a procedure body) and you'll see a compile-time error.
#return "this should be invalid but I don't necessarily know how to make that happen.";
function testMultipleReturns(x: int) -> string {
  if (x > 0) {
    return "positive";
  } else if (x == 0) {
    return "zero";
    # Try uncommenting the below invalid unreachable code and you'll see a compile-time error.
#    print("Unreachable stmts immediately following a return stmt are disallowed.");
  } else {
    return "negative";
  }
   # Try uncommenting the below invalid unreachable code and you'll see a compile-time error.
#  print("Unreachable stmts are disallowed.");
}


# This provider tests that returns that are hidden from branch inspection are handled properly giving
# the correct returned value.
provider testReturnsHiddenFromBranchInspection() -> int {
  if (true) {
    return 99;
  }
  # As a human, I'm aware that this return is unnecessary and that makes me sad that Claro doesn't
  # know the same thing yet...
  # TODO (steving) improve Claro's branch detection so that it would know that this unreachable return is...unreachable.
  return -1;
}
var testReturnsHiddenFromBranchInspectionRes = testReturnsHiddenFromBranchInspection();
if (testReturnsHiddenFromBranchInspectionRes  == -1) {
  print("BROKEN! BROKEN! BROKEN! - Hidden return was skipped and fell through to a return that should be unreachable.");
} else if (testReturnsHiddenFromBranchInspectionRes == 99) {
  print("Return stmts hidden from branch inspection work :).");
}