package com.claro;

import com.claro.ClaroParserException;
import com.claro.compiler_backends.interpreted.ScopedHeap;
import com.claro.intermediate_representation.*;
import com.claro.intermediate_representation.expressions.*;
import com.claro.intermediate_representation.expressions.bool.*;
import com.claro.intermediate_representation.expressions.numeric.*;
import com.claro.intermediate_representation.expressions.procedures.functions.*;
import com.claro.intermediate_representation.expressions.term.*;
import com.claro.intermediate_representation.statements.*;
import com.claro.intermediate_representation.statements.contracts.*;
import com.claro.intermediate_representation.statements.user_defined_type_def_stmts.*;
import com.claro.intermediate_representation.types.BaseType;
import com.claro.intermediate_representation.types.ClaroTypeException;
import com.claro.intermediate_representation.types.SupportsMutableVariant;
import com.claro.intermediate_representation.types.TypeProvider;
import com.claro.intermediate_representation.types.TypeProvider.ImmediateTypeProvider;
import com.claro.intermediate_representation.types.Type;
import com.claro.intermediate_representation.types.Types;
import com.claro.runtime_utilities.injector.InjectedKey;
import com.claro.runtime_utilities.injector.InjectedKeyIdentifier;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.base.Strings;
import java_cup.runtime.Symbol;
import java.lang.Math;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Stack;
import java.util.stream.Stream;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

action code {:
  AtomicReference<TypeProvider> returnTypeHolder;

  int indentationLevel = 1;

  public String getDisambiguatedExportedIdentifierName(String originalName) {
    return getDisambiguatedExportedIdentifierName(optionalModuleName.orElse(""), originalName);
  }

  public String getDisambiguatedExportedIdentifierName(String depModuleName, String originalName) {
    // Use a disambiguation prefix for namespacing required by dep modules.
    return String.format("%s$%s", originalName, ScopedHeap.getDefiningModuleDisambiguator(Optional.of(depModuleName)));
  }

  private String getIndents(int level) {
    StringBuilder res = new StringBuilder();
    for(int i = 0; i < level; i++) {
      res.append("\t");
    }
    return res.toString();
  }

  private Expr constructBinaryExpr(Expr a, LexedValue<String> op, Integer opleft, Integer opright, Expr b, Function<Supplier<String>, BiFunction<Integer, Integer, Expr>> constructor) {
    Supplier<String> currentLinesSupplier =
      joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(op.getCurrentInputLine(), opright), new Line(b.currentLine, b.currentLineNumber));
    int startCol = min(a.startCol, opleft, b.startCol);
    int endCol = max(a.endCol, opleft + op.getLen(), b.endCol);

    return constructor.apply(currentLinesSupplier).apply(startCol, endCol);
  }

  private CollectionSubscriptExpr constructCollectionSubscriptExpr(Expr l, LexedValue<String> lb, int lbleft, int lbright, Expr e, LexedValue<String> rb, int rbleft, int rbright) {
     Supplier<String> currentLinesSupplier =
        joinExprLines(new Line(l.currentLine, l.currentLineNumber), new Line(lb.getCurrentInputLine(), lbright), new Line(e.currentLine, e.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
     int startCol = min(l.startCol, lbleft, e.startCol, rbleft);
     int endCol = max(l.endCol, lbleft + lb.getLen(), e.endCol, rbleft + rb.getLen());

     return new CollectionSubscriptExpr(l, e, currentLinesSupplier, rbright, startCol, endCol);
  }

  private InputExpr constructInputExpr(
    Optional<LexedValue<String>> prompt, int promptleft, int promptright, LexedValue<String> i, int ileft, int iright, LexedValue<String> lp, int lpleft, int lpright, LexedValue<String> rp, int rpleft, int rpright
  ) {
     Supplier<String> currentLinesSupplier =
        prompt.isPresent()
        ? joinExprLines(new Line(i.getCurrentInputLine(), iright), new Line(lp.getCurrentInputLine(), lpright), new Line(prompt.get().getCurrentInputLine(), promptright), new Line(rp.getCurrentInputLine(), rpright))
        : joinExprLines(new Line(i.getCurrentInputLine(), iright), new Line(lp.getCurrentInputLine(), lpright), new Line(rp.getCurrentInputLine(), rpright));
     int startCol = min(ileft, lpleft, prompt.isPresent() ? promptleft : Integer.MAX_VALUE, rpleft);
     int endCol = max(ileft + i.getLen(), lpleft + lp.getLen(), prompt.isPresent() ? promptleft + prompt.get().getLen() : -1, rpleft + rp.getLen());

     return new InputExpr(prompt.map(p -> p.getVal()), currentLinesSupplier, rpright, startCol, endCol);
  }

  private Expr constructSetOrTuple(LexedValue<String> mut, int mutleft, int mutright, LexedValue<String> lp, int lpleft, int lpright, Expr head, LexedValue<String> c, int cleft, int cright, Symbol tailValues, LexedValue<String> rp, int rpleft, int rpright, BiFunction<ImmutableList<Expr>, Supplier<String>, BiFunction<Integer, Integer, Expr>> constructor) {
    Supplier<String> currentLinesSupplier =
       mut == null
       ? joinExprLines(new Line(lp.getCurrentInputLine(), lpright), new Line(head.currentLine, head.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue) tailValues.value).getCurrentInputLine(), tailValues.right), new Line(rp.getCurrentInputLine(), rpright))
       : joinExprLines(new Line(mut.getCurrentInputLine(), mutright), new Line(lp.getCurrentInputLine(), lpright), new Line(head.currentLine, head.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue) tailValues.value).getCurrentInputLine(), tailValues.right), new Line(rp.getCurrentInputLine(), rpright));
    int startCol = min(mutleft, lpleft, head.startCol, cleft, tailValues.left, rpleft);
    int endCol =
      mut == null
      ? max(lpleft + lp.getLen(), head.endCol, cleft + c.getLen(), tailValues.left + ((LexedValue) tailValues.value).getLen(), rpleft + rp.getLen())
      : max(mutleft + mut.getLen(), lpleft + lp.getLen(), head.endCol, cleft + c.getLen(), tailValues.left + ((LexedValue) tailValues.value).getLen(), rpleft + rp.getLen());

    ImmutableList.Builder<Expr> values = ImmutableList.builder();
    values.add(head);
    values.addAll(((LexedValue<ImmutableList.Builder<Expr>>) tailValues.value).getVal().build().reverse());
    return constructor.apply(values.build(), currentLinesSupplier).apply(startCol, endCol);
  }

  private Symbol constructBuiltinType(LexedValue<String> lb, int lbleft, int lbright, Symbol t, LexedValue<String> rb, int rbleft, int rbright, Function<LexedValue<TypeProvider>, TypeProvider> typeProviderConstructor) {
    LexedValue<TypeProvider> tLexedVal = (LexedValue<TypeProvider>) t.value;
    Supplier<String> currentLinesSupplier =
      joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(tLexedVal.getCurrentInputLine(), t.right), new Line(rb.getCurrentInputLine(), rbright));
    int startCol = min(lbleft, t.left, rbleft);
    int endCol = max(lbleft + lb.getLen(), t.left + tLexedVal.getLen(), rbleft + rb.getLen());

    return new Symbol(
      -1,
      startCol,
      endCol, // line number
      LexedValue.create(
        typeProviderConstructor.apply(tLexedVal),
        currentLinesSupplier,
        endCol - startCol)
      );
  }

  private ContractProcedureImplementationStmt constructContractProcImplStmtForGenericProcDefStmt(
      GenericFunctionDefinitionStmt f) {
    return new ContractProcedureImplementationStmt(
        f.functionName,
              (canonName, scopedHeap) -> {
          String origName = f.functionName;
          f.functionName = canonName;
          if (scopedHeap == null) {
            // In this case we're updating the name specifically for the sake of creating a name suitable for
                  // codegen, so that means we also need to update the monorphizations.
                  f.genericProcedureDefStmt.procedureName = canonName;
          } else {
            try {
              f.registerGenericProcedureTypeProvider(scopedHeap);
            } catch (Exception e) {
              throw new RuntimeException(e);
            }
          }
          return f;
        });
  }
:}

parser code {:
  public String generatedClassName = "CompiledClaroProgram";  // default to be overridden.
  public String parsedFileName = "CompiledClaroProgram";  // default to be overridden.
  public String package_string = "";  // default to be overridden.
  public Optional<String> optionalModuleName = Optional.empty(); // default to be overridden. Something like "DepModule".
  public Optional<String> optionalUniqueModuleName = Optional.empty(); // default to be overridden. Something like "src$com$foo$module".
  public Consumer<String> printerDelegate = System.out::println;

  public int errorsFound = 0;
  public static Stack<Runnable> errorMessages = new Stack<>();

  @Override
  public void report_error(String message, Object info) {
    errorsFound++;
    Symbol currSymbol = (Symbol) info;
    LexedValue<?> lexedValue = (LexedValue) currSymbol.value;

    errorMessages.push(
      () -> {
        // It's possible that this is just a terminal report from JCUP.
        if (lexedValue == null) {
          return;
        }
        System.err.print(String.format("%s.claro:%s: ", parsedFileName, currSymbol.right + 1));
        System.err.println("Unexpected token <" + lexedValue.getVal() + ">");
        String currentInputLineString = lexedValue.getCurrentInputLine().get();
        if (Character.isWhitespace(currentInputLineString.charAt(currentInputLineString.length() - 1))) {
          int trailingWhitespaceStart = currentInputLineString.length();
          while (Character.isWhitespace(currentInputLineString.charAt(--trailingWhitespaceStart))); // This is just cute for the sake of it....barf...but I'm keeping it lol.
          System.err.println(currentInputLineString.substring(0, trailingWhitespaceStart + 1));
        } else {
          System.err.println(lexedValue.getCurrentInputLine().get());
        }
        System.err.println(Strings.repeat(" ", currSymbol.left) + '^');
      });
  }

  @Override
  public void syntax_error(Symbol cur_token) {
    this.report_error("Syntax error", cur_token);
  }

  static class Line {
    Supplier<String> inputLineSupplier;
    int inputLineNumber;

    Line(StringBuilder inputLine, int inputLineNumber) {
      this(() -> inputLine.toString(), inputLineNumber);
    }

    Line(Expr e) {
      this(e.currentLine, e.currentLineNumber);
    }

    Line(Symbol s) {
      this(((LexedValue<?>)s.value).getCurrentInputLine(), s.right);
    }

    Line(Supplier<String> inputLineSupplier, int inputLineNumber) {
      this.inputLineSupplier = inputLineSupplier;
      this.inputLineNumber = inputLineNumber;
    }
  }

  private Supplier<String> joinExprLines(Line ... linesToJoin) {
    return () -> {
        StringBuilder res = new StringBuilder(linesToJoin[0].inputLineSupplier.get());
        int prevLineNum = linesToJoin[0].inputLineNumber;
        for (int i = 1; i < linesToJoin.length; i++) {
          Line curr = linesToJoin[i];
          if (curr.inputLineNumber != prevLineNum) {
            prevLineNum = curr.inputLineNumber;
            res.append(curr.inputLineSupplier.get());
          }
        }
        return res.toString();
    };
  }

  // Super obnoxious code...but for the sake of hacking together input text annotations for nonterminal grammar matches
  // so that we can plumb it up into the AST, this code aggregates data from multiple Symbols into a single one.
  private <T> Symbol chainSymbols(T value, Symbol ... symbols) {
    Stream<Symbol> symbolStream = Arrays.stream(symbols);
    int minStartCol = Integer.MAX_VALUE; // min column
    int maxEndCol = Integer.MIN_VALUE; // max column
    int maxLine = Integer.MIN_VALUE; // max line
    for (int i = 0; i<symbols.length; i++) {
      minStartCol = Math.min(symbols[i].left, minStartCol);
      maxEndCol = Math.max(symbols[i].left + ((LexedValue)symbols[i].value).getLen(), maxEndCol);
      maxLine = Math.max(symbols[i].right, maxLine);
    }
    int aggregateLen = maxEndCol - minStartCol;

    Supplier<String> inputLinesSupplier = () -> {
      StringBuilder inputLines = new StringBuilder();
      symbolStream.map(s -> ((LexedValue)s.value).getCurrentInputLine()).forEach(inputLines::append);
      return inputLines.toString();
    };
    return new Symbol(
      -1, // Really I just have no better value to put in here.
      minStartCol,
      maxLine,
      LexedValue.create(value, inputLinesSupplier, aggregateLen)
    );
  }

  private static int min(int ... nums) {
    int currMin = Integer.MAX_VALUE;
    for (int x : nums) {
      currMin = Math.min(x, currMin);
    }
    return currMin;
  }

  private static int max(int ... nums) {
    int currMax = Integer.MIN_VALUE;
    for (int x : nums) {
      currMax = Math.max(x, currMax);
    }
    return currMax;
  }
:}

terminal LexedValue<String>  LPAR, RPAR;
terminal LexedValue<String>  LCURLY, RCURLY, LBRACKET, RBRACKET;
terminal LexedValue<String>  EXPONENTIATE;
terminal LexedValue<String>  MULTIPLY, DIVIDE, MODULUS;
terminal LexedValue<String>  PLUS, MINUS;
terminal LexedValue<String>  INCREMENT, DECREMENT;
terminal LexedValue<String>  SEMICOLON;
terminal LexedValue<String>  COLON;
terminal LexedValue<String>  COMMA;
terminal LexedValue<String>  BAR;
terminal LexedValue<String>  EQUALS, NOT_EQUALS;
terminal LexedValue<String>  UNDERSCORE;
terminal LexedValue<String>  VAR, ASSIGNMENT;
terminal LexedValue<String>  L_ANGLE_BRACKET, R_ANGLE_BRACKET, LTE, GTE;
terminal LexedValue<String>  OR, AND, NOT;
terminal LexedValue<String>  IN;
terminal LexedValue<String>  INSTANCEOF;
terminal LexedValue<String>  ARROW, UP_ARROW, PIPE_ARROW, IMPLICATION_ARROW;
terminal LexedValue<Boolean> TRUE, FALSE;
// An integer is also a terminal, but it's of type Integer.
terminal LexedValue<Integer> INTEGER;
terminal LexedValue<String>  LONG, DOUBLE;
// A float is also a terminal, but it's of type Double.
terminal LexedValue<Double>  FLOAT;
// A string is also a terminal, but it's of type String.
terminal LexedValue<String>  STRING, FMT_STRING_PART;
terminal LexedValue<Character> CHAR;
// A variable identifier is just a sequence of chars.
terminal LexedValue<String>  IDENTIFIER;
terminal LexedValue<ScopedIdentifier> SCOPED_IDENTIFIER;
// The prefix "log_", of the function log_x(y), is also a terminal.
// This is good practice for figuring out how to handle functions
// once I get to Claro, consider this a function hard-coded into the
// grammar.
terminal LexedValue<String>  LOG_PREFIX;
// This grammar also has a builtin print() function for printing expr values.
terminal LexedValue<String>  PRINT;
// This grammar also has a builtin sleep() function.
terminal LexedValue<String>  SLEEP;
// This grammar also has a builtin numeric() function for casting booleans to doubles.
terminal LexedValue<String>  NUMERIC_BOOL;
// This grammar also has a builtin input() function for reading a line from stdin.
terminal LexedValue<String>  INPUT;
// This grammar also has a builtin copy() function for efficiently and conveniently copying data.
terminal LexedValue<String>  COPY;
// This grammar also has a builtin fromJson() function for efficiently and conveniently parsing JSON.
terminal LexedValue<String>  FROM_JSON;
// This grammar also has a builtin isInputReady() function for checking whether a line is ready to be read on stdin.
terminal LexedValue<String>  IS_INPUT_READY;
// This grammar also has a builtin len() function for getting the length of an Iterable.
terminal LexedValue<String>  LEN;
// This grammar also has a builtin type() function for getting the type of an Expr.
terminal LexedValue<String>  TYPE;
// This grammar also has a builtin append() function for appending an element to a List.
terminal LexedValue<String>  REMOVE;
terminal LexedValue<String>  IF, ELSE;
terminal LexedValue<String>  WHILE, FOR, REPEAT, BREAK, CONTINUE, WHERE, MATCH, CASE;
// Builtin Types (with keywords instead of symbolic notation, e.g. list is [<type>]).
terminal LexedValue<String>  INT_TYPE, LONG_TYPE, FLOAT_TYPE, DOUBLE_TYPE, BOOLEAN_TYPE, STRING_TYPE, CHAR_TYPE,
                             TUPLE_TYPE, STRUCT_TYPE, ONEOF, FUNCTION_TYPE, CONSUMER_FUNCTION_TYPE,
                             PROVIDER_FUNCTION_TYPE, LAMBDA;
terminal LexedValue<String>  ALIAS;
terminal LexedValue<String>  ATOM, NEWTYPE, UNWRAP, INITIALIZERS, UNWRAPPERS;
terminal LexedValue<String>  RETURN, QUESTION_MARK_ASSIGNMENT;
terminal LexedValue<String>  MUT;
terminal LexedValue<String>  DOT;
terminal LexedValue<String>  MODULE, BIND, TO, AS, USING;
terminal LexedValue<String>  FUTURE, BLOCKING_GET, BLOCKING, MAYBE_BLOCKING, GRAPH, ROOT, NODE, LEFT_ARROW, AT;
terminal LexedValue<String>  CONTRACT, IMPLEMENT, REQUIRES;
terminal LexedValue<String>  CAST;
terminal LexedValue<String>  HTTP_SERVICE, HTTP_CLIENT, GET_HTTP_CLIENT, HTTP_SERVER, HTTP_RESPONSE, ENDPOINT_HANDLERS, GET_BASIC_HTTP_SERVER_FOR_PORT;
terminal LexedValue<String>  PRIVILEGED_INLINE_JAVA, SYNTHETIC_JAVA_TYPE;

// DEBUGGING keywords which should be removed when we want a real release....
terminal LexedValue<String>  DEBUG_DUMP_SCOPE;

// Declare which type will be returned by each nonterminal grammar production.
nonterminal ProgramNode                        program;
nonterminal Expr                               expr;
nonterminal Expr                               non_lambda_exprs;
nonterminal ParenthesizedExpr                  parenthesized_expr;
nonterminal Symbol/*ImmutableList<ImmutableList.Builder>*/  fmt_string;
nonterminal Term                               term;
nonterminal Term                               primitive;
nonterminal IdentifierReferenceTerm            identifier;
nonterminal ScopedIdentifier                   scoped_identifier;
nonterminal FloatTerm                          float;
nonterminal IntegerTerm                        integer;
nonterminal Stmt                               stmt;
nonterminal StmtListNode                       stmt_list;
nonterminal StmtListNode                       stmts_and_defs_list;
nonterminal ListExpr                           list;
nonterminal MapExpr                            map;
nonterminal ImmutableList.Builder/*<ImmutableList<Expr>>*/ map_initializer_kv_list;
nonterminal TupleExpr                          tuple;
nonterminal SetExpr                            set;
nonterminal StructExpr                         struct;
nonterminal Symbol/*ImmutableMap.Builder<String, Expr>*/ struct_field_initializers_list;
nonterminal StructFieldAccessExpr              struct_field_access_expr;
nonterminal StructFieldAssignmentStmt          struct_field_assignment_stmt;
nonterminal CollectionSubscriptExpr            collection_subscript;
nonterminal Symbol/*ImmutableList.Builder<Expr>*/  args_list;
nonterminal IfStmt                             if_else_chain_stmt;
nonterminal IfStmt                             if_stmt;
nonterminal IfStmt                             else_if_stmt_chain;
nonterminal IfStmt                             else_if_stmt;
nonterminal StmtListNode                       else_stmt;
nonterminal WhileStmt                          while_stmt;
nonterminal ForLoopStmt                        for_loop_stmt;
nonterminal RepeatStmt                         repeat_stmt;
nonterminal BreakStmt                          break_stmt;
nonterminal ContinueStmt                       continue_stmt;
nonterminal MatchStmt                          match_stmt;
nonterminal ImmutableList.Builder/*<ImmutableList<Object>>*/ match_cases_list_stmt;
nonterminal MatchStmt.TypeMatchPattern<? extends Type> match_case_patterns;
nonterminal ImmutableList.Builder/*<Object>*/  match_multi_expr_case;
nonterminal ImmutableList.Builder/*<MatchStmt.TypeMatchPattern<? extends Type>>*/ match_case_patterns_list;
nonterminal ImmutableList.Builder/*<MatchStmt.StructFieldPattern>*/ match_case_pattern_struct_field_list;
nonterminal ComprehensionExpr                  list_comprehension_expr;
nonterminal ComprehensionExpr                  set_comprehension_expr;
nonterminal ComprehensionExpr                  map_comprehension_expr;
nonterminal AliasStmt                          alias_stmt;
nonterminal AtomDefinitionStmt                 atom_def_stmt;
nonterminal NewTypeDefStmt                     newtype_def_stmt;
nonterminal ImmutableList.Builder<Stmt>        initializers_or_unwrappers_proc_defs_list;
nonterminal InitializersBlockStmt              initializers_block_stmt;
nonterminal UnwrappersBlockStmt                unwrappers_block_stmt;
nonterminal UnwrapUserDefinedTypeExpr          unwrap_expr;
nonterminal CopyExpr                           copy_expr;
nonterminal FromJsonExpr                       from_json_expr;
nonterminal PrintStmt                          print;
nonterminal SleepStmt                          sleep;
nonterminal ShowTypeStmt                       show_type;
nonterminal DeclarationStmt                    identifier_declaration;
nonterminal AssignmentStmt                     identifier_assignment;
nonterminal TrashcanAssignmentStmt             trashcan_assignment;
nonterminal IncrementExpr                      identifier_increment;
nonterminal IncrementStmt                      identifier_increment_stmt;
nonterminal DecrementExpr                      identifier_decrement;
nonterminal DecrementStmt                      identifier_decrement_stmt;
nonterminal ListElementAssignmentStmt          list_element_assignment;
nonterminal RemoveElementFromListExpr          list_remove_expr;
nonterminal FunctionDefinitionStmt             function_definition_stmt;
nonterminal GenericFunctionDefinitionStmt      generic_function_definition_stmt;
nonterminal LambdaExpr                         lambda_function_expr;
nonterminal CastExpr/*wrapping LambdaExpr*/    typed_lambda_function_expr;
nonterminal Symbol/*ImmutableMap.Builder<String, TypeProvider>*/ function_args_types_list;
nonterminal Symbol/*ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>*/ function_args_types_list_identifiers;
nonterminal Symbol/*ImmutableList.Builder<String>*/  identifier_list;
nonterminal ImmutableList<String>              generic_blocking_on;
nonterminal ImmutableList.Builder<String>      identifier_bar_sep_list;
nonterminal TypeProvider                       maybe_blocking_procedure_types;
nonterminal ImmutableMap.Builder<String, TypeProvider> procedure_args_w_generic_blocking;
nonterminal ConsumerFunctionDefinitionStmt     consumer_function_definition_stmt;
nonterminal GenericFunctionDefinitionStmt      generic_consumer_function_definition_stmt;
nonterminal ProviderFunctionDefinitionStmt     provider_function_definition_stmt;
nonterminal GenericFunctionDefinitionStmt      generic_provider_function_definition_stmt;
nonterminal GraphFunctionDefinitionStmt        graph_function_definition_stmt;
nonterminal GraphProviderDefinitionStmt        graph_provider_definition_stmt;
nonterminal GraphConsumerDefinitionStmt        graph_consumer_definition_stmt;
nonterminal GraphNodeDefinitionStmt            root_node;
nonterminal GraphNodeDefinitionStmt            non_root_node;
nonterminal ImmutableList.Builder<GraphNodeDefinitionStmt> non_root_nodes_list;
nonterminal GraphNodeReferenceExpr             node_reference;
nonterminal ContractDefinitionStmt             contract_definition_stmt;
nonterminal ImmutableList.Builder<ContractProcedureSignatureDefinitionStmt> contract_signature_defs_list;
nonterminal ContractProcedureSignatureDefinitionStmt contract_procedure_signature_definition_stmt;
nonterminal ContractImplementationStmt         contract_implementation_stmt;
nonterminal ImmutableList.Builder<ContractProcedureImplementationStmt> contract_implementations_list;
// Unfortunately IntelliJ is starting to take a dump on this file since it's gotten massive, so it will no longer
// correctly parse this type even though JCup and Java are handling the file like a champ.
nonterminal ImmutableListMultimap.Builder/*<String, ImmutableList<Type>>*/  required_contracts;
nonterminal PipeChainStmt                      pipe_chain_stmt;
// This is just because Java is hot garbage and doesn't have tuples. The first entry will be a sink stmt.
// The second entry will be an ImmutableList.Builder<Expr>. The Expr will be required to contain some
// backreference to the value piped from the previous expr.
//  except that it will also need to be able to either make itself a codegen inlining of the prior expr, or it will
//  need to reference a generated identifier for an intermediate temporary.
nonterminal ImmutableList<Object>              pipe_chain;
nonterminal ReturnStmt                         return_stmt;
nonterminal /*(FirstClass)?FunctionCall*/Expr  function_call_expr;
nonterminal /*(FirstClass)?ProviderFunctionCall*/Expr provider_function_call_expr;
nonterminal /*(FirstClass)?ConsumerFunctionCall*/Stmt consumer_function_call_stmt;
nonterminal InputExpr                          input;
nonterminal IsInputReadyExpr                   is_input_ready;
nonterminal Expr/*BoolExpr*/                   bool_expr;
nonterminal Expr/*BoolExpr*/                   equality;
nonterminal Expr/*BoolExpr*/                   inequality;
nonterminal Expr/*BoolExpr*/                   bool_arithmetic;
nonterminal Expr/*BoolExpr*/                   instanceof_expr;
nonterminal Symbol/*TypeProvider*/             builtin_type;
nonterminal Symbol/*TypeProvider*/             base_builtin_type_without_mutability_modifier;
nonterminal Symbol/*ImmutableList<TypeProvider>*/  builtin_types_list;
nonterminal Symbol/*ImmutableList.Builder<TypeProvider>*/ backwards_builtin_types_list;
nonterminal Stmt                               debug_stmts;
nonterminal ModuleDefinitionStmt               module_definition_stmt;
nonterminal StmtListNode                       bind_stmts_list;
nonterminal BindStmt                           bind_stmt;
nonterminal UsingBlockStmt                     using_block_stmt;
nonterminal Symbol/*ImmutableList.Builder<InjectedKey>*/ injected_keys_list;
nonterminal HttpServiceDefStmt                 http_service_def_stmt;
nonterminal ImmutableMap.Builder<IdentifierReferenceTerm, Object/*oneof<String, FormatStringExpr>*/> http_endpoints_list;
nonterminal EndpointHandlersBlockStmt          endpoint_handlers_block_stmt;
nonterminal ImmutableList.Builder<GraphProcedureDefinitionStmt> endpoint_handler_impl_graphs_list;
nonterminal GetHttpClientExpr                  get_http_client_expr;
nonterminal GetHttpServerExpr                  get_basic_http_server_for_port_expr;
nonterminal PrivilegedInlineJavaStmt           privileged_inline_java;

// Lower precedence things at the top, higher precedence things at the bottom.
// ...but also I've basically put no thought whatsoever into the order these ACTUALLY appear in.
precedence right ARROW;
precedence right QUESTION_MARK_ASSIGNMENT;
precedence left INSTANCEOF;
precedence left IN;
precedence left COMMA;
precedence left IDENTIFIER;
precedence left SEMICOLON;
precedence left ASSIGNMENT;
precedence left COLON;
precedence left EQUALS, NOT_EQUALS;
precedence left AND, OR, NOT;
precedence left L_ANGLE_BRACKET, R_ANGLE_BRACKET, LTE, GTE;
precedence left PLUS, MINUS;
precedence left INCREMENT, DECREMENT;
precedence left MULTIPLY, DIVIDE, MODULUS;
precedence left EXPONENTIATE;
precedence left LOG_PREFIX, IF, ELSE;
precedence left WHILE, FOR, REPEAT, BREAK, WHERE;
precedence left QUESTION_MARK_ASSIGNMENT;
precedence left DOT;
precedence left LPAR, RPAR, LBRACKET, RBRACKET;

// This is where the grammar starts.
program ::=
    stmts_and_defs_list:s
    {:
       RESULT = new ProgramNode(s, package_string, generatedClassName);
    :}
  ;

// TODO(steving) Add procedure defs to this target so that they also can only be used at the top level.
stmts_and_defs_list ::=
    stmt:s stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(s, tail); :}
  | module_definition_stmt:m stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(m, tail); :}
  | contract_definition_stmt:c stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(c, tail); :}
  | contract_implementation_stmt:c stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(c, tail); :}
  | generic_function_definition_stmt:f stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(f, tail); :}
  | generic_consumer_function_definition_stmt:f stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(f, tail); :}
  | generic_provider_function_definition_stmt:f stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(f, tail); :}

  // We'll allow files with only a single one of these following stmts as well.
  | stmt:s
    {: RESULT = new StmtListNode(s); :}
  | module_definition_stmt:m
    {: RESULT = new StmtListNode(m); :}
  | contract_definition_stmt:c
    {: RESULT = new StmtListNode(c); :}
  | contract_implementation_stmt:c
    {: RESULT = new StmtListNode(c); :}
  | generic_function_definition_stmt:f
    {: RESULT = new StmtListNode(f); :}
  | generic_consumer_function_definition_stmt:f
    {: RESULT = new StmtListNode(f); :}
  | generic_provider_function_definition_stmt:f
    {: RESULT = new StmtListNode(f); :}
  ;

stmt_list ::=
    stmt:head stmt_list:tail
    {: RESULT = new StmtListNode(head, tail); :}
  | stmt:s
    {: RESULT = new StmtListNode(s); :}
  | debug_stmts:d
    {: RESULT = new StmtListNode(d); :}
  ;

debug_stmts ::=
    DEBUG_DUMP_SCOPE LPAR RPAR SEMICOLON
    {:
       RESULT =
         new PrintStmt(
           new StringTerm(null, ()-> "", 0,0,0) {
             @Override
             public Object generateInterpretedOutput(ScopedHeap scopedHeap) {
               return scopedHeap;
             }
           },
           printerDelegate
         );
    :}
  ;

stmt ::=
    print:p
    {: RESULT = p; :}
  | show_type:s
    {: RESULT = s; :}
  | identifier_declaration:d
    {: RESULT = d; :}
  | identifier_assignment:a
    {: RESULT = a; :}
  | trashcan_assignment:t
    {: RESULT = t; :}
  | identifier_increment_stmt:i
    {: RESULT = i; :}
  | identifier_decrement_stmt:i
    {: RESULT = i; :}
  | struct_field_assignment_stmt:s
    {: RESULT = s; :}
  | list_element_assignment:l
    {: RESULT = l; :}
  | if_else_chain_stmt:i
    {: RESULT = i; :}
  | match_stmt:m
    {: RESULT = m; :}
  | while_stmt:w
    {: RESULT = w; :}
  | for_loop_stmt:f
    {: RESULT = f; :}
  | repeat_stmt:r
    {: RESULT = r; :}
  | break_stmt:b
    {: RESULT = b; :}
  | continue_stmt:c
    {: RESULT = c; :}
  | function_definition_stmt:f
    {: RESULT = f; :}
  | consumer_function_definition_stmt:f
    {: RESULT = f; :}
  | provider_function_definition_stmt:pf
    {: RESULT = pf; :}
  | consumer_function_call_stmt:cf
    {: RESULT = cf; :}
  | graph_function_definition_stmt:gf
    {: RESULT = gf; :}
  | graph_provider_definition_stmt:gf
    {: RESULT = gf; :}
  | graph_consumer_definition_stmt:gf
    {: RESULT = gf; :}
  | initializers_block_stmt:i
    {: RESULT = i; :}
  | unwrappers_block_stmt:u
    {: RESULT = u; :}
  | return_stmt:r
    {: RESULT = r; :}
  | alias_stmt:a
    {: RESULT = a; :}
  | atom_def_stmt:a
    {: RESULT = a; :}
  | newtype_def_stmt:n
    {: RESULT = n; :}
  | using_block_stmt:u
    {: RESULT = u; :}
  | pipe_chain_stmt:p
    {: RESULT = p; :}
  | http_service_def_stmt:h
    {: RESULT = h; :}
  | endpoint_handlers_block_stmt:e
    {: RESULT = e; :}
  | sleep:s
    {: RESULT = s; :}
  | privileged_inline_java:java
    {: RESULT = java; :}
  ;

module_definition_stmt ::=
    MODULE IDENTIFIER:i LCURLY bind_stmts_list:b RCURLY
    {: RESULT = new ModuleDefinitionStmt(i.getVal(), b); :}
  | MODULE IDENTIFIER:i USING LPAR identifier_list:modules RPAR LCURLY bind_stmts_list:b RCURLY
    {:
      ImmutableList<String> moduleList =
        ((LexedValue<ImmutableList.Builder<String>>)modules.value).getVal().build().reverse();
      RESULT = new ModuleDefinitionStmt(i.getVal(), Optional.of(moduleList), b);
    :}
  ;

bind_stmts_list ::=
    bind_stmt:head bind_stmts_list:tail
    {: RESULT = new StmtListNode(head, tail); :}
  | bind_stmt:s
    {: RESULT = new StmtListNode(s); :}
  ;

bind_stmt ::=
    BIND IDENTIFIER:i COLON builtin_type:t TO expr:e SEMICOLON
    {: RESULT = new BindStmt(i.getVal(), ((LexedValue<TypeProvider>) t.value).getVal(), e); :}
  ;

using_block_stmt ::=
    USING LPAR identifier_list:modules RPAR LCURLY stmt_list:s RCURLY
    {:
       ImmutableList<String> moduleList =
         ((LexedValue<ImmutableList.Builder<String>>)modules.value).getVal().build().reverse();
       RESULT = new UsingBlockStmt(moduleList, s, true);
    :}
  ;

print ::=
    PRINT LPAR expr:e RPAR SEMICOLON
    {: RESULT = new PrintStmt(e, printerDelegate); :}
  ;

show_type ::=
    TYPE LPAR expr:e RPAR SEMICOLON
    {: RESULT = new ShowTypeStmt(e); :}
  ;

unwrap_expr ::=
    UNWRAP:u LPAR:l expr:expr RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(u.getCurrentInputLine(), uright), new Line(l.getCurrentInputLine(), lright), new Line(expr), new Line(r.getCurrentInputLine(), rright));
       int startCol = min(uleft, lleft, expr.startCol, rleft);
       int endCol = max(uleft + u.getLen(), lleft + l.getLen(), expr.endCol, rleft + r.getLen());
       RESULT = new UnwrapUserDefinedTypeExpr(expr, currentLinesSupplier, rright, startCol, endCol);
    :}
  ;

identifier_declaration ::=
    VAR IDENTIFIER:identifier ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.getVal(), e); :}
  | VAR IDENTIFIER:identifier COLON builtin_type:t SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.getVal(), ((LexedValue<TypeProvider>) t.value).getVal()); :}
  | VAR IDENTIFIER:identifier COLON builtin_type:t ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.getVal(), ((LexedValue<TypeProvider>) t.value).getVal(), e); :}

  // Blocking variants.
  | VAR IDENTIFIER:identifier COLON builtin_type:t BLOCKING_GET expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.getVal(), ((LexedValue<TypeProvider>) t.value).getVal(), e, /*allowVariableHiding=*/false, /*blocking=*/true, /*errorProp=*/false); :}
  | VAR IDENTIFIER:identifier BLOCKING_GET expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.getVal(), e, /*blocking=*/true, /*errorProp=*/false); :}

  // Automatic error propagation variants.
  | VAR IDENTIFIER:identifier COLON builtin_type:t QUESTION_MARK_ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.getVal(), ((LexedValue<TypeProvider>) t.value).getVal(), e, /*allowVariableHiding=*/false, /*blocking=*/false, /*errorProp=*/true); :}
  | VAR IDENTIFIER:identifier QUESTION_MARK_ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.getVal(), e, /*blocking=*/false, /*errorProp=*/true); :}
  ;

alias_stmt ::=
    ALIAS IDENTIFIER:alias COLON builtin_type:aliased_type
    {:
       LexedValue<TypeProvider> aliasedTypeLexedVal = (LexedValue<TypeProvider>) aliased_type.value;
       RESULT = new AliasStmt(alias.getVal(), aliasedTypeLexedVal.getVal());
    :}
  ;

atom_def_stmt ::=
    ATOM identifier:name
    {: RESULT = new AtomDefinitionStmt(name); :}
  ;

newtype_def_stmt ::=
    NEWTYPE IDENTIFIER:type_name COLON builtin_type:base_type
    {:
       LexedValue<TypeProvider> baseTypeLexedVal = (LexedValue<TypeProvider>) base_type.value;
       RESULT = new NewTypeDefStmt(type_name.getVal(), optionalUniqueModuleName, baseTypeLexedVal.getVal());
    :}
  | NEWTYPE IDENTIFIER:type_name L_ANGLE_BRACKET identifier_list:parameterized_type_names R_ANGLE_BRACKET COLON builtin_type:base_type
    {:
       LexedValue<TypeProvider> baseTypeLexedVal = (LexedValue<TypeProvider>) base_type.value;
       RESULT = new NewTypeDefStmt(type_name.getVal(), optionalUniqueModuleName, baseTypeLexedVal.getVal(), ((LexedValue<ImmutableList.Builder<String>>)parameterized_type_names.value).getVal().build().reverse());
    :}
  ;

initializers_block_stmt ::=
    INITIALIZERS:i IDENTIFIER:initialized_type LCURLY:lc initializers_or_unwrappers_proc_defs_list:initializer_defs RCURLY:rc
    {:
       RESULT = new InitializersBlockStmt(initialized_type.getVal(), initializer_defs.build().reverse());
    :}
  ;

unwrappers_block_stmt ::=
    UNWRAPPERS:u IDENTIFIER:unwrapped_type LCURLY:lc initializers_or_unwrappers_proc_defs_list:unwrapper_defs RCURLY:rc
    {:
       RESULT = new UnwrappersBlockStmt(unwrapped_type.getVal(), unwrapper_defs.build().reverse());
    :}
  ;

  // TODO(steving) Add support for Generic Graph Procedures when available.
initializers_or_unwrappers_proc_defs_list ::=
    function_definition_stmt:def initializers_or_unwrappers_proc_defs_list:tail
    {: RESULT = tail.add(def); :}
  | provider_function_definition_stmt:def initializers_or_unwrappers_proc_defs_list:tail
    {: RESULT = tail.add(def); :}
  | consumer_function_definition_stmt:def initializers_or_unwrappers_proc_defs_list:tail
    {: RESULT = tail.add(def); :}
  | graph_function_definition_stmt:def initializers_or_unwrappers_proc_defs_list:tail
    {: RESULT = tail.add(def); :}
  | graph_provider_definition_stmt:def initializers_or_unwrappers_proc_defs_list:tail
    {: RESULT = tail.add(def); :}
  | generic_function_definition_stmt:def initializers_or_unwrappers_proc_defs_list:tail
    {: RESULT = tail.add(def); :}
  | generic_provider_function_definition_stmt:def initializers_or_unwrappers_proc_defs_list:tail
    {: RESULT = tail.add(def); :}
  | generic_consumer_function_definition_stmt:def initializers_or_unwrappers_proc_defs_list:tail
    {: RESULT = tail.add(def); :}
  | function_definition_stmt:def
    {: RESULT = ImmutableList.<Stmt>builder().add(def); :}
  | provider_function_definition_stmt:def
    {: RESULT = ImmutableList.<Stmt>builder().add(def); :}
  | consumer_function_definition_stmt:def
    {: RESULT = ImmutableList.<Stmt>builder().add(def); :}
  | graph_function_definition_stmt:def
    {: RESULT = ImmutableList.<Stmt>builder().add(def); :}
  | graph_provider_definition_stmt:def
    {: RESULT = ImmutableList.<Stmt>builder().add(def); :}
  | generic_function_definition_stmt:def
    {: RESULT = ImmutableList.<Stmt>builder().add(def); :}
  | generic_provider_function_definition_stmt:def
    {: RESULT = ImmutableList.<Stmt>builder().add(def); :}
  | generic_consumer_function_definition_stmt:def
    {: RESULT = ImmutableList.<Stmt>builder().add(def); :}
  ;

builtin_type ::=
    base_builtin_type_without_mutability_modifier:base_type
    {: RESULT = base_type; :}
  | MUT:m base_builtin_type_without_mutability_modifier:base_type
    {:
       RESULT = constructBuiltinType(
           m, mleft, mright, base_type, LexedValue.create("", () -> "", 0), base_type.left + ((LexedValue) base_type.value).getLen(), base_type.right,
           tLexedVal -> (TypeProvider) (scopedHeap) -> {
                Type resolvedType = tLexedVal.getVal().resolveType(scopedHeap);
                // Literally all I need to do is manually mark the thing mutable if mutability is supported for this type.
                if (resolvedType instanceof SupportsMutableVariant) {
                  return ((SupportsMutableVariant) resolvedType).toShallowlyMutableVariant();
                } else {
                  // Java is stupid, I hate the concept of checked exceptions. If you're going to give me exceptions,
                  // please make them "just work".
                  throw new RuntimeException(
                    ClaroTypeException.forIllegalMutableTypeAnnotationOnInherentlyImmutableType(resolvedType));
                }
           });
    :}
  ;

base_builtin_type_without_mutability_modifier ::=
    INT_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.INTEGER),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | LONG_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.LONG),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | FLOAT_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.FLOAT),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | DOUBLE_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.DOUBLE),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | BOOLEAN_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.BOOLEAN),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | STRING_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.STRING),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | CHAR_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.CHAR),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | LBRACKET:lb builtin_type:t RBRACKET:rb
    {:
       RESULT = constructBuiltinType(
           lb, lbleft, lbright, t, rb, rbleft, rbright,
           tLexedVal -> (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.ListType.forValueType(tLexedVal.getVal().resolveType(scopedHeap));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
           });
    :}
  | LCURLY:lb builtin_type:t RCURLY:rb
    {:
       RESULT = constructBuiltinType(
           lb, lbleft, lbright, t, rb, rbleft, rbright,
           tLexedVal -> (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.SetType.forValueType(tLexedVal.getVal().resolveType(scopedHeap));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
           });
    :}
  | LCURLY:la builtin_type:key COLON:c builtin_type:value RCURLY:ra
    // Maps are defined like {string:int} to avoid a new keyword `map` since I'd like to not impair functional style,
    // where map is a well known function.
    {:
       LexedValue<TypeProvider> keyLexedVal = (LexedValue<TypeProvider>) key.value;
       LexedValue<TypeProvider> valueLexedVal = (LexedValue<TypeProvider>) value.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(la.getCurrentInputLine(), laright), new Line(keyLexedVal.getCurrentInputLine(), key.right), new Line(c.getCurrentInputLine(), cright), new Line(valueLexedVal.getCurrentInputLine(), value.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(laleft, key.left, cleft, value.left, raleft);
       int endCol = max(laleft + la.getLen(), key.left + keyLexedVal.getLen(), cleft + c.getLen(), value.left + valueLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.MapType.forKeyValueTypes(keyLexedVal.getVal().resolveType(scopedHeap), valueLexedVal.getVal().resolveType(scopedHeap));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
              },
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | ONEOF:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg_types.left + argTypesLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.OneofType.forVariantTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
              },
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argLexedVal.getCurrentInputLine(), arg.right), new Line(a.getCurrentInputLine(), aright), new Line(outputTypeLexedVal.getCurrentInputLine(), output_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg.left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg.left + argLexedVal.getLen(), aleft + a.getLen(), output_type.left + outputTypeLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.getVal().resolveType(scopedHeap)), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(b1.getCurrentInputLine(), b1right), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(b2.getCurrentInputLine(), b2right), new Line(a.getCurrentInputLine(), aright), new Line(outputTypeLexedVal.getCurrentInputLine(), output_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, b1left, arg_types.left, b2left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), b1left + b1.getLen(), arg_types.left + argTypesLexedVal.getLen(), b2left + b2.getLen(), aleft + a.getLen(), output_type.left + outputTypeLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argLexedVal.getCurrentInputLine(), arg.right), new Line(a.getCurrentInputLine(), aright), new Line(outputTypeLexedVal.getCurrentInputLine(), output_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg.left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg.left + argLexedVal.getLen(), aleft + a.getLen(), output_type.left + outputTypeLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.getVal().resolveType(scopedHeap)), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(b1.getCurrentInputLine(), b1right), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(b2.getCurrentInputLine(), b2right), new Line(a.getCurrentInputLine(), aright), new Line(outputTypeLexedVal.getCurrentInputLine(), output_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, b1left, arg_types.left, b2left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), b1left + b1.getLen(), arg_types.left + argTypesLexedVal.getLen(), b2left + b2.getLen(), aleft + a.getLen(), output_type.left + outputTypeLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg_types.left + argTypesLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg_types.left + argTypesLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | PROVIDER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:return_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> returnTypeProvider = (LexedValue<TypeProvider>) return_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(returnTypeProvider.getCurrentInputLine(), return_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, return_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), return_type.left + returnTypeProvider.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(returnTypeProvider.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING PROVIDER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:return_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> returnTypeProvider = (LexedValue<TypeProvider>) return_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(returnTypeProvider.getCurrentInputLine(), return_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, return_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), return_type.left + returnTypeProvider.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(returnTypeProvider.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | TUPLE_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg_types.left + argTypesLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.TupleType.forValueTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUTURE:f L_ANGLE_BRACKET:la builtin_type:wrapped R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> wrappedTypeProvider = (LexedValue<TypeProvider>) wrapped.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(f.getCurrentInputLine(), fright), new Line(la.getCurrentInputLine(), laright), new Line(wrappedTypeProvider.getCurrentInputLine(), wrapped.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(fleft, laleft, wrapped.left, raleft);
       int endCol = max(fleft + f.getLen(), laleft + la.getLen(), wrapped.left + wrappedTypeProvider.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.FutureType.wrapping(wrappedTypeProvider.getVal().resolveType(scopedHeap)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:type_name
    {:
       RESULT = new Symbol(
          -1,
          type_nameleft,
          type_nameright, // line number
          LexedValue.create(
            TypeProvider.Util.getTypeByName(type_name.getVal(), /*isTypeDefinition=*/true),
            type_name.getCurrentInputLine(),
            type_name.getLen())
       );
    :}
  | SCOPED_IDENTIFIER:scoped_identifier
    {:
       // TODO(steving) Long term I'll want to support first-class procedure references to contract procedures, so this
       // TODO(steving)     would actually need to be updated to check whether the given dep_module_name is in fact a
       // TODO(steving)     declared module dep and if not then it would be parsed as a contract procedure reference.
       String depModuleNameStr = scoped_identifier.getVal().getScopeName();
       if (ScopedHeap.currProgramDepModules.containsRow(depModuleNameStr)) {
         // Mark this dep as used, so that we can track whether the program's declared deps are *actually* necessary.
         ScopedHeap.markDepModuleUsed(depModuleNameStr);
       }
       String disambiguatedDepModuleTypeName = getDisambiguatedExportedIdentifierName(
          depModuleNameStr, scoped_identifier.getVal().getIdentifier());
       RESULT = new Symbol(
          -1,
          scoped_identifierleft,
          scoped_identifierright, // line number
          LexedValue.create(
            TypeProvider.Util.getTypeByName(disambiguatedDepModuleTypeName, /*isTypeDefinition=*/true),
            scoped_identifier.getCurrentInputLine(),
            scoped_identifier.getLen())
       );
    :}
  | IDENTIFIER:type_name L_ANGLE_BRACKET:la builtin_types_list:concrete_type_params R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> concreteTypeParamsLexedVal = (LexedValue<ImmutableList<TypeProvider>>) concrete_type_params.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(type_name.getCurrentInputLine(), type_nameright), new Line(la.getCurrentInputLine(), laright), new Line(concreteTypeParamsLexedVal.getCurrentInputLine(), concrete_type_params.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(type_nameleft, laleft, concrete_type_params.left, raleft);
       int endCol = max(type_nameleft + type_name.getLen(), laleft + la.getLen(), concrete_type_params.left + concreteTypeParamsLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          type_nameright, // line number
          LexedValue.create(
            // TODO(steving) There's currently no validation that this user-defined-type was ACTUALLY declared somewhere.
            // TODO(steving)    This is a bit of a ridiculous situation as this essentially would allow the declaration
            // TODO(steving)    of procedures/types that are actually unusable.
            (TypeProvider) (scopedHeap) -> Types.UserDefinedType.forTypeNameAndParameterizedTypes(
              type_name.getVal(),
              optionalUniqueModuleName.orElse(""),
              concreteTypeParamsLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())
            ),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | SCOPED_IDENTIFIER:scoped_identifier L_ANGLE_BRACKET:la builtin_types_list:concrete_type_params R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> concreteTypeParamsLexedVal = (LexedValue<ImmutableList<TypeProvider>>) concrete_type_params.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(scoped_identifier.getCurrentInputLine(), scoped_identifierright), new Line(la.getCurrentInputLine(), laright), new Line(concreteTypeParamsLexedVal.getCurrentInputLine(), concrete_type_params.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(scoped_identifierleft, laleft, concrete_type_params.left, raleft);
       int endCol = max(scoped_identifierleft + scoped_identifier.getLen(), laleft + la.getLen(), concrete_type_params.left + concreteTypeParamsLexedVal.getLen(), raleft + ra.getLen());

       String depModuleName = scoped_identifier.getVal().getScopeName();
       if (ScopedHeap.currProgramDepModules.containsRow(depModuleName)) {
         // Mark this dep as used, so that we can track whether the program's declared deps are *actually* necessary.
         ScopedHeap.markDepModuleUsed(depModuleName);
       }
       String disambiguatedDepModuleTypeName =
          getDisambiguatedExportedIdentifierName(depModuleName, scoped_identifier.getVal().getIdentifier());
       RESULT = new Symbol(
          -1,
          startCol,
          scoped_identifierright,
          LexedValue.create(
            // TODO(steving) There's currently no validation that this user-defined-type was ACTUALLY declared somewhere.
            // TODO(steving)    This is a bit of a ridiculous situation as this essentially would allow the declaration
            // TODO(steving)    of procedures/types that are actually unusable.
            (TypeProvider) (scopedHeap) -> Types.UserDefinedType.forTypeNameAndParameterizedTypes(
              scoped_identifier.getVal().getIdentifier(),
              ScopedHeap.getDefiningModuleDisambiguator(Optional.of(depModuleName)),
              concreteTypeParamsLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())
            ),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | STRUCT_TYPE:s LCURLY:la function_args_types_list:fields RCURLY:ra
    // Structs are defined like `struct{field1: int, ..., fieldN: string}`. This is intended to resemble a sequence of
    // variable declarations, which will align with the initialization syntax `{field1 = 1, ..., fieldN = "foo"}` which
    // in turn is intended to resemble a sequence of variable initializations. I appreciate the metaphore of a struct as
    // a bundle of variables.
    {:
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) fields.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(s.getCurrentInputLine(), sright), new Line(la.getCurrentInputLine(), laright), new Line(((LexedValue) fields.value).getCurrentInputLine(), fields.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(sleft, laleft, fields.left, raleft);
       int endCol = max(sleft + s.getLen(), laleft + la.getLen(), fields.left + ((LexedValue) fields.value).getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          sright, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) ->
              Types.StructType.forFieldTypes(
                fieldTypesMap.keySet().asList(),
                fieldTypesMap.values().stream()
                  .map(tp -> tp.resolveType(scopedHeap))
                  .collect(ImmutableList.toImmutableList()),
                /*isMutable=*/false
              ),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | HTTP_RESPONSE:h
    {:
       RESULT = new Symbol(
          -1,
          hleft,
          hright, // line number
          LexedValue.create(
            TypeProvider.ImmediateTypeProvider.of(Types.HTTP_RESPONSE),
            joinExprLines(new Line(h.getCurrentInputLine(), hright)),
            h.getVal().length())
       );
    :}
  | HTTP_CLIENT:h L_ANGLE_BRACKET:la builtin_type:http_service R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> httpServiceLex = (LexedValue<TypeProvider>)http_service.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(h.getCurrentInputLine(), hright), new Line(la.getCurrentInputLine(), laright), new Line(httpServiceLex.getCurrentInputLine(), http_serviceright), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(hleft, laleft, http_serviceleft, raleft);
       int endCol = max(hleft + h.getLen(), laleft + la.getLen(), http_serviceleft + httpServiceLex.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          hright, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> {
              // First things first, I need to actually do some type validation that this type has been correctly
              // parameterized with an HttpService and not some arbitrary type.
              Type resolvedHttpServiceType = httpServiceLex.getVal().resolveType(scopedHeap);
              if (!resolvedHttpServiceType.baseType().equals(BaseType.HTTP_SERVICE)) {
                throw new RuntimeException(
                  ClaroTypeException.forIllegalHttpClientTypeWithNonHttpServiceParameterizedType(resolvedHttpServiceType)
                );
              }
              return Types.HttpClientType.forServiceName(((Types.HttpServiceType) resolvedHttpServiceType).getServiceName());
            },
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | HTTP_SERVER:f L_ANGLE_BRACKET:la builtin_type:wrapped R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> wrappedTypeProvider = (LexedValue<TypeProvider>) wrapped.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(f.getCurrentInputLine(), fright), new Line(la.getCurrentInputLine(), laright), new Line(wrappedTypeProvider.getCurrentInputLine(), wrapped.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(fleft, laleft, wrapped.left, raleft);
       int endCol = max(fleft + f.getLen(), laleft + la.getLen(), wrapped.left + wrappedTypeProvider.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          fright, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> {
              Type resolvedHttpServiceType = wrappedTypeProvider.getVal().resolveType(scopedHeap);
              if (!resolvedHttpServiceType.baseType().equals(BaseType.HTTP_SERVICE)) {
                throw new RuntimeException(
                  ClaroTypeException.forIllegalHttpServerTypeWithNonHttpServiceParameterizedType(resolvedHttpServiceType)
                );
              }
              return Types.HttpServerType.forHttpService(resolvedHttpServiceType);
            },
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | SYNTHETIC_JAVA_TYPE:j LPAR:lp STRING:fully_qualified_java_type_fmt_str RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(j.getCurrentInputLine(), jright), new Line(fully_qualified_java_type_fmt_str.getCurrentInputLine(), fully_qualified_java_type_fmt_strright), new Line(lp.getCurrentInputLine(), lpright), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(jleft, lpleft, fully_qualified_java_type_fmt_strleft, rpleft);
       int endCol = max(jleft + j.getLen(), lpleft + lp.getLen(), fully_qualified_java_type_fmt_strleft + fully_qualified_java_type_fmt_str.getLen(), rpleft + rp.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          jright, // line number
          LexedValue.create(
            TypeProvider.ImmediateTypeProvider.of(
              Types.$JavaType.create(/*isMutable=*/false, ImmutableList.of(), fully_qualified_java_type_fmt_str.getVal())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | SYNTHETIC_JAVA_TYPE:j L_ANGLE_BRACKET:la builtin_types_list:parameterized_type_names R_ANGLE_BRACKET:ra LPAR:lp STRING:fully_qualified_java_type_fmt_str RPAR:rp
    {:
       LexedValue<ImmutableList<TypeProvider>> concreteTypeParamsLexedVal = (LexedValue<ImmutableList<TypeProvider>>) parameterized_type_names.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(j.getCurrentInputLine(), jright), new Line(la.getCurrentInputLine(), laright), new Line(concreteTypeParamsLexedVal.getCurrentInputLine(), parameterized_type_names.right), new Line(ra.getCurrentInputLine(), raright), new Line(fully_qualified_java_type_fmt_str.getCurrentInputLine(), fully_qualified_java_type_fmt_strright), new Line(lp.getCurrentInputLine(), lpright), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(jleft, laleft, parameterized_type_names.left, raleft, lpleft, fully_qualified_java_type_fmt_strleft, rpleft);
       int endCol = max(jleft + j.getLen(), laleft + la.getLen(), parameterized_type_names.left + concreteTypeParamsLexedVal.getLen(), raleft + ra.getLen(), lpleft + lp.getLen(), fully_qualified_java_type_fmt_strleft + fully_qualified_java_type_fmt_str.getLen(), rpleft + rp.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          jright, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) ->
              Types.$JavaType.create(
                /*isMutable=*/false,
                concreteTypeParamsLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()),
                fully_qualified_java_type_fmt_str.getVal()),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

builtin_types_list ::=
    backwards_builtin_types_list:b
    {:
       LexedValue<ImmutableList.Builder<TypeProvider>> bLexedValue = (LexedValue<ImmutableList.Builder<TypeProvider>>) b.value;
       RESULT = new Symbol(
          -1,
          b.left,
          b.right, // line number
          LexedValue.create(
            bLexedValue.getVal().build().reverse(),
            bLexedValue.getCurrentInputLine(),
            bLexedValue.getLen())
       );
    :}
  ;

backwards_builtin_types_list ::=
    builtin_type:t COMMA:c backwards_builtin_types_list:tail
    {:
       LexedValue<TypeProvider> tLexedVal = (LexedValue<TypeProvider>)t.value;
       LexedValue<ImmutableList.Builder<TypeProvider>> tailLexedVal = (LexedValue<ImmutableList.Builder<TypeProvider>>)tail.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(tLexedVal.getCurrentInputLine(), t.right), new Line(c.getCurrentInputLine(), cright), new Line(tailLexedVal.getCurrentInputLine(), tail.right));
       int startCol = min(t.left, cleft, tail.left);
       int endCol = max(t.left + tLexedVal.getLen(), cleft + c.getLen(), tail.left + tailLexedVal.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          LexedValue.create(
            tailLexedVal.getVal().add(tLexedVal.getVal()),
            currentLinesSupplier,
            tailLexedVal.getLen())
       );
    :}
  | builtin_type:t
    {:
       RESULT = new Symbol(
          -1,
          t.left,
          t.right, // line number
          LexedValue.create(
            ImmutableList.<TypeProvider>builder().add(((LexedValue<TypeProvider>) t.value).getVal()),
            ((LexedValue)t.value).getCurrentInputLine(),
            ((LexedValue)t.value).getLen())
       );
    :}
  ;

identifier_assignment ::=
    identifier:identifier ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new AssignmentStmt(identifier, e); :}
  ;

trashcan_assignment ::=
    UNDERSCORE ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new TrashcanAssignmentStmt(e); :}
  | UNDERSCORE QUESTION_MARK_ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new TrashcanAssignmentStmt(e, /*errorProp=*/true); :}
  ;

identifier_increment_stmt ::=
    identifier_increment:i SEMICOLON
    {: RESULT = new IncrementStmt(i); :}
  ;

identifier_increment ::=
    INCREMENT:inc identifier:i
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(inc.getCurrentInputLine(), incright), new Line(i.currentLine, i.currentLineNumber));
       int startCol = min(incleft, i.startCol);
       int endCol = max(incleft + inc.getLen(), i.endCol);

       RESULT = new IncrementExpr(i, /*preIncrement=*/true, currentLinesSupplier, i.currentLineNumber, startCol, endCol);
    :}
  | identifier:i INCREMENT:inc
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(i.currentLine, i.currentLineNumber), new Line(inc.getCurrentInputLine(), incright));
       int startCol = min(i.startCol, incleft);
       int endCol = max(i.endCol, incleft + inc.getLen());

       RESULT = new IncrementExpr(i, /*preIncrement=*/false, currentLinesSupplier, incright, startCol, endCol);
    :}
  ;

identifier_decrement_stmt ::=
    identifier_decrement:i SEMICOLON
    {: RESULT = new DecrementStmt(i); :}
  ;

identifier_decrement ::=
    DECREMENT:d identifier:i
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(d.getCurrentInputLine(), dright), new Line(i.currentLine, i.currentLineNumber));
       int startCol = min(dleft, i.startCol);
       int endCol = max(dleft + d.getLen(), i.endCol);

       RESULT = new DecrementExpr(i, /*preDecrement=*/true, currentLinesSupplier, i.currentLineNumber, startCol, endCol);
    :}
  | identifier:i DECREMENT:d
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(i.currentLine, i.currentLineNumber), new Line(d.getCurrentInputLine(), dright));
       int startCol = min(i.startCol, dleft);
       int endCol = max(i.endCol, dleft + d.getLen());

       RESULT = new DecrementExpr(i, /*preDecrement=*/false, currentLinesSupplier, dright, startCol, endCol);
    :}
  ;

list_element_assignment ::=
    collection_subscript:l ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new ListElementAssignmentStmt(l, e); :}
  | collection_subscript:l QUESTION_MARK_ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new ListElementAssignmentStmt(l, e, /*errorProp=*/true); :}
  ;

list_remove_expr ::=
    REMOVE:r LPAR:lp expr:l COMMA:c expr:e RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(r.getCurrentInputLine(), rright), new Line(lp.getCurrentInputLine(), lpright), new Line(l), new Line(c.getCurrentInputLine(), cright), new Line(e), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(rleft, lpleft, l.startCol, cleft, e.startCol, rpleft);
       int endCol = max(rleft + r.getLen(), lpleft + lp.getLen(), l.endCol, cleft + c.getLen(), e.endCol, rpleft + rp.getLen());

       RESULT = new RemoveElementFromListExpr(l, e, currentLinesSupplier, rpright, startCol, endCol);
    :}
  ;

// In order to support function calls w/in single-expr lambda bodies w/o making the grammar think that it has reached
// the end of the lambda at the first occurrence of `(` in the expr body I am making a separate grammar production for
// "all of the exprs including lambdas" and "all of the exprs not including lambdas" so that function application can be
// restricted to not work on lambdas right away. Solves the ambiguity in a minimally annoying way. To immediately call a
// lambda you'd need to wrap the lambda in parens or something.
expr ::=
    non_lambda_exprs:e
    {: RESULT = e; :}
  | lambda_function_expr:lf
    {: RESULT = lf; :}
  ;
non_lambda_exprs ::=
    MINUS:m expr:e
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(m.getCurrentInputLine(), mright), new Line(e.currentLine, e.currentLineNumber));
       int startCol = min(mleft, e.startCol);
       int endCol = max(mleft + m.getLen(), e.endCol);

       RESULT = new NegateNumericExpr(e, currentLinesSupplier, e.currentLineNumber, startCol, endCol);
    :}
  | expr:a PLUS:p expr:b
    {:
       RESULT = constructBinaryExpr(a, p, pleft, pright, b, (currentLinesSupplier) -> (startCol, endCol) -> new AddNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | identifier_increment:i
    {: RESULT = i; :}
  | identifier_decrement:i
    {: RESULT = i; :}
  | expr:a MINUS:m expr:b
    {:
       RESULT = constructBinaryExpr(a, m, mleft, mright, b, (currentLinesSupplier) -> (startCol, endCol) -> new SubtractNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a MULTIPLY:m expr:b
    {:
       RESULT = constructBinaryExpr(a, m, mleft, mright, b, (currentLinesSupplier) -> (startCol, endCol) -> new MultiplyNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a DIVIDE:d expr:b
    {:
       RESULT = constructBinaryExpr(a, d, dleft, dright, b, (currentLinesSupplier) -> (startCol, endCol) -> new DivideNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a MODULUS:m expr:b
    {:
       RESULT = constructBinaryExpr(a, m, mleft, mright, b, (currentLinesSupplier) -> (startCol, endCol) -> new ModulusNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a EXPONENTIATE:ex expr:b
    {:
       RESULT = constructBinaryExpr(a, ex, exleft, exright, b, (currentLinesSupplier) -> (startCol, endCol) -> new ExponentiateNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a IN:in expr:b
    {:
       RESULT = constructBinaryExpr(a, in, inleft, inright, b, (currentLinesSupplier) -> (startCol, endCol) -> new InBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | parenthesized_expr:p
    {: RESULT = p; :}
  | LOG_PREFIX:log float:float_base LPAR:lp expr:arg RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(log.getCurrentInputLine(), logright), new Line(float_base.currentLine, float_base.currentLineNumber), new Line(lp.getCurrentInputLine(), lpright), new Line(arg.currentLine, arg.currentLineNumber), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(logleft, float_base.startCol, lpleft, arg.startCol, rpleft);
       int endCol = max(logleft + log.getLen(), float_base.endCol, lpleft + lp.getLen(), arg.endCol, rpleft + rp.getLen());

       RESULT = new LogNumericExpr(arg, float_base, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | LOG_PREFIX:log integer:int_base LPAR:lp expr:arg RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(log.getCurrentInputLine(), logright), new Line(int_base.currentLine, int_base.currentLineNumber), new Line(lp.getCurrentInputLine(), lpright), new Line(arg.currentLine, arg.currentLineNumber), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(logleft, int_base.startCol, lpleft, arg.startCol, rpleft);
       int endCol = max(logleft + log.getLen(), int_base.endCol, lpleft + lp.getLen(), arg.endCol, rpleft + rp.getLen());

       RESULT = new LogNumericExpr(arg, int_base, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | NUMERIC_BOOL:num LPAR:lp expr:b RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(num.getCurrentInputLine(), numright), new Line(lp.getCurrentInputLine(), lpright), new Line(b.currentLine, b.currentLineNumber), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(numleft, lpleft, b.startCol, rpleft);
       int endCol = max(numleft + num.getLen(), lpleft + lp.getLen(), b.endCol, rpleft + rp.getLen());

       RESULT = new NumericBoolNumericExpr(b, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | input:i
    {: RESULT = i; :}
  | list_remove_expr:lr
    {: RESULT = lr; :}
  | unwrap_expr:u
    {: RESULT = u; :}
  | is_input_ready:i
    {: RESULT = i; :}
  | copy_expr:c
    {: RESULT = c; :}
  | from_json_expr:f
    {: RESULT = f; :}
  | list:l
    {: RESULT = l; :}
  | map:m
    {: RESULT = m; :}
  | list_comprehension_expr:c
    {: RESULT = c; :}
  | set_comprehension_expr:c
    {: RESULT = c; :}
  | map_comprehension_expr:c
    {: RESULT = c; :}
  | collection_subscript:l
    {: RESULT = l; :}
  | LEN:len LPAR:lp expr:e RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(len.getCurrentInputLine(), lenright), new Line(lp.getCurrentInputLine(), lpright), new Line(e.currentLine, e.currentLineNumber), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(lenleft, lpleft, e.startCol, rpleft);
       int endCol = max(lenleft + len.getLen(), lpleft + lp.getLen(), e.endCol, rpleft + rp.getLen());

       RESULT = new LenExpr(e, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | bool_expr:b
    {: RESULT = b; :}
  | fmt_string:fs_symbol
    {:
       LexedValue<ImmutableList<ImmutableList.Builder>> fsLexedValue = (LexedValue<ImmutableList<ImmutableList.Builder>>) fs_symbol.value;
       ImmutableList<ImmutableList.Builder> fs = fsLexedValue.getVal();
       RESULT = new FormatStringExpr(fs.get(0).build().reverse(), fs.get(1).build().reverse(), fsLexedValue.getCurrentInputLine(), fs_symbol.right, fs_symbol.left, fs_symbol.left + fsLexedValue.getLen());
    :}
  | term:t
    {: RESULT = t; :}
  | function_call_expr:f
    {: RESULT = f; :}
  | typed_lambda_function_expr:tlf
    {: RESULT = tlf; :}
  | provider_function_call_expr:pf
    {: RESULT = pf; :}
  | tuple:t
    {: RESULT = t; :}
  | set:s
    {: RESULT = s; :}
  | struct:s
    {: RESULT = s; :}
  | struct_field_access_expr:s
    {: RESULT = s; :}
    // This is some unfortunate syntax for casting, but this actually was necessary to avoid having casting create an
    // ambiguous grammar deciding whether `(i < len(l))` was a malformed cast (e.g. for some parameterized custom type
    // like `(MyType<foo>)`) or if it was actually a "less-than" operator within a parenthesized expression. From some
    // perspective this is an issue with JCUP being set to use too low of a lookahead....but I don't fully understand
    // the implications of trying to increase that, so it'll stay this way.
  | CAST:cast LPAR:lp builtin_type:asserted_type COMMA:comma expr:casted_expr RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.getCurrentInputLine(), lpright), new Line(((LexedValue)asserted_type.value).getCurrentInputLine(), asserted_type.right), new Line(rp.getCurrentInputLine(), rpright), new Line(casted_expr.currentLine, casted_expr.currentLineNumber));
       int startCol = min(lpleft, asserted_type.left, rpleft, casted_expr.startCol);
       int endCol = max(lpleft + lp.getLen(), asserted_type.left + ((LexedValue)asserted_type.value).getLen(), rpleft + rp.getLen(), casted_expr.endCol);

       RESULT = new CastExpr(((LexedValue<TypeProvider>)asserted_type.value).getVal(), casted_expr, currentLinesSupplier, casted_expr.currentLineNumber, startCol, endCol);
    :}
  | get_http_client_expr:g
    {: RESULT = g; :}
  | get_basic_http_server_for_port_expr:g
    {: RESULT = g; :}
  | error:e
    // TODO(steving) This is super helpful, do the same thing for stmts.
    // There's been some syntax error in an expression somewhere.. meaning that this expression is getting thrown away
    // in order to continue checking for other errors in the input program. So "repair" the program by giving it some
    // arbitrary Expr that won't complain a second time during AST type checking.
    {:
       RESULT = new Expr(ImmutableList.of(), () -> {throw new RuntimeException("Internal Compiler Error: Should be unreachable.");}, -1, -1, -1) {
          public Type getValidatedExprType(ScopedHeap unused) {
            return Types.UNKNOWABLE;
          }
          public StringBuilder generateJavaSourceBodyOutput(ScopedHeap unused) {
            return new StringBuilder();
          }
          public Object generateInterpretedOutput(ScopedHeap unused) {
            return null;
          }
          public void logTypeError(Exception unused) {
            // Intentionally do not re-log this error.
          }
       };
    :}
  ;

parenthesized_expr ::=
    LPAR:lp expr:e RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.getCurrentInputLine(), lpright), new Line(e.currentLine, e.currentLineNumber), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(lpleft, e.startCol, rpleft);
       int endCol = max(lpleft + lp.getLen(), e.endCol, rpleft + rp.getLen());

       RESULT = new ParenthesizedExpr(e, currentLinesSupplier, rpright, startCol, endCol);
    :}
  ;

sleep ::=
    SLEEP:i LPAR:lp expr:e RPAR:rp SEMICOLON
    {:
       RESULT = new SleepStmt(e);
    :}
  ;

input ::=
    INPUT:i LPAR:lp STRING:prompt RPAR:rp
    {:
       RESULT = constructInputExpr(Optional.of(prompt), promptleft, promptright, i, ileft, iright, lp, lpleft, lpright, rp, rpleft, rpright);
    :}
  | INPUT:i LPAR:lp RPAR:rp
    {:
       RESULT = constructInputExpr(Optional.empty(), -1, -1, i, ileft, iright, lp, lpleft, lpright, rp, rpleft, rpright);
    :}
  ;

is_input_ready ::=
    IS_INPUT_READY LPAR RPAR
    {:
       RESULT = new IsInputReadyExpr();
    :}
  ;

copy_expr ::=
    COPY:copy LPAR:lp expr:e RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(copy.getCurrentInputLine(), copyright), new Line(lp.getCurrentInputLine(), lpright), new Line(e.currentLine, e.currentLineNumber), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(copyleft, lpleft, e.startCol, rpleft);
       int endCol = max(copyleft + copy.getLen(), lpleft + lp.getLen(), e.endCol, rpleft + rp.getLen());

       RESULT = new CopyExpr(e, currentLinesSupplier, rpright, startCol, endCol);
    :}
  ;

from_json_expr ::=
    FROM_JSON:from_json LPAR:lp expr:e RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(from_json.getCurrentInputLine(), from_jsonright), new Line(lp.getCurrentInputLine(), lpright), new Line(e.currentLine, e.currentLineNumber), new Line(rp.getCurrentInputLine(), rpright));
       int startCol = min(from_jsonleft, lpleft, e.startCol, rpleft);
       int endCol = max(from_jsonleft + from_json.getLen(), lpleft + lp.getLen(), e.endCol, rpleft + rp.getLen());

       RESULT = new FromJsonExpr(e, currentLinesSupplier, rpright, startCol, endCol);
    :}
  ;


list ::=
    LBRACKET:lb args_list:args RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(((LexedValue) args.value).getCurrentInputLine(), args.right), new Line(rb.getCurrentInputLine(), rbright));
       int startCol = min(lbleft, args.left, rbleft);
       int endCol = max(lbleft + lb.getLen(), args.left + ((LexedValue) args.value).getLen(), rbleft + rb.getLen());

       // Notice that we reverse the list before handing it to the ListExpr node because it was collected backwards.
       RESULT = new ListExpr(((LexedValue<ImmutableList.Builder<Expr>>) args.value).getVal().build().reverse(), /*isMutable=*/false, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | LBRACKET:lb RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(rb.getCurrentInputLine(), rbright));
       int startCol = min(lbleft, rbleft);
       int endCol = max(lbleft + lb.getLen(), rbleft + rb.getLen());

       RESULT = new ListExpr(/*isMutable=*/false, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | MUT:mut LBRACKET:lb args_list:args RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(mut.getCurrentInputLine(), mutright), new Line(lb.getCurrentInputLine(), lbright), new Line(((LexedValue) args.value).getCurrentInputLine(), args.right), new Line(rb.getCurrentInputLine(), rbright));
       int startCol = min(mutleft, lbleft, args.left, rbleft);
       int endCol = max(mutleft + mut.getLen(), lbleft + lb.getLen(), args.left + ((LexedValue) args.value).getLen(), rbleft + rb.getLen());

       // Notice that we reverse the list before handing it to the ListExpr node because it was collected backwards.
       RESULT = new ListExpr(((LexedValue<ImmutableList.Builder<Expr>>) args.value).getVal().build().reverse(), /*isMutable=*/true, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | MUT:mut LBRACKET:lb RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(mut.getCurrentInputLine(), mutright), new Line(lb.getCurrentInputLine(), lbright), new Line(rb.getCurrentInputLine(), rbright));
       int startCol = min(mutleft, lbleft, rbleft);
       int endCol = max(mutleft + mut.getLen(), lbleft + lb.getLen(), rbleft + rb.getLen());

       RESULT = new ListExpr(/*isMutable=*/true, currentLinesSupplier, rbright, startCol, endCol);
    :}
  ;

map ::=
    LCURLY:lc RCURLY:rc
    {:
      RESULT = new MapExpr(ImmutableList.of(), /*isMutable=*/false, joinExprLines(new Line(lc.getCurrentInputLine(), lcright), new Line(rc.getCurrentInputLine(), rcright)), rcright, min(lcleft, rcleft), max(lcleft + lc.getLen(), rcleft + rc.getLen()));
    :}
  | LCURLY:lc map_initializer_kv_list:initializer RCURLY:rc
    {:
      RESULT = new MapExpr(initializer.build().reverse(), /*isMutable=*/false, joinExprLines(new Line(lc.getCurrentInputLine(), lcright), new Line(rc.getCurrentInputLine(), rcright)), rcright, min(lcleft, rcleft), max(lcleft + lc.getLen(), rcleft + rc.getLen()));
    :}
  | MUT:mut LCURLY:lc RCURLY:rc
    {:
      RESULT = new MapExpr(ImmutableList.of(), /*isMutable=*/true, joinExprLines(new Line(mut.getCurrentInputLine(), mutright), new Line(lc.getCurrentInputLine(), lcright), new Line(rc.getCurrentInputLine(), rcright)), rcright, min(mutleft, lcleft, rcleft), max(mutleft + mut.getLen(), lcleft + lc.getLen(), rcleft + rc.getLen()));
    :}
  | MUT:mut LCURLY:lc map_initializer_kv_list:initializer RCURLY:rc
    {:
      RESULT = new MapExpr(initializer.build().reverse(), /*isMutable=*/true, joinExprLines(new Line(mut.getCurrentInputLine(), mutright), new Line(lc.getCurrentInputLine(), lcright), new Line(rc.getCurrentInputLine(), rcright)), rcright, min(mutleft, lcleft, rcleft), max(mutleft + mut.getLen(), lcleft + lc.getLen(), rcleft + rc.getLen()));
    :}
  ;

map_initializer_kv_list ::=
    expr:k COLON expr:v COMMA map_initializer_kv_list:tail
    {:
      RESULT = tail.add(ImmutableList.of(k, v));
    :}
  | expr:k COLON expr:v
    {:
      RESULT = ImmutableList.builder().add(ImmutableList.of(k, v));
    :}
  ;

tuple ::=
    // Tuples distinguish themselves from parenthesized expressions by having at least one comma.
    LPAR:lp expr:head COMMA:c args_list:tailValues RPAR:rp
    {:
       RESULT = (TupleExpr) constructSetOrTuple(null, lpleft, lpright, lp, lpleft, lpright, head, c, cleft, cright, tailValues, rp, rpleft, rpright, (values, lines) -> (startCol, endCol) -> new TupleExpr(values, /*isMutable=*/false, lines, rpright, startCol, endCol));
    :}
  | MUT:mut LPAR:lp expr:head COMMA:c args_list:tailValues RPAR:rp
    {:
       RESULT = (TupleExpr) constructSetOrTuple(mut, mutleft, mutright, lp, lpleft, lpright, head, c, cleft, cright, tailValues, rp, rpleft, rpright, (values, lines) -> (startCol, endCol) -> new TupleExpr(values, /*isMutable=*/true, lines, rpright, startCol, endCol));
    :}
  ;

set ::=
    // Sets distinguish themselves from parenthesized expressions by having at least one comma, and tuples by {} instead of ().
    LCURLY:lp expr:head COMMA:c args_list:tailValues RCURLY:rp
    {:
       RESULT = (SetExpr) constructSetOrTuple(null, lpleft, lpright, lp, lpleft, lpright, head, c, cleft, cright, tailValues, rp, rpleft, rpright, (values, lines) -> (startCol, endCol) -> new SetExpr(values, /*isMutable=*/false, lines, rpright, startCol, endCol));
    :}
  | MUT:mut LCURLY:lp expr:head COMMA:c args_list:tailValues RCURLY:rp
    {:
       RESULT = (SetExpr) constructSetOrTuple(mut, mutleft, mutright, lp, lpleft, lpright, head, c, cleft, cright, tailValues, rp, rpleft, rpright, (values, lines) -> (startCol, endCol) -> new SetExpr(values, /*isMutable=*/true, lines, rpright, startCol, endCol));
    :}
  ;

args_list ::=
    expr:head COMMA:c args_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(head.currentLine, head.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue)tail.value).getCurrentInputLine(), tail.right));
       int startCol = min(head.startCol, cleft, tail.left);
       int endCol = max(head.endCol, cleft + c.getLen(), tail.left + ((LexedValue) tail.value).getLen());

       // Notice that we're building this list in reverse order, just by the order of the parser recursively identifying
       // each expr in the list.
       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          LexedValue.create(
            ((LexedValue<ImmutableList.Builder<Expr>>) tail.value).getVal().add(head),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | expr:e
    {:
       RESULT = new Symbol(
          -1,
          e.startCol,
          e.currentLineNumber, // line number
          LexedValue.create(
            ImmutableList.<Expr>builder().add(e),
            e.currentLine,
            e.endCol - e.startCol)
       );
    :}
  ;

struct ::=
    LCURLY:lc struct_field_initializers_list:fields RCURLY:rc
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lc.getCurrentInputLine(), lcright), new Line(((LexedValue) fields.value).getCurrentInputLine(), fields.right), new Line(rc.getCurrentInputLine(), rcright));
       int startCol = min(lcleft, fields.left, rcleft);
       int endCol = max(lcleft + lc.getLen(), fields.left + ((LexedValue) fields.value).getLen(), rcleft + rc.getLen());

      ImmutableMap<String, Expr> fieldsMap = ((LexedValue<ImmutableMap.Builder<String, Expr>>) fields.value).getVal().build();
      RESULT = new StructExpr(fieldsMap.keySet().asList().reverse(), fieldsMap.values().asList().reverse(), /*isMutable=*/false,
        currentLinesSupplier, rcright, startCol, endCol);
    :}
  | MUT:mut LCURLY:lc struct_field_initializers_list:fields RCURLY:rc
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(mut.getCurrentInputLine(), mutright), new Line(lc.getCurrentInputLine(), lcright), new Line(((LexedValue) fields.value).getCurrentInputLine(), fields.right), new Line(rc.getCurrentInputLine(), rcright));
       int startCol = min(mutleft, lcleft, fields.left, rcleft);
       int endCol = max(mutleft + mut.getLen(), lcleft + lc.getLen(), fields.left + ((LexedValue) fields.value).getLen(), rcleft + rc.getLen());

      ImmutableMap<String, Expr> fieldsMap = ((LexedValue<ImmutableMap.Builder<String, Expr>>) fields.value).getVal().build();
      RESULT = new StructExpr(fieldsMap.keySet().asList().reverse(), fieldsMap.values().asList().reverse(), /*isMutable=*/true,
        currentLinesSupplier, rcright, startCol, endCol);
    :}
  ;

// Note that we're again building this up backwards for convenience (remember that all guava collections respect ordering).
struct_field_initializers_list ::=
    IDENTIFIER:arg_name ASSIGNMENT:eq expr:e COMMA:comma struct_field_initializers_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(eq.getCurrentInputLine(), eqright), new Line(e.currentLine, e.currentLineNumber), new Line(comma.getCurrentInputLine(), commaright), new Line(((LexedValue) tail.value).getCurrentInputLine(), tail.right));
       int startCol = min(arg_nameleft, eqleft, e.startCol, commaleft, tail.left);
       int endCol = max(arg_nameleft + arg_name.getLen(), eqleft + eq.getLen(), e.endCol, commaleft + comma.getLen(), tail.left + ((LexedValue) tail.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          LexedValue.create(
            ((LexedValue<ImmutableMap.Builder<String, Expr>>) tail.value).getVal().put(arg_name.getVal(), e),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:arg_name ASSIGNMENT:eq expr:e
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(eq.getCurrentInputLine(), eqright), new Line(e.currentLine, e.currentLineNumber));
       int startCol = min(arg_nameleft, eqleft, e.startCol);
       int endCol = max(arg_nameleft + arg_name.getLen(), eqleft + eq.getLen(), e.endCol);

       RESULT = new Symbol(
          -1,
          startCol,
          e.currentLineNumber, // line number
          LexedValue.create(
            ImmutableMap.<String, Expr>builder().put(arg_name.getVal(), e),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

struct_field_access_expr ::=
    expr:e DOT:dot IDENTIFIER:id
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(e.currentLine, e.currentLineNumber), new Line(dot.getCurrentInputLine(), dotright), new Line(id.getCurrentInputLine(), idright));
       int startCol = min(e.startCol, dotleft, idleft);
       int endCol = max(e.endCol, dotleft + dot.getLen(), idleft + id.getLen());

      RESULT = new StructFieldAccessExpr(e, id.getVal(), currentLinesSupplier, idright, startCol, endCol);
    :}
  ;

struct_field_assignment_stmt ::=
    struct_field_access_expr:field ASSIGNMENT expr:e SEMICOLON
    {:
      field.codegenForRead = false;
      RESULT = new StructFieldAssignmentStmt(field, e);
    :}
  ;

collection_subscript ::=
    expr:l LBRACKET:lb expr:e RBRACKET:rb
    {:
       RESULT = constructCollectionSubscriptExpr(l, lb, lbleft, lbright, e, rb, rbleft, rbright);
    :}
  ;

bool_expr ::=
    equality:b
    {: RESULT = b; :}
  | inequality:b
    {: RESULT = b; :}
  | bool_arithmetic:b
    {: RESULT = b; :}
  | instanceof_expr:b
    {: RESULT = b; :}
  ;

// This calculator can evaluate an equality check of expressions.
equality ::=
    expr:a EQUALS:e expr:b
    {:
       RESULT = constructBinaryExpr(a, e, eleft, eright, b, (currentLinesSupplier) -> (startCol, endCol) -> new EqualsBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a NOT_EQUALS:ne expr:b
    {:
       RESULT = constructBinaryExpr(a, ne, neleft, neright, b, (currentLinesSupplier) -> (startCol, endCol) -> new NotEqualsBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  ;

if_else_chain_stmt ::=
    if_stmt:leading_if_stmt else_if_stmt_chain:else_if_chain
    {:
       leading_if_stmt.setNextCondition(else_if_chain);
       RESULT = leading_if_stmt;
    :}
  | if_stmt:if_stmt else_stmt:trailing_else_stmt
    {:
       if_stmt.setTerminalElseClause(trailing_else_stmt);
       RESULT = if_stmt;
    :}
  | if_stmt:if_stmt
    {: RESULT = if_stmt; :}
  ;

if_stmt ::=
    IF LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new IfStmt(e, stmt_list); :}
  ;

else_if_stmt_chain ::=
    else_if_stmt:head else_if_stmt_chain:tail
    {:
       head.setNextCondition(tail);
       RESULT = head;
    :}
  | else_if_stmt:else_if_stmt else_stmt:trailing_else_stmt
    {:
       else_if_stmt.setTerminalElseClause(trailing_else_stmt);
       RESULT = else_if_stmt;
    :}
  | else_if_stmt:else_if_stmt
    {: RESULT = else_if_stmt; :}
  ;

else_if_stmt ::=
    ELSE if_stmt:else_if_stmt
    {: RESULT = else_if_stmt; :}
  ;

// We can simply return the StmtListNode itself because this is actually gonna be run by the IfStmt it's associated
// with.
else_stmt ::=
    ELSE LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = stmt_list; :}
  ;

match_stmt ::=
    MATCH LPAR expr:e RPAR LCURLY match_cases_list_stmt:cases RCURLY
    {: RESULT = new MatchStmt(e, cases.build().reverse()); :}
  ;

match_cases_list_stmt ::=
    CASE match_case_patterns:p ARROW stmt_list:s match_cases_list_stmt:tail
    {: RESULT = tail.add(ImmutableList.of(p, s)); :}
  | CASE match_multi_expr_case:p ARROW stmt_list:s match_cases_list_stmt:tail
    {: RESULT = tail.add(ImmutableList.of(p.build().reverse(), s)); :}

  | CASE match_case_patterns:p ARROW stmt_list:s
    {: RESULT = ImmutableList.<ImmutableList<Object>>builder().add(ImmutableList.of(p, s)); :}
  | CASE match_multi_expr_case:p ARROW stmt_list:s
    {: RESULT = ImmutableList.<ImmutableList<Object>>builder().add(ImmutableList.of(p.build().reverse(), s)); :}
  ;

match_case_patterns ::=
    primitive:p
    {: RESULT = MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(p); :}
  | MINUS INTEGER:i
    {: RESULT = MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(
                  new IntegerTerm(-(i.getVal()), i.getCurrentInputLine(), iright, ileft, ileft + i.getLen())); :}
  | identifier:wildcard
    {: RESULT = MatchStmt.MaybeWildcardPrimitivePattern.forWildcardBinding(wildcard); :}
  | identifier:type LPAR primitive:wrapped RPAR
    {: RESULT =
          MatchStmt.UserDefinedTypePattern.forTypeNameAndWrappedValue(
            type,
            MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(wrapped));
    :}
  | identifier:type LPAR match_case_patterns:wrapped RPAR
    {: RESULT =
          MatchStmt.UserDefinedTypePattern.forTypeNameAndWrappedValue(
            type,
            wrapped);
    :}
  | scoped_identifier:type LPAR primitive:wrapped RPAR
    {: RESULT =
          MatchStmt.UserDefinedTypePattern.forTypeNameAndWrappedValue(
            type.getScopeNameIdentifierReferenceTerm(
                Optional.of(ScopedHeap.getDefiningModuleDisambiguator(Optional.of(type.getScopeName())))),
            type.getIdentifierIdentifierReferenceTerm(
                Optional.of(ScopedHeap.getDefiningModuleDisambiguator(Optional.of(type.getScopeName())))),
            MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(wrapped));
    :}
  | scoped_identifier:type LPAR match_case_patterns:wrapped RPAR
    {: RESULT =
          MatchStmt.UserDefinedTypePattern.forTypeNameAndWrappedValue(
            type.getScopeNameIdentifierReferenceTerm(
                Optional.of(ScopedHeap.getDefiningModuleDisambiguator(Optional.of(type.getScopeName())))),
            type.getIdentifierIdentifierReferenceTerm(
                Optional.of(ScopedHeap.getDefiningModuleDisambiguator(Optional.of(type.getScopeName())))),
            wrapped);
    :}
  | LPAR:lp match_case_patterns:head COMMA:c match_case_patterns_list:tailValues RPAR:rp
    {: RESULT = MatchStmt.TuplePattern.forElementValues(tailValues.add(head).build().reverse(), /*isMutable=*/false); :}
  | MUT LPAR:lp match_case_patterns:head COMMA:c match_case_patterns_list:tailValues RPAR:rp
    {: RESULT = MatchStmt.TuplePattern.forElementValues(tailValues.add(head).build().reverse(), /*isMutable=*/true); :}
  | LCURLY:lc match_case_pattern_struct_field_list:fields RCURLY:rc
    {: RESULT = MatchStmt.StructPattern.forFieldPatterns(fields.build().reverse(), /*isMutable=*/false); :}
  | MUT:mut LCURLY:lc match_case_pattern_struct_field_list:fields RCURLY:rc
    {: RESULT = MatchStmt.StructPattern.forFieldPatterns(fields.build().reverse(), /*isMutable=*/true); :}
  | UNDERSCORE COLON builtin_type:t
    {: RESULT = MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(((LexedValue<TypeProvider>) t.value).getVal()); :}
  | identifier:binding COLON builtin_type:t
    {: RESULT = MatchStmt.MaybeWildcardPrimitivePattern.forTypeLiteralWildcardBinding(((LexedValue<TypeProvider>) t.value).getVal(), binding); :}
  | UNDERSCORE
    // TODO(steving) This should model `_` as an Expr to have something to point at in errors.
    {: RESULT = MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(null); :}
  ;

// TODO(steving) TESTING!! Make multi-expr-case support arbitrary patterns.
match_multi_expr_case ::=
    primitive:p BAR match_multi_expr_case:tail
    {: RESULT = tail.add(MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(p)); :}
  | identifier:type LPAR primitive:wrapped RPAR BAR match_multi_expr_case:tail
    {:
        RESULT =
          tail.add(
            MatchStmt.UserDefinedTypePattern.forTypeNameAndWrappedValue(
              type,
              MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(wrapped)));
    :}

  | primitive:p1 BAR primitive:p2
    {: RESULT = ImmutableList.<Object>builder()
         .add(MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(p2))
         .add(MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(p1));
    :}
  | identifier:type1 LPAR primitive:wrapped1 RPAR BAR identifier:type2 LPAR primitive:wrapped2 RPAR
    {:
       RESULT = ImmutableList.<Object>builder()
          .add(
            MatchStmt.UserDefinedTypePattern.forTypeNameAndWrappedValue(
              type2,
              MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(wrapped2)))
          .add(
            MatchStmt.UserDefinedTypePattern.forTypeNameAndWrappedValue(
              type1,
              MatchStmt.MaybeWildcardPrimitivePattern.forNullableExpr(wrapped1)));
    :}
  ;

match_case_patterns_list ::=
    match_case_patterns:p COMMA match_case_patterns_list:tail
    {: RESULT = tail.add(p); :}
  | match_case_patterns:p
    {: RESULT = ImmutableList.<MatchStmt.TypeMatchPattern<? extends Type>>builder().add(p); :}
  ;

match_case_pattern_struct_field_list ::=
    identifier:field_name ASSIGNMENT:eq match_case_patterns:p COMMA:comma match_case_pattern_struct_field_list:tail
    {: RESULT = tail.add(MatchStmt.StructFieldPattern.forFieldNameAndValue(field_name, p)); :}
  | identifier:field_name ASSIGNMENT:eq match_case_patterns:wp
    {: RESULT = ImmutableList.<MatchStmt.StructFieldPattern>builder().add(MatchStmt.StructFieldPattern.forFieldNameAndValue(field_name, wp)); :}
  ;

while_stmt ::=
    WHILE LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new WhileStmt(e, stmt_list); :}
  ;

for_loop_stmt ::=
    FOR LPAR identifier:ident IN expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new ForLoopStmt(ident, e, stmt_list); :}
  ;

repeat_stmt ::=
    REPEAT LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new RepeatStmt(e, stmt_list); :}
  ;

break_stmt ::=
    BREAK:b SEMICOLON
    {: RESULT = new BreakStmt(b.getCurrentInputLine(), bright, bleft, bleft + b.getLen()); :}
  ;

continue_stmt ::=
    CONTINUE:c SEMICOLON
    {: RESULT = new ContinueStmt(c.getCurrentInputLine(), cright, cleft, cleft + c.getLen()); :}
  ;

list_comprehension_expr ::=
    LBRACKET:lb expr:mapped_item_expr BAR:bar identifier:item_name IN:in expr:collection_expr RBRACKET:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_item_expr.currentLine, mapped_item_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(lbleft, mapped_item_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, rbleft);
      int endCol = max(lbleft + lb.getLen(), mapped_item_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.LIST, mapped_item_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.empty(), /*isMutable=*/false, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | MUT:mut LBRACKET:lb expr:mapped_item_expr BAR:bar identifier:item_name IN:in expr:collection_expr RBRACKET:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(mut.getCurrentInputLine(), mutright), new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_item_expr.currentLine, mapped_item_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(mutleft, lbleft, mapped_item_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, rbleft);
      int endCol = max(mutleft + mut.getLen(), lbleft + lb.getLen(), mapped_item_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.LIST, mapped_item_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.empty(), /*isMutable=*/true, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | LBRACKET:lb expr:mapped_item_expr BAR:bar identifier:item_name IN:in expr:collection_expr WHERE:where expr:filter_expr RBRACKET:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_item_expr.currentLine, mapped_item_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(where.getCurrentInputLine(), whereright), new Line(filter_expr.currentLine, filter_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(lbleft, mapped_item_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, whereleft, filter_expr.startCol, rbleft);
      int endCol = max(lbleft + lb.getLen(), mapped_item_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, whereleft + where.getLen(), filter_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.LIST, mapped_item_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.of(filter_expr), /*isMutable=*/false, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | MUT:mut LBRACKET:lb expr:mapped_item_expr BAR:bar identifier:item_name IN:in expr:collection_expr WHERE:where expr:filter_expr RBRACKET:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_item_expr.currentLine, mapped_item_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(where.getCurrentInputLine(), whereright), new Line(filter_expr.currentLine, filter_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(mutleft, lbleft, mapped_item_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, whereleft, filter_expr.startCol, rbleft);
      int endCol = max(mutleft + mut.getLen(), lbleft + lb.getLen(), mapped_item_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, whereleft + where.getLen(), filter_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.LIST, mapped_item_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.of(filter_expr), /*isMutable=*/true, currentLinesSupplier, rbright, startCol, endCol);
    :}
  ;

set_comprehension_expr ::=
    LCURLY:lb expr:mapped_item_expr BAR:bar identifier:item_name IN:in expr:collection_expr RCURLY:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_item_expr.currentLine, mapped_item_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(lbleft, mapped_item_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, rbleft);
      int endCol = max(lbleft + lb.getLen(), mapped_item_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.SET, mapped_item_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.empty(), /*isMutable=*/false, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | MUT:mut LCURLY:lb expr:mapped_item_expr BAR:bar identifier:item_name IN:in expr:collection_expr RCURLY:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(mut.getCurrentInputLine(), mutright), new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_item_expr.currentLine, mapped_item_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(mutleft, lbleft, mapped_item_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, rbleft);
      int endCol = max(mutleft + mut.getLen(), lbleft + lb.getLen(), mapped_item_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.SET, mapped_item_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.empty(), /*isMutable=*/true, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | LCURLY:lb expr:mapped_item_expr BAR:bar identifier:item_name IN:in expr:collection_expr WHERE:where expr:filter_expr RCURLY:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_item_expr.currentLine, mapped_item_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(where.getCurrentInputLine(), whereright), new Line(filter_expr.currentLine, filter_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(lbleft, mapped_item_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, whereleft, filter_expr.startCol, rbleft);
      int endCol = max(lbleft + lb.getLen(), mapped_item_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, whereleft + where.getLen(), filter_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.SET, mapped_item_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.of(filter_expr), /*isMutable=*/false, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | MUT:mut LCURLY:lb expr:mapped_item_expr BAR:bar identifier:item_name IN:in expr:collection_expr WHERE:where expr:filter_expr RCURLY:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_item_expr.currentLine, mapped_item_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(where.getCurrentInputLine(), whereright), new Line(filter_expr.currentLine, filter_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(mutleft, lbleft, mapped_item_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, whereleft, filter_expr.startCol, rbleft);
      int endCol = max(mutleft + mut.getLen(), lbleft + lb.getLen(), mapped_item_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, whereleft + where.getLen(), filter_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.SET, mapped_item_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.of(filter_expr), /*isMutable=*/true, currentLinesSupplier, rbright, startCol, endCol);
    :}
  ;

map_comprehension_expr ::=
    LCURLY:lb expr:mapped_key_expr COLON:c expr:mapped_value_expr BAR:bar identifier:item_name IN:in expr:collection_expr RCURLY:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_key_expr.currentLine, mapped_value_expr.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(mapped_value_expr.currentLine, mapped_value_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(lbleft, mapped_key_expr.startCol, cleft, mapped_value_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, rbleft);
      int endCol = max(lbleft + lb.getLen(), mapped_key_expr.endCol, cleft + c.getLen(), mapped_value_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.MAP, mapped_key_expr, mapped_value_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.empty(), /*isMutable=*/false, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | MUT:mut LCURLY:lb expr:mapped_key_expr COLON:c expr:mapped_value_expr BAR:bar identifier:item_name IN:in expr:collection_expr RCURLY:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(mut.getCurrentInputLine(), mutright), new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_key_expr.currentLine, mapped_value_expr.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(mapped_value_expr.currentLine, mapped_value_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(mutleft, lbleft, mapped_key_expr.startCol, cleft, mapped_value_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, rbleft);
      int endCol = max(mutleft + mut.getLen(), lbleft + lb.getLen(), mapped_key_expr.endCol, cleft + c.getLen(), mapped_value_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.MAP, mapped_key_expr, mapped_value_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.empty(), /*isMutable=*/true, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | LCURLY:lb expr:mapped_key_expr COLON:c expr:mapped_value_expr BAR:bar identifier:item_name IN:in expr:collection_expr WHERE:where expr:filter_expr RCURLY:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_key_expr.currentLine, mapped_value_expr.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(mapped_value_expr.currentLine, mapped_value_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(where.getCurrentInputLine(), whereright), new Line(filter_expr.currentLine, filter_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(lbleft, mapped_key_expr.startCol, cleft, mapped_value_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, whereleft, filter_expr.startCol, rbleft);
      int endCol = max(lbleft + lb.getLen(), mapped_key_expr.endCol, cleft + c.getLen(), mapped_value_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, whereleft + where.getLen(), filter_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.MAP, mapped_key_expr, mapped_value_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.of(filter_expr), /*isMutable=*/false, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | MUT:mut LCURLY:lb expr:mapped_key_expr COLON:c expr:mapped_value_expr BAR:bar identifier:item_name IN:in expr:collection_expr WHERE:where expr:filter_expr RCURLY:rb
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(mapped_key_expr.currentLine, mapped_value_expr.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(mapped_value_expr.currentLine, mapped_value_expr.currentLineNumber), new Line(bar.getCurrentInputLine(), barright), new Line(item_name.currentLine, item_name.currentLineNumber), new Line(collection_expr.currentLine, collection_expr.currentLineNumber), new Line(where.getCurrentInputLine(), whereright), new Line(filter_expr.currentLine, filter_expr.currentLineNumber), new Line(rb.getCurrentInputLine(), rbright));
      int startCol = min(mutleft, lbleft, mapped_key_expr.startCol, cleft, mapped_value_expr.startCol, barleft, item_name.startCol, inleft, collection_expr.startCol, whereleft, filter_expr.startCol, rbleft);
      int endCol = max(mutleft + mut.getLen(), lbleft + lb.getLen(), mapped_key_expr.endCol, cleft + c.getLen(), mapped_value_expr.endCol, barleft + bar.getLen(), item_name.endCol, inleft + in.getLen(), collection_expr.endCol, whereleft + where.getLen(), filter_expr.endCol, rbleft + rb.getLen());

      RESULT = new ComprehensionExpr(BaseType.MAP, mapped_key_expr, mapped_value_expr, item_name, collection_expr, /*whereClauseExpr=*/Optional.of(filter_expr), /*isMutable=*/true, currentLinesSupplier, rbright, startCol, endCol);
    :}
  ;

function_definition_stmt ::=
   FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new FunctionDefinitionStmt(name.getVal(), argTypesMap, outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse().stream().map(i -> i.toInjectedKey()).collect(ImmutableList.toImmutableList());
      RESULT = new FunctionDefinitionStmt(name.getVal(), argTypesMap, Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
    :}
  | BLOCKING FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new FunctionDefinitionStmt(name.getVal(), argTypesMap, outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR BLOCKING FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse().stream().map(i -> i.toInjectedKey()).collect(ImmutableList.toImmutableList());
      RESULT = new FunctionDefinitionStmt(name.getVal(), argTypesMap, Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new FunctionDefinitionStmt(name.getVal(), argTypesMap, outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse().stream().map(i -> i.toInjectedKey()).collect(ImmutableList.toImmutableList());
      RESULT = new FunctionDefinitionStmt(name.getVal(), argTypesMap, Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  ;

generic_function_definition_stmt ::=
   FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(name.getVal(), /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
 | REQUIRES LPAR required_contracts:required_contracts RPAR FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.getVal(), (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
 | BLOCKING FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(name.getVal(), /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
   :}
 | REQUIRES LPAR required_contracts:required_contracts RPAR BLOCKING FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.getVal(), (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
   :}
  | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.getVal(), /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  | REQUIRES LPAR required_contracts:required_contracts RPAR generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.getVal(), (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  ;

generic_blocking_on ::=
    BLOCKING COLON identifier_bar_sep_list:i
    {:
      RESULT = i.build().reverse();
    :}
  ;

identifier_bar_sep_list ::=
    IDENTIFIER:i BAR identifier_bar_sep_list:b
    {:
      RESULT = b.add(i.getVal());
    :}
  | IDENTIFIER:i
    {:
      RESULT = ImmutableList.<String>builder().add(i.getVal());
    :}
  ;

maybe_blocking_procedure_types ::=
    MAYBE_BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.getVal().resolveType(scopedHeap)), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/null);
    :}
  | MAYBE_BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/null);
    :}
  | MAYBE_BLOCKING CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), /*explicitlyAnnotatedBlocking=*/null);
    :}
  | MAYBE_BLOCKING PROVIDER_FUNCTION_TYPE:p L_ANGLE_BRACKET:la builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/null);
    :}
  ;

// TODO(steving) I need to enable generic functions to be generic over only a partial subset of the required
// TODO(steving) Contract's type params.
required_contracts ::=
    IDENTIFIER:contract_name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET COMMA required_contracts:tail
    {:
      ImmutableList<Type> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse().stream()
          .map(g -> Types.$GenericTypeParam.forTypeParamName(g)).collect(ImmutableList.toImmutableList());
      RESULT = tail.put(String.format("%s$%s", contract_name.getVal(), ScopedHeap.getDefiningModuleDisambiguator(Optional.empty())), genericTypesList);
    :}
  | scoped_identifier:dep_contract_name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET COMMA required_contracts:tail
    {:
      ImmutableList<Type> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse().stream()
          .map(g -> Types.$GenericTypeParam.forTypeParamName(g)).collect(ImmutableList.toImmutableList());
      RESULT = tail.put(
        getDisambiguatedExportedIdentifierName(dep_contract_name.getScopeName(), dep_contract_name.getIdentifier()),
        genericTypesList);
    :}
  | IDENTIFIER:contract_name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET
    {:
      ImmutableList<Type> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse().stream()
          .map(g -> Types.$GenericTypeParam.forTypeParamName(g)).collect(ImmutableList.toImmutableList());
      RESULT = ImmutableListMultimap.<String, ImmutableList<Type>>builder().put(String.format("%s$%s", contract_name.getVal(), ScopedHeap.getDefiningModuleDisambiguator(Optional.empty())), genericTypesList);
    :}
  | scoped_identifier:dep_contract_name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET
    {:
      ImmutableList<Type> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse().stream()
          .map(g -> Types.$GenericTypeParam.forTypeParamName(g)).collect(ImmutableList.toImmutableList());
      RESULT = ImmutableListMultimap.<String, ImmutableList<Type>>builder().put(
        getDisambiguatedExportedIdentifierName(dep_contract_name.getScopeName(), dep_contract_name.getIdentifier()),
        genericTypesList);
    :}
  ;

lambda_function_expr ::=
    IDENTIFIER:arg_name ARROW:a expr:implicit_return_expr
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(a.getCurrentInputLine(), aright), new Line(implicit_return_expr.currentLine, implicit_return_expr.currentLineNumber));
      int startCol = min(arg_nameleft, aleft, implicit_return_exprleft);
      int endCol = max(arg_nameleft + arg_name.getLen(), aleft + a.getLen(), implicit_return_expr.endCol);

      // In this case, we can generate our own settable reference to a TypeProvider for the ReturnStmt.
      AtomicReference<TypeProvider> returnTypeReference = new AtomicReference<>(null);
      ReturnStmt implicitReturnStmt = new ReturnStmt(implicit_return_expr, returnTypeReference);
      RESULT = new LambdaExpr(ImmutableList.of(arg_name.getVal()), new StmtListNode(implicitReturnStmt), returnTypeReference, currentLinesSupplier, implicit_return_expr.currentLineNumber, startCol, endCol);
    :}
  | IDENTIFIER:arg_name ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(a.getCurrentInputLine(), aright), new Line(lc.getCurrentInputLine(), lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.getCurrentInputLine(), rcright));
      int startCol = min(arg_nameleft, aleft, lcleft, rcleft);
      int endCol = max(arg_nameleft + arg_name.getLen(), aleft + a.getLen(), lcleft + lc.getLen(), rcleft + rc.getLen());

      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      RESULT = new LambdaExpr(ImmutableList.of(arg_name.getVal()), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
    :}
  | LAMBDA:lam LPAR:lp IDENTIFIER:first_arg_name COMMA:c identifier_list:arg_names RPAR:rp ARROW:a expr:implicit_return_expr
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lam.getCurrentInputLine(), lamright), new Line(lp.getCurrentInputLine(), lpright), new Line(first_arg_name.getCurrentInputLine(), first_arg_nameright), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue) arg_names.value).getCurrentInputLine(), arg_namesright), new Line(rp.getCurrentInputLine(), rpright), new Line(a.getCurrentInputLine(), aright), new Line(implicit_return_expr.currentLine, implicit_return_expr.currentLineNumber));
      int startCol = min(lamleft, lpleft, first_arg_nameleft, cleft, arg_names.left, rpleft, aleft, implicit_return_exprleft);
      int endCol = max(lamleft + lam.getLen(), lpleft + lp.getLen(), first_arg_nameleft + first_arg_name.getLen(), cleft + c.getLen(), arg_names.left + ((LexedValue)arg_names.value).getLen(), rpleft + rp.getLen(), aleft + a.getLen(), implicit_return_expr.endCol);

      // In this case, we can generate our own settable reference to a TypeProvider for the ReturnStmt.
      AtomicReference<TypeProvider> returnTypeReference = new AtomicReference<>(null);
      ReturnStmt implicitReturnStmt = new ReturnStmt(implicit_return_expr, returnTypeReference);
      RESULT = new LambdaExpr(((LexedValue<ImmutableList.Builder<String>>)arg_names.value).getVal().add(first_arg_name.getVal()).build().reverse(), new StmtListNode(implicitReturnStmt), returnTypeReference, currentLinesSupplier, implicit_return_exprright, startCol, endCol);
    :}
  | LAMBDA:lam LPAR:lp IDENTIFIER:first_arg_name COMMA:c identifier_list:arg_names RPAR:rp ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lam.getCurrentInputLine(), lamright), new Line(lp.getCurrentInputLine(), lpright), new Line(first_arg_name.getCurrentInputLine(), first_arg_nameright), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue)arg_names.value).getCurrentInputLine(), arg_namesright), new Line(rp.getCurrentInputLine(), rpright), new Line(a.getCurrentInputLine(), aright), new Line(lc.getCurrentInputLine(), lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.getCurrentInputLine(), rcright));
      int startCol = min(lamleft, lpleft, first_arg_nameleft, cleft, arg_names.left, rpleft, aleft, lcleft, rcleft);
      int endCol = max(lamleft + lam.getLen(), lpleft + lp.getLen(), first_arg_nameleft + first_arg_name.getLen(), cleft + c.getLen(), arg_names.left + ((LexedValue)arg_names.value).getLen(), rpleft + rp.getLen(), aleft + a.getLen(), lcleft + lc.getLen(), rcleft + rc.getLen());

      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      RESULT = new LambdaExpr(((LexedValue<ImmutableList.Builder<String>>)arg_names.value).getVal().add(first_arg_name.getVal()).build().reverse(), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
    :}
  | LPAR:lp RPAR:rp ARROW:a expr:implicit_return_expr
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lp.getCurrentInputLine(), lpright), new Line(rp.getCurrentInputLine(), rpright), new Line(a.getCurrentInputLine(), aright), new Line(implicit_return_expr.currentLine, implicit_return_expr.currentLineNumber));
      int startCol = min(lpleft, rpleft, aleft, implicit_return_expr.startCol);
      int endCol = max(lpleft + lp.getLen(), rpleft + rp.getLen(), aleft + a.getLen(), implicit_return_expr.endCol);

      // In this case, we can generate our own settable reference to a TypeProvider for the ReturnStmt.
      AtomicReference<TypeProvider> returnTypeReference = new AtomicReference<>(null);
      ReturnStmt implicitReturnStmt = new ReturnStmt(implicit_return_expr, returnTypeReference);
      RESULT = new LambdaExpr(new StmtListNode(implicitReturnStmt), returnTypeReference, currentLinesSupplier, implicit_return_expr.currentLineNumber, startCol, endCol);
    :}
  | LPAR:lp RPAR:rp ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {:
       // We won't throw type errors at this level for the StmtListNode itself (that'll be handled on the Exprs contained w/in)
       // so intentionally ignore the StmtListNode here for error lines. Pointers may be slightly off if programmer has
       // terrible indentation but in that case, fuck em.
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.getCurrentInputLine(), lpright), new Line(rp.getCurrentInputLine(), rpright), new Line(a.getCurrentInputLine(), aright), new Line(lc.getCurrentInputLine(), lcright), new Line(() -> "...", aright + 2 > rcright ? aright : aright + 1), new Line(rc.getCurrentInputLine(), rcright));
       int startCol = min(lpleft, rpleft, aleft, lcleft, rcleft);
       int endCol = max(lpleft + lp.getLen(), rpleft + rp.getLen(), aleft + a.getLen(), lcleft + lc.getLen(), rcleft + rc.getLen());

       // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
       RESULT = new LambdaExpr(stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
    :}
  ;

// TODO(steving) Lambda syntax has been complicated by parsing constraints. I don't actually want the `lambda` keyword
// TODO(steving) EVER. Figure out a way to actually define all lambda forms w/o ever using `lambda` keyword.
typed_lambda_function_expr ::=
    LPAR:lp function_args_types_list:backwards_arg_types RPAR:rp ARROW:a builtin_type:return_type LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {: // FUNCTION
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(((LexedValue) backwards_arg_types.value).getCurrentInputLine(), backwards_arg_types.right), new Line(a.getCurrentInputLine(), aright), new Line(((LexedValue) return_type.value).getCurrentInputLine(), return_type.right), new Line(lc.getCurrentInputLine(), lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.getCurrentInputLine(), rcright));
      int startCol = min(lpleft, backwards_arg_types.left, rpleft, aleft, return_type.left, lcleft, rcleft);
      int endCol = max(lpleft + lp.getLen(), backwards_arg_types.left + ((LexedValue) backwards_arg_types.value).getLen(), aleft + a.getLen(), lcleft + lc.getLen(), rcleft + rc.getLen());

      ImmutableMap<String, TypeProvider> args =
        ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build();
      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      LambdaExpr lambda = new LambdaExpr(args.keySet().asList().reverse(), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
      RESULT = new CastExpr(
        (scopedHeap) ->
          Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(
            args.values().asList().reverse().stream().map(argTypeProvider -> argTypeProvider.resolveType(scopedHeap))
              .collect(ImmutableList.toImmutableList()),
            ((LexedValue<TypeProvider>) return_type.value).getVal().resolveType(scopedHeap),
            /*explicitlyAnnotatedBlocking=*/ false),
        lambda,
        currentLinesSupplier, rcright, startCol, endCol
      );
    :}
  | LAMBDA:lam LPAR:lp function_args_types_list:backwards_arg_types RPAR:rp ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {: // CONSUMER
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lp.getCurrentInputLine(), lpright), new Line(((LexedValue) backwards_arg_types.value).getCurrentInputLine(), backwards_arg_types.right), new Line(lp.getCurrentInputLine(), lpright), new Line(a.getCurrentInputLine(), aright), new Line(lc.getCurrentInputLine(), lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.getCurrentInputLine(), rcright));
      int startCol = min(lpleft, backwards_arg_types.left, rpleft, aleft, lcleft, rcleft);
      int endCol = max(lpleft + lp.getLen(), backwards_arg_types.left + ((LexedValue)backwards_arg_types.value).getLen(), rpleft + rp.getLen(), aleft + a.getLen(), lcleft + lc.getLen(), rcleft + rc.getLen());

      ImmutableMap<String, TypeProvider> args =
        ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build();
      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      LambdaExpr lambda = new LambdaExpr(args.keySet().asList().reverse(), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
      RESULT = new CastExpr(
        (scopedHeap) ->
          Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(
            args.values().asList().reverse().stream().map(argTypeProvider -> argTypeProvider.resolveType(scopedHeap))
              .collect(ImmutableList.toImmutableList()),
            /*explicitlyAnnotatedBlocking=*/ false),
        lambda,
        currentLinesSupplier, rcright, startCol, endCol
      );
    :}
  | LAMBDA LPAR:lp RPAR:rp ARROW:a builtin_type:return_type LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {: // PROVIDER
       // We won't throw type errors at this level for the StmtListNode itself (that'll be handled on the Exprs contained w/in)
       // so intentionally ignore the StmtListNode here for error lines. Pointers may be slightly off if programmer has
       // terrible indentation but in that case, *shrug*.
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.getCurrentInputLine(), lpright), new Line(rp.getCurrentInputLine(), rpright), new Line(a.getCurrentInputLine(), aright), new Line(((LexedValue) return_type.value).getCurrentInputLine(), return_type.right), new Line(lc.getCurrentInputLine(), lcright), new Line(() -> "...", aright + 2 > rcright ? aright : aright + 1), new Line(rc.getCurrentInputLine(), rcright));
       int startCol = min(lpleft, rpleft, aleft, return_type.left, lcleft, rcleft);
       int endCol = max(lpleft + lp.getLen(), rpleft + rp.getLen(), aleft + a.getLen(), return_type.left + ((LexedValue) return_type.value).getLen(), lcleft + lc.getLen(), rcleft + rc.getLen());

       // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
       LambdaExpr lambda = new LambdaExpr(stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
       RESULT = new CastExpr(
         (scopedHeap) ->
           Types.ProcedureType.ProviderType.typeLiteralForReturnType(
             ((LexedValue<TypeProvider>) return_type.value).getVal().resolveType(scopedHeap),
             /*explicitlyAnnotatedBlocking=*/ false),
         lambda,
         currentLinesSupplier, rcright, startCol, endCol
       );
    :}
  ;

identifier_list ::=
    IDENTIFIER:arg_name COMMA:c identifier_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue)tail.value).getCurrentInputLine(), tail.right));
       int startCol = min(arg_nameleft, cleft);
       int endCol = max(arg_nameleft + arg_name.getLen(), cleft + c.getLen());
       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          LexedValue.create(
            ((LexedValue<ImmutableList.Builder<String>>)tail.value).getVal().add(arg_name.getVal()),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:arg_name
    {:
       RESULT = new Symbol(
          -1,
          arg_nameleft,
          arg_nameright, // line number
          LexedValue.create(
            ImmutableList.<String>builder().add(arg_name.getVal()),
            arg_name.getCurrentInputLine(),
            arg_name.getLen())
       );
    :}
  ;

consumer_function_definition_stmt ::=
    CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new ConsumerFunctionDefinitionStmt(name.getVal(), argTypesMap, stmt_list, /*explicitlyAnnotatedBlocking=*/false);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
        ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse().stream().map(i -> i.toInjectedKey()).collect(ImmutableList.toImmutableList());
      RESULT = new ConsumerFunctionDefinitionStmt(name.getVal(), argTypesMap, Optional.of(injectedKeysList), stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
    :}
  | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new ConsumerFunctionDefinitionStmt(name.getVal(), argTypesMap, stmt_list, /*explicitlyAnnotatedBlocking=*/true);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
        ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse().stream().map(i -> i.toInjectedKey()).collect(ImmutableList.toImmutableList());
      RESULT = new ConsumerFunctionDefinitionStmt(name.getVal(), argTypesMap, Optional.of(injectedKeysList), stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new ConsumerFunctionDefinitionStmt(name.getVal(), argTypesMap, Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
        ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse().stream().map(i -> i.toInjectedKey()).collect(ImmutableList.toImmutableList());
      RESULT = new ConsumerFunctionDefinitionStmt(name.getVal(), argTypesMap, Optional.of(injectedKeysList), stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  ;

generic_consumer_function_definition_stmt ::=
   CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
   {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(name.getVal(), /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
 | REQUIRES LPAR required_contracts:required_contracts RPAR CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
   {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.getVal(), (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
 | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
   {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(name.getVal(), /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
   :}
 | REQUIRES LPAR required_contracts:required_contracts RPAR BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
   {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.getVal(), (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
   :}
  | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.getVal(), /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  | REQUIRES LPAR required_contracts:required_contracts RPAR generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.getVal(), (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  ;

provider_function_definition_stmt ::=
    PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      RESULT = new ProviderFunctionDefinitionStmt(name.getVal(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse().stream().map(i -> i.toInjectedKey()).collect(ImmutableList.toImmutableList());
      RESULT = new ProviderFunctionDefinitionStmt(name.getVal(), Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false);
    :}
  | BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      RESULT = new ProviderFunctionDefinitionStmt(name.getVal(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse().stream().map(i -> i.toInjectedKey()).collect(ImmutableList.toImmutableList());
      RESULT = new ProviderFunctionDefinitionStmt(name.getVal(), Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true);
    :}
  ;

generic_provider_function_definition_stmt ::=
    PROVIDER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;

       ImmutableList<String> genericTypesList =
         ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
      RESULT = new GenericFunctionDefinitionStmt(name.getVal(), /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, ImmutableMap.of(), /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
    :}
  | REQUIRES LPAR required_contracts:required_contracts RPAR PROVIDER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;

       ImmutableList<String> genericTypesList =
         ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
      RESULT = new GenericFunctionDefinitionStmt(name.getVal(), (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, ImmutableMap.of(), /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
    :}
  | BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;

       ImmutableList<String> genericTypesList =
         ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
      RESULT = new GenericFunctionDefinitionStmt(name.getVal(), /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, ImmutableMap.of(), /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  | REQUIRES LPAR required_contracts:required_contracts RPAR BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;

       ImmutableList<String> genericTypesList =
         ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
      RESULT = new GenericFunctionDefinitionStmt(name.getVal(), (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, ImmutableMap.of(), /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  ;

injected_keys_list ::=
    identifier:key_name COLON:colon builtin_type:t COMMA:comma injected_keys_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentLine, key_name.currentLineNumber), new Line(colon.getCurrentInputLine(), colonright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right), new Line(comma.getCurrentInputLine(), commaright), new Line(((LexedValue) tail.value).getCurrentInputLine(), tail.right));
       int startCol = min(key_name.startCol, colonleft, t.left, commaleft, tail.left);
       int endCol = max(key_name.endCol, colonleft + colon.getLen(), t.left + ((LexedValue) t.value).getLen(), commaleft + comma.getLen(), tail.left + ((LexedValue) tail.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) tail.value).getVal()
              .add(InjectedKeyIdentifier.create(key_name, ((LexedValue<TypeProvider>) t.value).getVal(), Optional.empty())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | identifier:key_name COLON:colon builtin_type:t AS IDENTIFIER:alias COMMA:comma injected_keys_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentLine, key_name.currentLineNumber), new Line(colon.getCurrentInputLine(), colonright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right), new Line(comma.getCurrentInputLine(), commaright), new Line(((LexedValue) tail.value).getCurrentInputLine(), tail.right));
       int startCol = min(key_name.startCol, colonleft, t.left, commaleft, tail.left);
       int endCol = max(key_name.endCol, colonleft + colon.getLen(), t.left + ((LexedValue) t.value).getLen(), commaleft + comma.getLen(), tail.left + ((LexedValue) tail.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) tail.value).getVal()
              .add(InjectedKeyIdentifier.create(key_name, ((LexedValue<TypeProvider>) t.value).getVal(), Optional.of(alias.getVal()))),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | identifier:key_name COLON:c builtin_type:t
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentLine, key_name.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right));
       int startCol = min(key_name.startCol, cleft, t.left);
       int endCol = max(key_name.endCol, cleft + c.getLen(), t.left + ((LexedValue) t.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ImmutableList.<InjectedKeyIdentifier>builder().add(InjectedKeyIdentifier.create(key_name, ((LexedValue<TypeProvider>) t.value).getVal(), Optional.empty())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | identifier:key_name COLON:c builtin_type:t AS IDENTIFIER:alias
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentLine, key_name.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right));
       int startCol = min(key_name.startCol, cleft, t.left);
       int endCol = max(key_name.endCol, cleft + c.getLen(), t.left + ((LexedValue) t.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ImmutableList.<InjectedKeyIdentifier>builder().add(InjectedKeyIdentifier.create(key_name, ((LexedValue<TypeProvider>) t.value).getVal(), Optional.of(alias.getVal()))),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

// TODO(steving) Be less lazy and don't bother using a Map where we should just be using a List of pairs....but Java is so garbage it doesn't have tuples so.....
// Note that we're again building this up backwards for convenience (remember that all guava collections respect ordering).
function_args_types_list ::=
    IDENTIFIER:arg_name COLON:colon builtin_type:t COMMA:comma function_args_types_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(colon.getCurrentInputLine(), colonright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right), new Line(comma.getCurrentInputLine(), commaright), new Line(((LexedValue) tail.value).getCurrentInputLine(), tail.right));
       int startCol = min(arg_nameleft, colonleft, t.left, commaleft, tail.left);
       int endCol = max(arg_nameleft + arg_name.getLen(), colonleft + colon.getLen(), t.left + ((LexedValue) t.value).getLen(), commaleft + comma.getLen(), tail.left + ((LexedValue) tail.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) tail.value).getVal().put(arg_name.getVal(), ((LexedValue<TypeProvider>) t.value).getVal()),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:arg_name COLON:c builtin_type:t
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right));
       int startCol = min(arg_nameleft, cleft, t.left);
       int endCol = max(arg_nameleft + arg_name.getLen(), cleft + c.getLen(), t.left + ((LexedValue) t.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ImmutableMap.<String, TypeProvider>builder().put(arg_name.getVal(), ((LexedValue<TypeProvider>) t.value).getVal()),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

// LITERALLY THE ONLY DIFFERENCE BETWEEN THIS AND THE ABOVE `function_args_types_list` production is that this one gives
// IdentifierReferenceTerms instead of Strings. Useful for logging error messages. Only really applicable to Graphs for
// now since we don't actually have restrictions on procedure args in general.
// TODO(steving) Also use this production for blocking generic args so that we can indicate when blocking generics were used incorrectly.
function_args_types_list_identifiers ::=
    identifier:arg_name COLON:colon builtin_type:t COMMA:comma function_args_types_list_identifiers:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.currentLine, arg_name.currentLineNumber), new Line(colon.getCurrentInputLine(), colonright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right), new Line(comma.getCurrentInputLine(), commaright), new Line(((LexedValue) tail.value).getCurrentInputLine(), tail.right));
       int startCol = min(arg_name.startCol, colonleft, t.left, commaleft, tail.left);
       int endCol = max(arg_name.endCol, colonleft + colon.getLen(), t.left + ((LexedValue) t.value).getLen(), commaleft + comma.getLen(), tail.left + ((LexedValue) tail.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ((LexedValue<ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>>) tail.value).getVal().put(arg_name, ((LexedValue<TypeProvider>) t.value).getVal()),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | identifier:arg_name COLON:c builtin_type:t
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.currentLine, arg_name.currentLineNumber), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right));
       int startCol = min(arg_name.startCol, cleft, t.left);
       int endCol = max(arg_name.endCol, cleft + c.getLen(), t.left + ((LexedValue) t.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ImmutableMap.<IdentifierReferenceTerm, TypeProvider>builder().put(arg_name, ((LexedValue<TypeProvider>) t.value).getVal()),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

procedure_args_w_generic_blocking ::=
    IDENTIFIER:arg_name COLON maybe_blocking_procedure_types:maybe_blocking_proc COMMA procedure_args_w_generic_blocking:args_w_generic_blocking
    {:
      RESULT = args_w_generic_blocking.put(arg_name.getVal(), maybe_blocking_proc);
    :}
  | IDENTIFIER:arg_name COLON builtin_type:t COMMA procedure_args_w_generic_blocking:args_w_generic_blocking
    {:
      RESULT = args_w_generic_blocking.put(arg_name.getVal(), ((LexedValue<TypeProvider>) t.value).getVal());
    :}
  | IDENTIFIER:arg_name COLON maybe_blocking_procedure_types:maybe_blocking_proc
    {:
      RESULT = ImmutableMap.<String, TypeProvider>builder().put(arg_name.getVal(), maybe_blocking_proc);
    :}
  | IDENTIFIER:arg_name COLON builtin_type:t
    {:
      RESULT = ImmutableMap.<String, TypeProvider>builder().put(arg_name.getVal(), ((LexedValue<TypeProvider>) t.value).getVal());
    :}
  ;

return_stmt ::=
    RETURN expr:e SEMICOLON
    {:
      // All ReturnStmts belonging to the same procedure expect the same return type. Use this container to
      // act as a placeholder for the procedure to inject that context once the parsing bubbles back up.
      if (returnTypeHolder == null) {
        returnTypeHolder = new AtomicReference<>(); // Start it off empty.
      }
      RESULT = new ReturnStmt(e, returnTypeHolder);
    :}
  ;

// Just to make sure that graphs are somewhat consistent, you must either choose between putting the root node as the
// first or last node definition in the graph body. Let's encourage ordering these sanely because it can be hard to
// trace declarative code without a pattern.
graph_function_definition_stmt ::=
    GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list_identifiers:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();

      ImmutableList<Map.Entry<IdentifierReferenceTerm, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<IdentifierReferenceTerm, TypeProvider> argTypesMap =
          ImmutableMap.<IdentifierReferenceTerm, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphFunctionDefinitionStmt(
          name.getVal(),
          argTypesMap,
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list_identifiers:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();

      ImmutableList<Map.Entry<IdentifierReferenceTerm, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<IdentifierReferenceTerm, TypeProvider> argTypesMap =
          ImmutableMap.<IdentifierReferenceTerm, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphFunctionDefinitionStmt(
          name.getVal(),
          argTypesMap,
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list_identifiers:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();

      ImmutableList<Map.Entry<IdentifierReferenceTerm, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<IdentifierReferenceTerm, TypeProvider> argTypesMap =
          ImmutableMap.<IdentifierReferenceTerm, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKeyIdentifier> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse();
      RESULT = new GraphFunctionDefinitionStmt(
          name.getVal(),
          argTypesMap,
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list_identifiers:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();

      ImmutableList<Map.Entry<IdentifierReferenceTerm, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<IdentifierReferenceTerm, TypeProvider> argTypesMap =
          ImmutableMap.<IdentifierReferenceTerm, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKeyIdentifier> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse();
       RESULT = new GraphFunctionDefinitionStmt(
          name.getVal(),
          argTypesMap,
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  ;

// Just to make sure that graphs are somewhat consistent, you must either choose between putting the root node as the
// first or last node definition in the graph body. Let's encourage ordering these sanely because it can be hard to
// trace declarative code without a pattern.
graph_provider_definition_stmt ::=
    GRAPH PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphProviderDefinitionStmt(
          name.getVal(),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | GRAPH PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphProviderDefinitionStmt(
          name.getVal(),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKeyIdentifier> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse();
      RESULT = new GraphProviderDefinitionStmt(
          name.getVal(),
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKeyIdentifier> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse();
       RESULT = new GraphProviderDefinitionStmt(
          name.getVal(),
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  ;

graph_consumer_definition_stmt ::=
    GRAPH CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list_identifiers:backwards_arg_types RPAR LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      ImmutableList<Map.Entry<IdentifierReferenceTerm, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<IdentifierReferenceTerm, TypeProvider> argTypesMap =
          ImmutableMap.<IdentifierReferenceTerm, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

       RESULT = new GraphConsumerDefinitionStmt(
          name.getVal(),
          argTypesMap,
          root,
          non_root_nodes.build().reverse());
    :}
  | GRAPH CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list_identifiers:backwards_arg_types RPAR LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      ImmutableList<Map.Entry<IdentifierReferenceTerm, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<IdentifierReferenceTerm, TypeProvider> argTypesMap =
          ImmutableMap.<IdentifierReferenceTerm, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

       RESULT = new GraphConsumerDefinitionStmt(
          name.getVal(),
          argTypesMap,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list_identifiers:backwards_arg_types RPAR LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      ImmutableList<Map.Entry<IdentifierReferenceTerm, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<IdentifierReferenceTerm, TypeProvider> argTypesMap =
          ImmutableMap.<IdentifierReferenceTerm, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<InjectedKeyIdentifier> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse();
      RESULT = new GraphConsumerDefinitionStmt(
          name.getVal(),
          argTypesMap,
          Optional.of(injectedKeysList),
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list_identifiers:backwards_arg_types RPAR LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      ImmutableList<Map.Entry<IdentifierReferenceTerm, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<IdentifierReferenceTerm, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<IdentifierReferenceTerm, TypeProvider> argTypesMap =
          ImmutableMap.<IdentifierReferenceTerm, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<InjectedKeyIdentifier> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKeyIdentifier>>) bw_injected_keys.value).getVal().build().reverse();
       RESULT = new GraphConsumerDefinitionStmt(
          name.getVal(),
          argTypesMap,
          Optional.of(injectedKeysList),
          root,
          non_root_nodes.build().reverse());
    :}
  ;

root_node ::=
    ROOT IDENTIFIER:name LEFT_ARROW expr:expr SEMICOLON
    {: RESULT = new GraphNodeDefinitionStmt(name.getVal(), expr); :}
  ;

non_root_node ::=
    NODE IDENTIFIER:name LEFT_ARROW expr:expr SEMICOLON
    {: RESULT = new GraphNodeDefinitionStmt(name.getVal(), expr); :}
  ;

non_root_nodes_list ::=
    non_root_node:node non_root_nodes_list:tail
    {: RESULT = tail.add(node); :}
  | non_root_node:node
    {: RESULT = ImmutableList.<GraphNodeDefinitionStmt>builder().add(node); :}
  ;

node_reference ::=
    AT IDENTIFIER:identifier
    {: RESULT = new GraphNodeReferenceExpr(identifier.getVal(), identifier.getCurrentInputLine(), identifierright, identifierleft, identifierleft + identifier.getLen()); :}
  ;

contract_definition_stmt ::=
    CONTRACT IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LCURLY contract_signature_defs_list:contract_signature_defs_backwards RCURLY
    {:
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
      RESULT = new ContractDefinitionStmt(String.format("%s$%s", name.getVal(), ScopedHeap.getDefiningModuleDisambiguator(Optional.empty())), genericTypesList, contract_signature_defs_backwards.build().reverse());
    :}
  | CONTRACT IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types IMPLICATION_ARROW identifier_list:implied_types R_ANGLE_BRACKET LCURLY contract_signature_defs_list:contract_signature_defs_backwards RCURLY
    {:
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
      ImmutableList<String> impliedTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)implied_types.value).getVal().build().reverse();
      RESULT = new ContractDefinitionStmt(String.format("%s$%s", name.getVal(), ScopedHeap.getDefiningModuleDisambiguator(Optional.empty())), genericTypesList, impliedTypesList, contract_signature_defs_backwards.build().reverse());
    :}
  ;

contract_signature_defs_list ::=
    contract_procedure_signature_definition_stmt:signature contract_signature_defs_list:tail
    {:
      RESULT = tail.add(signature);
    :}
  | contract_procedure_signature_definition_stmt:signature
    {:
      RESULT = ImmutableList.<ContractProcedureSignatureDefinitionStmt>builder().add(signature);
    :}
  ;

contract_procedure_signature_definition_stmt ::=
   // FUNCTIONS
   FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | BLOCKING FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), Optional.of(genericTypesList));
   :}
 | BLOCKING FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.of(genericTypesList));
   :}
 | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), Optional.of(genericTypesList));
   :}

   // CONSUMERS
 | CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), Optional.of(genericTypesList));
   :}
 | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.of(genericTypesList));
   :}
 | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), Optional.of(genericTypesList));
   :}

   // PROVIDERS
 | PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.empty(), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.empty(), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | PROVIDER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR RPAR ARROW builtin_type:output_type SEMICOLON
   {: // Interestingly this production is only possible because the stdlib uses some compiler intrinsics to implement
      // this manner of generic provider signature. So, a fun fact is that every procedure w/ this signature validated
      // by the compiler will touch one of those specific stdlib procedures at some point (or else it returns a value
      // that does not actually contain an instance of the generic type
      // (e.g. `provider foo<T>() -> oneof<Other, T> { return Other(...); }`).
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<String> genericTypesList =
       ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.empty(), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), Optional.of(genericTypesList));
   :}
  ;

contract_implementation_stmt ::=
    IMPLEMENT IDENTIFIER:contract_name L_ANGLE_BRACKET builtin_types_list:concrete_types R_ANGLE_BRACKET LCURLY contract_implementations_list:contract_impls RCURLY
    {:
       RESULT = new ContractImplementationStmt(String.format("%s$%s", contract_name.getVal(), ScopedHeap.getDefiningModuleDisambiguator(Optional.empty())), ((LexedValue<ImmutableList<TypeProvider>>) concrete_types.value).getVal(), contract_impls.build().reverse());
    :}
  | IMPLEMENT scoped_identifier:dep_contract_name L_ANGLE_BRACKET builtin_types_list:concrete_types R_ANGLE_BRACKET LCURLY contract_implementations_list:contract_impls RCURLY
    {:
       RESULT = new ContractImplementationStmt(
          getDisambiguatedExportedIdentifierName(dep_contract_name.getScopeName(), dep_contract_name.getIdentifier()),
          ((LexedValue<ImmutableList<TypeProvider>>) concrete_types.value).getVal(),
          contract_impls.build().reverse());
    :}
  ;

contract_implementations_list ::=
    function_definition_stmt:f contract_implementations_list:tail
    {: RESULT = tail.add(new ContractProcedureImplementationStmt(f)); :}
  | consumer_function_definition_stmt:c contract_implementations_list:tail
    {: RESULT = tail.add(new ContractProcedureImplementationStmt(c)); :}
  | provider_function_definition_stmt:p contract_implementations_list:tail
    {: RESULT = tail.add(new ContractProcedureImplementationStmt(p)); :}
  | generic_function_definition_stmt:f contract_implementations_list:tail
    {: RESULT = tail.add(constructContractProcImplStmtForGenericProcDefStmt(f)); :}
  | generic_consumer_function_definition_stmt:c contract_implementations_list:tail
    {: RESULT = tail.add(constructContractProcImplStmtForGenericProcDefStmt(c)); :}

  | function_definition_stmt:f
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(new ContractProcedureImplementationStmt(f)); :}
  | consumer_function_definition_stmt:c
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(new ContractProcedureImplementationStmt(c)); :}
  | provider_function_definition_stmt:p
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(new ContractProcedureImplementationStmt(p)); :}
  | generic_function_definition_stmt:f
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(constructContractProcImplStmtForGenericProcDefStmt(f)); :}
  | generic_consumer_function_definition_stmt:c
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(constructContractProcImplStmtForGenericProcDefStmt(c)); :}
  ;

pipe_chain_stmt ::=
    expr:source pipe_chain:p
    {:
       RESULT =
        new PipeChainStmt(
          source,
          ((ImmutableList.Builder<Object>) p.get(1)).build().reverse(), // chain exprs
          (Stmt) p.get(0) // sink stmt
        );
    :}
  ;

pipe_chain ::=
    PIPE_ARROW:a expr:expr pipe_chain:p
    {:
       // Finally, add the current expr in the pipe chain to the list builder where I'm collecting exprs.
       ((ImmutableList.Builder<Object>) p.get(1)).add(expr);
       RESULT = p;
    :}
  | PIPE_ARROW consumer_function_call_stmt:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  | PIPE_ARROW identifier_assignment:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  | PIPE_ARROW identifier_declaration:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  | PIPE_ARROW list_element_assignment:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  | PIPE_ARROW print:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  ;

function_call_expr ::=
    non_lambda_exprs:function LPAR:l args_list:args RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(function), new Line(l.getCurrentInputLine(), lright), new Line(args), new Line(r.getCurrentInputLine(), rright));
       int startCol = min(function.startCol, lleft, args.left, rleft);
       int endCol = max(function.endCol, lleft + l.getLen(), args.left + ((LexedValue)args.value).getLen(), rleft + r.getLen());
       if (function instanceof IdentifierReferenceTerm) {
         // Here, we may actually need to do some more complex handling of generic functions or something like a user-defined-type constructor.
         RESULT = new FunctionCallExpr(((IdentifierReferenceTerm) function).identifier, ((LexedValue<ImmutableList.Builder<Expr>>)args.value).getVal().build().reverse(), currentLinesSupplier, rright, startCol, endCol);
       } else {
         RESULT = new FirstClassFunctionCallExpr(function, ((LexedValue<ImmutableList.Builder<Expr>>)args.value).getVal().build().reverse(), currentLinesSupplier, rright, startCol, endCol);
       }
    :}
  | scoped_identifier:scoped_identifier LPAR:l args_list:args RPAR:r
  // Foo::bar(arg1, ..., argN)
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(scoped_identifier.getCurrentInputLine(), scoped_identifierright), new Line(l.getCurrentInputLine(), lright), new Line(args), new Line(r.getCurrentInputLine(), rright));
       int startCol = min(scoped_identifier.getStartCol(), lleft, args.left, rleft);
       int endCol = max(scoped_identifier.getStartCol() + scoped_identifier.getOverallLen(), lleft + l.getLen(), args.left + ((LexedValue)args.value).getLen(), rleft + r.getLen());

       // This syntax is technically contextual (read: ambiguous) depending upon whether the "contract_name" is actually
       // the name of a dep module or not.
       String contractNameStr = scoped_identifier.getScopeName();
       if (ScopedHeap.currProgramDepModules.containsRow(contractNameStr)) {
         // Mark this dep as used, so that we can track whether the program's declared deps are *actually* necessary.
         ScopedHeap.markDepModuleUsed(contractNameStr);
         // This is actually a call to a procedure defined in a dep module, not a contract procedure call.
         RESULT = new FunctionCallExpr(contractNameStr, scoped_identifier.getIdentifier(), ((LexedValue<ImmutableList.Builder<Expr>>)args.value).getVal().build().reverse(), currentLinesSupplier, rright, startCol, endCol);
       } else {
         // This is in fact a contract procedure call, referencing a contract defined w/in this current compilation unit.
         RESULT =
          new ContractFunctionCallExpr(
            contractNameStr.contains("$") ? contractNameStr : String.format("%s$%s", contractNameStr, ScopedHeap.getDefiningModuleDisambiguator(Optional.empty())),
            scoped_identifier.getScopeNameIdentifierReferenceTerm(Optional.empty()),
            scoped_identifier.getIdentifier(),
            scoped_identifier.getIdentifierIdentifierReferenceTerm(Optional.empty()),
            ((LexedValue<ImmutableList.Builder<Expr>>)args.value).getVal().build().reverse(),
            currentLinesSupplier, rright, startCol, endCol);
       }
    :}
  ;

provider_function_call_expr ::=
    non_lambda_exprs:provider_name LPAR:l RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(provider_name), new Line(l.getCurrentInputLine(), lright), new Line(r.getCurrentInputLine(), rright));
       int startCol = min(provider_name.startCol, lleft, rleft);
       int endCol = max(provider_name.endCol, lleft + l.getLen(), rleft + r.getLen());
       if (provider_name instanceof IdentifierReferenceTerm) {
         // Here, we may actually need to do some more complex handling of generic functions or something like a user-defined-type constructor.
         RESULT = new ProviderFunctionCallExpr(((IdentifierReferenceTerm) provider_name).identifier, currentLinesSupplier, rright, startCol, endCol);
       } else {
         RESULT = new FirstClassProviderFunctionCallExpr(provider_name, currentLinesSupplier, rright, startCol, endCol);
       }
    :}
  | scoped_identifier:scoped_identifier LPAR:l RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(scoped_identifier.getCurrentInputLine(), scoped_identifierright), new Line(l.getCurrentInputLine(), lright), new Line(r.getCurrentInputLine(), rright));
       int startCol = min(scoped_identifier.getStartCol(), lleft, rleft);
       int endCol = max(scoped_identifier.getStartCol() + scoped_identifier.getOverallLen(), lleft + l.getLen(), rleft + r.getLen());

       // This syntax is technically contextual (read: ambiguous) depending upon whether the "contract_name" is actually
       // the name of a dep module or not.
       String contractNameStr = scoped_identifier.getScopeName();
       if (ScopedHeap.currProgramDepModules.containsRow(contractNameStr)) {
         // Mark this dep as used, so that we can track whether the program's declared deps are *actually* necessary.
         ScopedHeap.markDepModuleUsed(contractNameStr);
         // This is actually a call to a procedure defined in a dep module, not a contract procedure call.
         RESULT = new ProviderFunctionCallExpr(contractNameStr, scoped_identifier.getIdentifier(), currentLinesSupplier, rright, startCol, endCol);
       } else {
         RESULT = new ContractProviderFunctionCallExpr(
           contractNameStr.contains("$") ? contractNameStr : String.format("%s$%s", contractNameStr, ScopedHeap.getDefiningModuleDisambiguator(Optional.empty())),
           scoped_identifier.getScopeNameIdentifierReferenceTerm(Optional.empty()),
           scoped_identifier.getIdentifier(),
           scoped_identifier.getIdentifierIdentifierReferenceTerm(Optional.empty()),
           currentLinesSupplier, rright, startCol, endCol);
       }
    :}
  ;

consumer_function_call_stmt ::=
    non_lambda_exprs:consumer_name LPAR args_list:args RPAR SEMICOLON
    {:
       if (consumer_name instanceof IdentifierReferenceTerm) {
         // Here, we may actually need to do some more complex handling of generic functions or something like a user-defined-type constructor.
         RESULT = new ConsumerFunctionCallStmt(((IdentifierReferenceTerm) consumer_name).identifier, ((LexedValue<ImmutableList.Builder<Expr>>)args.value).getVal().build().reverse());
       } else {
         RESULT = new FirstClassConsumerFunctionCallStmt(consumer_name, ((LexedValue<ImmutableList.Builder<Expr>>)args.value).getVal().build().reverse());
       }
    :}
  | scoped_identifier:scoped_identifier LPAR:l args_list:args RPAR:r SEMICOLON
    {:
       // This syntax is technically contextual (read: ambiguous) depending upon whether the "contract_name" is actually
       // the name of a dep module or not.
       String contractNameStr = scoped_identifier.getScopeName();
       if (ScopedHeap.currProgramDepModules.containsRow(contractNameStr)) {
         // Mark this dep as used, so that we can track whether the program's declared deps are *actually* necessary.
         ScopedHeap.markDepModuleUsed(contractNameStr);
         // This is actually a call to a procedure defined in a dep module, not a contract procedure call.
         RESULT = new ConsumerFunctionCallStmt(contractNameStr, scoped_identifier.getIdentifier(), ((LexedValue<ImmutableList.Builder<Expr>>)args.value).getVal().build().reverse());
       } else {
         RESULT = new ContractConsumerFunctionCallStmt(
           contractNameStr.contains("$") ? contractNameStr : String.format("%s$%s", contractNameStr, ScopedHeap.getDefiningModuleDisambiguator(Optional.empty())),
           scoped_identifier.getScopeNameIdentifierReferenceTerm(Optional.empty()),
           scoped_identifier.getIdentifier(),
           scoped_identifier.getIdentifierIdentifierReferenceTerm(Optional.empty()),
           ((LexedValue<ImmutableList.Builder<Expr>>)args.value).getVal().build().reverse());
       }
    :}
  ;

inequality ::=
    expr:a L_ANGLE_BRACKET:l expr:b
    {:
       RESULT = constructBinaryExpr(a, l, lleft, lright, b, (currentLinesSupplier) -> (startCol, endCol) -> new LessThanBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a R_ANGLE_BRACKET:r expr:b
    {:
       RESULT = constructBinaryExpr(a, r, rleft, rright, b, (currentLinesSupplier) -> (startCol, endCol) -> new GreaterThanBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a LTE:lte expr:b
    {:
       RESULT = constructBinaryExpr(a, lte, lteleft, lteright, b, (currentLinesSupplier) -> (startCol, endCol) -> new LessThanOrEqualToBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a GTE:gte expr:b
    {:
       RESULT = constructBinaryExpr(a, gte, gteleft, gteright, b, (currentLinesSupplier) -> (startCol, endCol) -> new GreaterThanOrEqualToBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  ;

bool_arithmetic ::=
    expr:a AND:and expr:b
    {:
       RESULT = constructBinaryExpr(a, and, andleft, andright, b, (currentLinesSupplier) -> (startCol, endCol) -> new AndBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a OR:or expr:b
    {:
       RESULT = constructBinaryExpr(a, or, orleft, orright, b, (currentLinesSupplier) -> (startCol, endCol) -> new OrBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | NOT:n expr:a
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(n.getCurrentInputLine(), nright), new Line(a));
       int startCol = Math.min(nleft, a.startCol);
       int endCol = Math.max(a.endCol, nleft + n.getLen());
       RESULT = new NotBoolExpr(a, currentLinesSupplier, a.currentLineNumber, startCol, endCol);
    :}
  ;

instanceof_expr ::=
    expr:a INSTANCEOF:op builtin_type:b
    {:
       Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(op.getCurrentInputLine(), opright), new Line(((LexedValue) b.value).getCurrentInputLine(), b.right));
       int startCol = min(a.startCol, opleft, b.left);
       int endCol = max(a.endCol, opleft + op.getLen(), b.left + ((LexedValue) b.value).getLen());

       RESULT = new InstanceofBoolExpr(a, ((LexedValue<TypeProvider>) b.value).getVal(), currentLinesSupplier, bright, startCol, endCol);
    :}
  ;

fmt_string ::=
    FMT_STRING_PART:fs expr:e fmt_string:fswt
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(fs.getCurrentInputLine(), fsright), new Line(e.currentLine, e.currentLineNumber), new Line(((LexedValue) fswt.value).getCurrentInputLine(), fswt.right));
       int startCol = min(fsleft, e.startCol, fswt.left);
       int endCol = max(fsleft + fs.getLen(), e.endCol, fswt.left + ((LexedValue) fswt.value).getLen());

       ImmutableList<ImmutableList.Builder> fswtList = ((LexedValue<ImmutableList<ImmutableList.Builder>>)fswt.value).getVal();
       fswtList.get(0).add(fs.getVal());
       fswtList.get(1).add(e);

       RESULT = new Symbol(
          -1,
          startCol,
          fswt.right, // line number
          LexedValue.create(
            fswtList,
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FMT_STRING_PART:fs expr:e STRING:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(fs.getCurrentInputLine(), fsright), new Line(e.currentLine, e.currentLineNumber), new Line(tail.getCurrentInputLine(), tailright));
       int startCol = min(fsleft, e.startCol, tailleft);
       int endCol = max(fsleft + fs.getLen(), e.endCol, tailleft + tail.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          tailright, // line number
          LexedValue.create(
            ImmutableList.of(ImmutableList.builder().add(tail.getVal()).add(fs.getVal()), ImmutableList.builder().add(e)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

http_service_def_stmt ::=
    HTTP_SERVICE identifier:service_name LCURLY http_endpoints_list:endpoints RCURLY
    {: RESULT = new HttpServiceDefStmt(service_name, endpoints.build()); :}
  ;

http_endpoints_list ::=
    identifier:endpoint_name COLON fmt_string:path COMMA http_endpoints_list:tail
    {:
       LexedValue<ImmutableList<ImmutableList.Builder>> fsLexedValue = (LexedValue<ImmutableList<ImmutableList.Builder>>) path.value;
       ImmutableList<ImmutableList.Builder> fs = fsLexedValue.getVal();
       FormatStringExpr pathFmtStringExpr = new FormatStringExpr(fs.get(0).build().reverse(), fs.get(1).build().reverse(), fsLexedValue.getCurrentInputLine(), path.right, path.left, path.left + fsLexedValue.getLen());

       RESULT = tail.put(endpoint_name, pathFmtStringExpr);
    :}
  | identifier:endpoint_name COLON STRING:path COMMA http_endpoints_list:tail
    {:
      RESULT = tail.put(endpoint_name, path.getVal());
    :}
  | identifier:endpoint_name COLON fmt_string:path
    {:
       LexedValue<ImmutableList<ImmutableList.Builder>> fsLexedValue = (LexedValue<ImmutableList<ImmutableList.Builder>>) path.value;
       ImmutableList<ImmutableList.Builder> fs = fsLexedValue.getVal();
       FormatStringExpr pathFmtStringExpr = new FormatStringExpr(fs.get(0).build().reverse(), fs.get(1).build().reverse(), fsLexedValue.getCurrentInputLine(), path.right, path.left, path.left + fsLexedValue.getLen());

       RESULT = ImmutableMap.<IdentifierReferenceTerm, Object>builder().put(endpoint_name, pathFmtStringExpr);
    :}
  | identifier:endpoint_name COLON STRING:path
    {:
       RESULT = ImmutableMap.<IdentifierReferenceTerm, Object>builder().put(endpoint_name, path.getVal());
    :}
  ;

endpoint_handlers_block_stmt ::=
    ENDPOINT_HANDLERS identifier:service LCURLY endpoint_handler_impl_graphs_list:endpoint_impls RCURLY
    {: RESULT = new EndpointHandlersBlockStmt(service, endpoint_impls.build().reverse()); :}
  ;

endpoint_handler_impl_graphs_list ::=
    graph_function_definition_stmt:g endpoint_handler_impl_graphs_list:tail
    {: RESULT = tail.add(g); :}
  | graph_provider_definition_stmt:g endpoint_handler_impl_graphs_list:tail
    {: RESULT = tail.add(g); :}
  | graph_function_definition_stmt:g
    {: RESULT = ImmutableList.<GraphProcedureDefinitionStmt>builder().add(g); :}
  | graph_provider_definition_stmt:g
    {: RESULT = ImmutableList.<GraphProcedureDefinitionStmt>builder().add(g); :}
  ;

get_http_client_expr ::=
    GET_HTTP_CLIENT:g LPAR:l expr:base_url RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(g.getCurrentInputLine(), gright), new Line(l.getCurrentInputLine(), lright), new Line(base_url), new Line(r.getCurrentInputLine(), rright));
       int startCol = min(gleft, lleft, base_url.startCol, rleft);
       int endCol = max(gleft + g.getLen(), lleft + l.getLen(), base_url.endCol, rleft + r.getLen());
       RESULT = new GetHttpClientExpr(base_url, currentLinesSupplier, rright, startCol, endCol);
    :}
  ;

get_basic_http_server_for_port_expr ::=
    GET_BASIC_HTTP_SERVER_FOR_PORT:g LPAR:l expr:port RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(g.getCurrentInputLine(), gright), new Line(l.getCurrentInputLine(), lright), new Line(port), new Line(r.getCurrentInputLine(), rright));
       int startCol = min(gleft, lleft, port.startCol, rleft);
       int endCol = max(gleft + g.getLen(), lleft + l.getLen(), port.endCol, rleft + r.getLen());
       RESULT = new GetHttpServerExpr(port, currentLinesSupplier, rright, startCol, endCol);
    :}
  ;

privileged_inline_java ::=
    PRIVILEGED_INLINE_JAVA:java
    {: RESULT = new PrivilegedInlineJavaStmt(java.getVal(), java.getCurrentInputLine().get()); :}
  ;

// The last production 'term' closes the grammar. It's a primitive or identifier reference.
term ::=
    primitive:p
    {: RESULT = p; :}
  | identifier:i
    {: RESULT = i; :}
  | scoped_identifier:s
    {: RESULT = s.getOverallIdentifierReferenceTerm(getDisambiguatedExportedIdentifierName(s.getScopeName(), s.getIdentifier()), ScopedHeap.getDefiningModuleDisambiguator(Optional.of(s.getScopeName()))); :}
  | node_reference:nr
    {: RESULT = nr; :}
  | UP_ARROW:a
    {:
       RESULT =
        new PipeChainBackreferenceTerm(
          a.getCurrentInputLine(),
          aright,
          aleft,
          aleft + a.getLen()
        );
    :}
  ;

identifier ::=
    IDENTIFIER:identifier
    {: RESULT = new IdentifierReferenceTerm(identifier.getVal(), identifier.getCurrentInputLine(), identifierright, identifierleft, identifierleft + identifier.getLen()); :}
  ;

scoped_identifier ::=
    SCOPED_IDENTIFIER:scoped_identifier
    {:
       String depModuleName = scoped_identifier.getVal().getScopeName();
       if (ScopedHeap.currProgramDepModules.containsRow(depModuleName)) {
         // Mark this dep as used, so that we can track whether the program's declared deps are *actually* necessary.
         ScopedHeap.markDepModuleUsed(depModuleName);
       }
       RESULT = scoped_identifier.getVal();
    :}
  ;

primitive ::=
    float:f
    {: RESULT = f; :}
  | DOUBLE:d
    {: RESULT = new DoubleTerm(Double.parseDouble(d.getVal().substring(0, d.getVal().length() - 1)), d.getCurrentInputLine(), dright, dleft, dleft + d.getLen()); :}
  | integer:i
    {: RESULT = i; :}
  | LONG:l
    {: RESULT = new LongTerm(Long.parseLong(l.getVal().substring(0, l.getVal().length() - 1)), l.getCurrentInputLine(), lright, lleft, lleft + l.getLen()); :}
  | STRING:s
    {: RESULT = new StringTerm(s.getVal(), s.getCurrentInputLine(), sright, sleft, sleft + s.getLen()); :}
  | CHAR:s
    {: RESULT = new CharTerm(s.getVal(), s.getCurrentInputLine(), sright, sleft, sleft + s.getLen()); :}
  | TRUE:t
    {: RESULT = new TrueTerm(t.getCurrentInputLine(), tright, tleft, tleft + t.getLen()); :}
  | FALSE:f
    {: RESULT = new FalseTerm(f.getCurrentInputLine(), fright, fleft, fleft + f.getLen()); :}
  ;

float ::=
    FLOAT:f
    {: RESULT = new FloatTerm(f.getVal(), f.getCurrentInputLine(), fright, fleft, fleft + f.getLen()); :}
  ;

integer ::=
    INTEGER:i
    {: RESULT = new IntegerTerm(i.getVal(), i.getCurrentInputLine(), iright, ileft, ileft + i.getLen()); :}
  ;
