{
  "stdlib$http$http": {
    "api": "\nfunction getOk200HttpResponseForHtml(json: string) -> HttpResponse;\n\nfunction getOk200HttpResponseForJson(json: string) -> HttpResponse;\n",
    "deps": {}
  },
  "examples$claro_programs$demo_server$buggy_buggies$buggy_buggies_service$buggy_buggies_client": {
    "api": "\n# This encodes the public API of the Buggy-Buggies site available at https://buggy-buggies.gigalixirapp.com/.\n# Claro will generate a non-blocking RPC client for you via the following:\n#   `var myClient: HttpClient<BuggyBuggies> = getHttpClient(\"https://buggy-buggies.gigalixirapp.com\");`\nHttpService BuggyBuggies {\n  hostGame: \"/api/host/{handle}\",\n  friendsJoin: \"/api/game/{gameId}/join/{handle}\",\n  move: \"/api/game/{gameId}/player/{secret}/move/{direction}\",\n  worldInfo: \"/api/game/{gameId}/player/{secret}/info\",\n  reset: \"/api/game/{gameId}/player/{secret}/reset\"\n}\n\n# Now there's a single static definition of which client will be used for sending reqs to the Buggy Buggies server.\nstatic HTTP_CLIENT: HttpClient<BuggyBuggies>;\n\n# This type models the JSON response from the Buggy-Buggies service as a Claro type to enable parsing the response into\n# something that you can work with programmatically with strict type validation on the edge.\nalias MoveResponse : struct {\n  reason: oneof<string, std::Nothing>,\n  result: struct {\n    players: { string : struct { x: int, y: int } },\n    dimensions: struct {\n      height: int,\n      width: int\n    },\n    world: { string: string }, # E.g. (\"0,6\": \"wall\")\n    you: struct {\n      handle: string,\n      purse: int,\n      boom: boolean,\n      x: int,\n      y: int\n    }\n  },\n  success: boolean\n}\n\nfunction getParsedMoveResponse(buggyResponse: string) -> std::ParsedJson<MoveResponse>;\n",
    "deps": {}
  },
  "examples$claro_programs$demo_server$buggy_buggies$data_structures$default_dict": {
    "api": "newtype DefaultDict<K,V>: struct {defaultPr: provider<V>, dict: mut {K:V}}\n\ninitializers DefaultDict {\n  function create<K,V>(defaultPr: provider<V>) -> DefaultDict<K,V>;\n}\n\n# TODO(steving) Claro really needs to support overloading operator[] via some Contract.\nunwrappers DefaultDict {\n  function get<K,V>(d: DefaultDict<K,V>, key: K) -> V;\n  consumer put<K,V>(d: DefaultDict<K,V>, key: K, value: V);\n  function asMap<K,V>(d: DefaultDict<K,V>) -> {K: V};\n}\n",
    "deps": {}
  },
  "examples$claro_programs$demo_server$buggy_buggies$data_structures$position": {
    "api": "\nnewtype Position : struct {x: int, y: int}\n",
    "deps": {}
  },
  "examples$claro_programs$demo_server$buggy_buggies$data_structures$heap": {
    "api": "\n# This implementation is the result of asking Chat GPT to implement it in python for me and reworking it to fit in Claro\n# I'm not thinking too hard about this...\nnewtype Heap: mut [struct {dist: int, pos: Pos::Position}]\n\ninitializers Heap {\n  provider getHeap() -> Heap;\n}\n\nunwrappers Heap {\n  function extract_min(heap: Heap) -> oneof<Pos::Position, std::Error<std::Nothing>>;\n  consumer insert(heap: Heap, value: struct {dist: int, pos: Pos::Position});\n  function heapIsEmpty(heap: Heap) -> boolean;\n}\n",
    "deps": {"Pos": "examples$claro_programs$demo_server$buggy_buggies$data_structures$position"}
  },
  "examples$claro_programs$demo_server$buggy_buggies$buggy_agent$buggy_agent": {
    "api": "\nalias BestPath : [Pos::Position]\n\nfunction parseWorldMap(world: {string: string}) -> {Pos::Position: string};\nfunction dijkstra(world: {Pos::Position: string}, start: Pos::Position) -> BestPath;\nfunction movesFromBestPath(bestPath: BestPath) -> [string];\n",
    "deps": {"DefaultDict": "examples$claro_programs$demo_server$buggy_buggies$data_structures$default_dict",
      "Heaps": "examples$claro_programs$demo_server$buggy_buggies$data_structures$heap",
      "Pos": "examples$claro_programs$demo_server$buggy_buggies$data_structures$position"}
  },
  "examples$claro_programs$demo_server$buggy_buggies$utils$utils": {
    "api": "# This module is simply a dumping ground of uncategorized utility functions.\n\nfunction handleBuggyResponseAsHtmlStrParts(buggyResponse: oneof<string, std::Error<string>>) -> [string];\nfunction reduce<T, R>(l: [T], accumulated: R, accumulatorFn: function<|R, T| -> R>) -> R;\n",
    "deps": {}
  },
  "examples$claro_programs$demo_server$buggy_buggies$endpoint_handlers$resources$resources": {
    "api": "\nstatic gamePageHtml : string;\n",
    "deps": {}
  },
  "examples$claro_programs$demo_server$buggy_buggies$endpoint_handlers$endpoint_handlers": {
    "api": "\n# It's worth noting that in the Claro way of the world, this distinction of whether a Procedure is implemented as a\n# Graph or not is considered completely an internal implementation consideration that's not directly observable with\n# in-language semantics. Hence, this is *actually* implemented internally as a Graph Procedure, but that detail just\n# isn't exposed here.\nprovider gamePageHandler() -> future<string>;\n\nfunction startNewGameHandler(handle: string) -> future<string>;\n\nfunction getBestMovesHandler(buggyResponse: oneof<string, std::Error<string>>) -> string;\n\nfunction gameMoveHandler(gameId: string, playerSecret: string, dir: string) -> future<string>;\n",
    "deps": {"Agent": "examples$claro_programs$demo_server$buggy_buggies$buggy_agent$buggy_agent",
      "BuggyBuggies": "examples$claro_programs$demo_server$buggy_buggies$buggy_buggies_service$buggy_buggies_client",
      "Utils": "examples$claro_programs$demo_server$buggy_buggies$utils$utils",
      "Pos": "examples$claro_programs$demo_server$buggy_buggies$data_structures$position",
      "Resources": "examples$claro_programs$demo_server$buggy_buggies$endpoint_handlers$resources$resources"}
  }
}
