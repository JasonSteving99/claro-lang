<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Claro Programming Language (DRAFT)</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom_blocks.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="chapter_1.html">Welcome to Claro!</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="chapter_1/hello_world.generated_docs.html"><strong aria-hidden="true">1.</strong> Hello, World</a></li><li class="chapter-item expanded "><a href="getting_started/getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/understanding_starter_project/understanding_starter_project.generated_docs.html"><strong aria-hidden="true">2.1.</strong> Understanding the Starter Project</a></li><li class="chapter-item expanded "><a href="getting_started/first_program/first_program.generated_docs.html"><strong aria-hidden="true">2.2.</strong> Your First Program</a></li><li class="chapter-item expanded "><a href="getting_started/intro_to_modules/intro_to_modules.generated_docs.html"><strong aria-hidden="true">2.3.</strong> Intro to Modules</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="common_programming_concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="common_programming_concepts/variables_and_types/variables_and_types.generated_docs.html"><strong aria-hidden="true">3.1.</strong> Variables & Primitive Types</a></li><li class="chapter-item expanded "><a href="common_programming_concepts/sep_var_decl_and_init/sep_var_decl_and_init.generated_docs.html"><strong aria-hidden="true">3.2.</strong> Separate Variable Declaration & Initialization</a></li><li class="chapter-item expanded "><a href="common_programming_concepts/var_reassignment/var_reassignment.generated_docs.html"><strong aria-hidden="true">3.3.</strong> Variable Reassignment</a></li><li class="chapter-item expanded "><a href="common_programming_concepts/string_formatting/string_formatting.generated_docs.html"><strong aria-hidden="true">3.4.</strong> String Formatting</a></li><li class="chapter-item expanded "><a href="control_flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control_flow/if_else/if_else.generated_docs.html"><strong aria-hidden="true">3.5.1.</strong> If-Else</a></li><li class="chapter-item expanded "><a href="control_flow/while/while.generated_docs.html"><strong aria-hidden="true">3.5.2.</strong> While</a></li><li class="chapter-item expanded "><a href="control_flow/for/for.generated_docs.html"><strong aria-hidden="true">3.5.3.</strong> For</a></li><li class="chapter-item expanded "><a href="control_flow/repeat/repeat.generated_docs.html"><strong aria-hidden="true">3.5.4.</strong> Repeat</a></li><li class="chapter-item expanded "><a href="control_flow/pipes/pipes.generated_docs.html"><strong aria-hidden="true">3.5.5.</strong> Pipes</a></li><li class="chapter-item expanded "><a href="control_flow/match/match.generated_docs.html"><strong aria-hidden="true">3.5.6.</strong> Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control_flow/match/structed_data/structured_data.generated_docs.html"><strong aria-hidden="true">3.5.6.1.</strong> Matching Structured Data</a></li><li class="chapter-item expanded "><a href="control_flow/match/wildcards/wildcards.generated_docs.html"><strong aria-hidden="true">3.5.6.2.</strong> Wildcard Patterns</a></li><li class="chapter-item expanded "><a href="control_flow/match/exhaustiveness_checks/exhaustiveness_checks.generated_docs.html"><strong aria-hidden="true">3.5.6.3.</strong> Static Exhaustiveness Checks</a></li></ol></li><li class="chapter-item expanded "><a href="control_flow/collection_comprehension/collection_comprehension.generated_docs.html"><strong aria-hidden="true">3.5.7.</strong> Collection Comprehension</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control_flow/collection_comprehension/more_than_syntax_sugar/more_than_syntax_sugar.generated_docs.html"><strong aria-hidden="true">3.5.7.1.</strong> Comprehension is More Than Syntax Sugar</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="static_typing/static_typing.generated_docs.html"><strong aria-hidden="true">4.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static_typing/builtin_colls/builtin_collections.generated_docs.html"><strong aria-hidden="true">4.1.</strong> Builtin Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static_typing/builtin_colls/list_type/list_type.generated_docs.html"><strong aria-hidden="true">4.1.1.</strong> Lists</a></li><li class="chapter-item expanded "><a href="static_typing/builtin_colls/set_type/set_type.generated_docs.html"><strong aria-hidden="true">4.1.2.</strong> Sets</a></li><li class="chapter-item expanded "><a href="static_typing/builtin_colls/map_type/map_type.generated_docs.html"><strong aria-hidden="true">4.1.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="static_typing/builtin_colls/tuple_type/tuple_type.generated_docs.html"><strong aria-hidden="true">4.1.4.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="static_typing/builtin_colls/struct_type/struct_type.generated_docs.html"><strong aria-hidden="true">4.1.5.</strong> Structs</a></li></ol></li><li class="chapter-item expanded "><a href="static_typing/oneofs/oneofs.generated_docs.html"><strong aria-hidden="true">4.2.</strong> Oneofs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static_typing/oneofs/narrowing/narrowing.generated_docs.html"><strong aria-hidden="true">4.2.1.</strong> "Narrowing" / Type Guards</a></li></ol></li><li class="chapter-item expanded "><a href="static_typing/atoms/atoms.generated_docs.html"><strong aria-hidden="true">4.3.</strong> Atoms</a></li><li class="chapter-item expanded "><a href="static_typing/aliases/aliases.generated_docs.html"><strong aria-hidden="true">4.4.</strong> Aliases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static_typing/aliases/not_a_new_type_decl/not_a_new_type_decl.generated_docs.html"><strong aria-hidden="true">4.4.1.</strong> Aliases are Not a New Type Declaration</a></li></ol></li><li class="chapter-item expanded "><a href="static_typing/user_defined_types/user_defined_types.generated_docs.html"><strong aria-hidden="true">4.5.</strong> User Defined Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static_typing/user_defined_types/parameterized_types/parameterized_types.generated_docs.html"><strong aria-hidden="true">4.5.1.</strong> Parameterized Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static_typing/user_defined_types/parameterized_types/concrete_type_inference/concrete_type_inference.generated_docs.html"><strong aria-hidden="true">4.5.1.1.</strong> Concrete Type Inference</a></li></ol></li><li class="chapter-item expanded "><a href="static_typing/user_defined_types/recursive_types/recursive_types.generated_docs.html"><strong aria-hidden="true">4.5.2.</strong> Recursive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static_typing/user_defined_types/recursive_types/impossible_recursive_types/impossible_recursive_types.generated_docs.html"><strong aria-hidden="true">4.5.2.1.</strong> Impossible Recursive Types</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="type_inference/type_inference.generated_docs.html"><strong aria-hidden="true">5.</strong> Type Inference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type_inference/required_type_annotations/required_type_annotations.generated_docs.html"><strong aria-hidden="true">5.1.</strong> Required Type Annotations</a></li></ol></li><li class="chapter-item expanded "><a href="procedures.html"><strong aria-hidden="true">6.</strong> Procedures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="procedures/functions/functions.generated_docs.html"><strong aria-hidden="true">6.1.</strong> Functions</a></li><li class="chapter-item expanded "><a href="procedures/consumers/consumers.generated_docs.html"><strong aria-hidden="true">6.2.</strong> Consumers</a></li><li class="chapter-item expanded "><a href="procedures/providers/providers.generated_docs.html"><strong aria-hidden="true">6.3.</strong> Providers</a></li></ol></li><li class="chapter-item expanded "><a href="lambdas_and_first_class_procedures/lambdas_and_first_class_procedures.generated_docs.html"><strong aria-hidden="true">7.</strong> Lambdas & First Class Procedures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lambdas_and_first_class_procedures/lambda_closures/lambda_closures.generated_docs.html"><strong aria-hidden="true">7.1.</strong> Lambdas are Restricted "Closures"</a></li></ol></li><li class="chapter-item expanded "><a href="error_handling/error_handling.generated_docs.html"><strong aria-hidden="true">8.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error_handling/error_propagation/error_propagation.generated_docs.html"><strong aria-hidden="true">8.1.</strong> Error Propagation</a></li></ol></li><li class="chapter-item expanded "><a href="generics.generated_docs.html"><strong aria-hidden="true">9.</strong> Generics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/contracts/contracts.generated_docs.html"><strong aria-hidden="true">9.1.</strong> Contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/contracts/implementing_contracts/implementing_contracts.generated_docs.html"><strong aria-hidden="true">9.1.1.</strong> Implementing a Contract</a></li><li class="chapter-item expanded "><a href="generics/contracts/multiple_type_params/multiple_type_params.generated_docs.html"><strong aria-hidden="true">9.1.2.</strong> Multiple Type Params</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/contracts/multiple_type_params/implied_types/implied_types.generated_docs.html"><strong aria-hidden="true">9.1.2.1.</strong> (Advanced) Implied Types</a></li></ol></li><li class="chapter-item expanded "><a href="generics/contracts/dynamic_dispatch/dynamic_dispatch.generated_docs.html"><strong aria-hidden="true">9.1.3.</strong> Dynamic Dispatch</a></li></ol></li><li class="chapter-item expanded "><a href="generics/generic_return_type_inference/generic_return_type_inference.generated_docs.html"><strong aria-hidden="true">9.2.</strong> Generic Return Type Inference</a></li></ol></li><li class="chapter-item expanded "><a href="copying/copying.generated_docs.html"><strong aria-hidden="true">10.</strong> Copying Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="copying/mutability_coercion/mutability_coercion.generated_docs.html"><strong aria-hidden="true">10.1.</strong> Mutability Coercion on Copy</a></li><li class="chapter-item expanded "><a href="copying/performance/performance.generated_docs.html"><strong aria-hidden="true">10.2.</strong> Performance Optimizations</a></li><li class="chapter-item expanded "><a href="copying/known_bugs/known_bugs.generated_docs.html"><strong aria-hidden="true">10.3.</strong> Known Copy Bugs</a></li></ol></li><li class="chapter-item expanded "><a href="resource_files/resource_files.generated_docs.html"><strong aria-hidden="true">11.</strong> Resource Files</a></li><li class="chapter-item expanded "><a href="module_system/module_system.generated_docs.html"><strong aria-hidden="true">12.</strong> Module System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="module_system/module_apis/module_apis.generated_docs.html"><strong aria-hidden="true">12.1.</strong> Module APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="module_system/module_apis/procedure_signatures/procedure_signatures.generated_docs.html"><strong aria-hidden="true">12.1.1.</strong> Procedure Signatures</a></li><li class="chapter-item expanded "><a href="module_system/module_apis/type_definitions/type_definitions.generated_docs.html"><strong aria-hidden="true">12.1.2.</strong> Type & Alias Definitions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="module_system/module_apis/type_definitions/initializers_and_unwrappers/initializers_and_unwrappers.generated_docs.html"><strong aria-hidden="true">12.1.2.1.</strong> Initializers</a></li><li class="chapter-item expanded "><a href="module_system/module_apis/type_definitions/initializers_and_unwrappers/unwrappers/unwrappers.generated_docs.html"><strong aria-hidden="true">12.1.2.2.</strong> Unwrappers</a></li><li class="chapter-item expanded "><a href="module_system/module_apis/type_definitions/opaque_types/opaque_types.generated_docs.html"><strong aria-hidden="true">12.1.2.3.</strong> Opaque Types</a></li></ol></li><li class="chapter-item expanded "><a href="module_system/module_apis/static_values/static_values.generated_docs.html"><strong aria-hidden="true">12.1.3.</strong> Static Values</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="module_system/module_apis/flags/flags.generated_docs.html"><strong aria-hidden="true">12.1.3.1.</strong> Flags</a></li></ol></li><li class="chapter-item expanded "><a href="module_system/module_apis/http_services/http_services.generated_docs.html"><strong aria-hidden="true">12.1.4.</strong> HTTP Services</a></li></ol></li><li class="chapter-item expanded "><a href="module_system/visibility/visibility.generated_docs.html"><strong aria-hidden="true">12.2.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="module_system/swapping_deps/swapping_deps.generated_docs.html"><strong aria-hidden="true">12.3.</strong> Swapping Dependencies</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">13.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph_procedures/graph_procedures.generated_docs.html"><strong aria-hidden="true">13.1.</strong> Graph Procedures</a></li><li class="chapter-item expanded "><a href="graph_procedures/graph_procedure_composition/graph_procedure_composition.generated_docs.html"><strong aria-hidden="true">13.2.</strong> Graph Procedure Composition</a></li><li class="chapter-item expanded "><a href="graph_procedures/calling_graph_procedures/calling_graph_procedures.generated_docs.html"><strong aria-hidden="true">13.3.</strong> Calling Graph Procedures</a></li><li class="chapter-item expanded "><a href="graph_procedures/conditional_subgraph_execution/conditional_subgraph_execution.generated_docs.html"><strong aria-hidden="true">13.4.</strong> (Advanced) Conditional Subgraph Execution</a></li></ol></li><li class="chapter-item expanded "><a href="fearless_concurrency/fearless_concurrency.html"><strong aria-hidden="true">14.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guaranteed_data_race_free/guaranteed_data_race_free.generated_docs.html"><strong aria-hidden="true">14.1.</strong> Guaranteed Data-Race-Free Concurrency</a></li><li class="chapter-item expanded "><a href="guaranteed_deadlock_free.html"><strong aria-hidden="true">14.2.</strong> Guaranteed Deadlock-Free Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guaranteed_deadlock_free/blocking_procedures/blocking_procedures.generated_docs.html"><strong aria-hidden="true">14.2.1.</strong> Blocking Procedures</a></li><li class="chapter-item expanded "><a href="guaranteed_deadlock_free/re_what_color_is_your_function.generated_docs.html"><strong aria-hidden="true">14.2.2.</strong> Re: "What Color is Your Function?"</a></li><li class="chapter-item expanded "><a href="guaranteed_deadlock_free/re_what_color_is_your_function/blocking_generics.generated_docs.html"><strong aria-hidden="true">14.2.3.</strong> (Advanced) Blocking Generics</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="http_servers/http_servers.generated_docs.html"><strong aria-hidden="true">15.</strong> Basic HTTP Servers</a></li><li class="chapter-item expanded "><a href="json_parsing/json_parsing.generated_docs.html"><strong aria-hidden="true">16.</strong> JSON Parsing</a></li><li class="chapter-item expanded "><a href="metaprogramming/metaprogramming.generated_docs.html"><strong aria-hidden="true">17.</strong> Build Time Metaprogramming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="metaprogramming/templating/templating.generated_docs.html"><strong aria-hidden="true">17.1.</strong> Source Code Templates</a></li><li class="chapter-item expanded "><a href="metaprogramming/code_reuse/code_reuse.generated_docs.html"><strong aria-hidden="true">17.2.</strong> (Literal) Code Reuse</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="metaprogramming/code_reuse/reusing_module_apis/reusing_module_apis.generated_docs.html"><strong aria-hidden="true">17.2.1.</strong> Reusing Module APIs</a></li><li class="chapter-item expanded "><a href="metaprogramming/code_reuse/reusing_source_code/reusing_source_code.generated_docs.html"><strong aria-hidden="true">17.2.2.</strong> Reusing Source Code</a></li><li class="chapter-item expanded "><a href="metaprogramming/code_reuse/abstract_modules/abstract_modules.generated_docs.html"><strong aria-hidden="true">17.2.3.</strong> Abstract Modules</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">StdLib</li><li class="chapter-item expanded "><a href="stdlib/default_modules/default_modules.generated_docs.html"><strong aria-hidden="true">18.</strong> Default Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stdlib/booleans_module.generated_docs.html"><strong aria-hidden="true">18.1.</strong> booleans</a></li><li class="chapter-item expanded "><a href="stdlib/deque_module.generated_docs.html"><strong aria-hidden="true">18.2.</strong> deque</a></li><li class="chapter-item expanded "><a href="stdlib/doubles_module.generated_docs.html"><strong aria-hidden="true">18.3.</strong> doubles</a></li><li class="chapter-item expanded "><a href="stdlib/files_module.generated_docs.html"><strong aria-hidden="true">18.4.</strong> files</a></li><li class="chapter-item expanded "><a href="stdlib/floats_module.generated_docs.html"><strong aria-hidden="true">18.5.</strong> floats</a></li><li class="chapter-item expanded "><a href="stdlib/futures_module.generated_docs.html"><strong aria-hidden="true">18.6.</strong> futures</a></li><li class="chapter-item expanded "><a href="stdlib/fp_module.generated_docs.html"><strong aria-hidden="true">18.7.</strong> fp</a></li><li class="chapter-item expanded "><a href="stdlib/ints_module.generated_docs.html"><strong aria-hidden="true">18.8.</strong> ints</a></li><li class="chapter-item expanded "><a href="stdlib/lists_module.generated_docs.html"><strong aria-hidden="true">18.9.</strong> lists</a></li><li class="chapter-item expanded "><a href="stdlib/longs_module.generated_docs.html"><strong aria-hidden="true">18.10.</strong> longs</a></li><li class="chapter-item expanded "><a href="stdlib/maps_module.generated_docs.html"><strong aria-hidden="true">18.11.</strong> maps</a></li><li class="chapter-item expanded "><a href="stdlib/math_module.generated_docs.html"><strong aria-hidden="true">18.12.</strong> math</a></li><li class="chapter-item expanded "><a href="stdlib/priority_queue_module.generated_docs.html"><strong aria-hidden="true">18.13.</strong> priority_queue</a></li><li class="chapter-item expanded "><a href="stdlib/random_module.generated_docs.html"><strong aria-hidden="true">18.14.</strong> random</a></li><li class="chapter-item expanded "><a href="stdlib/scanner_module.generated_docs.html"><strong aria-hidden="true">18.15.</strong> scanner</a></li><li class="chapter-item expanded "><a href="stdlib/sets_module.generated_docs.html"><strong aria-hidden="true">18.16.</strong> sets</a></li><li class="chapter-item expanded "><a href="stdlib/std_module.generated_docs.html"><strong aria-hidden="true">18.17.</strong> std</a></li><li class="chapter-item expanded "><a href="stdlib/strings_module.generated_docs.html"><strong aria-hidden="true">18.18.</strong> strings</a></li><li class="chapter-item expanded "><a href="stdlib/string_builder_module.generated_docs.html"><strong aria-hidden="true">18.19.</strong> string_builder</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Claro Programming Language (DRAFT)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/JasonSteving99/claro-lang/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-claro"><a class="header" href="#welcome-to-claro">Welcome to Claro!</a></h1>
<img id="claro-logo" width=300 src="./images/ClaroLogoFromArrivalHeptapodOfferWeapon-transparentBackground.png">
<h2 id="claro-is-a-statically-typed-jvm-language-that-provides-a-well-lit-path-to-building-simple-highly-concurrent-and-scalable-applications"><a class="header" href="#claro-is-a-statically-typed-jvm-language-that-provides-a-well-lit-path-to-building-simple-highly-concurrent-and-scalable-applications">Claro is a statically typed JVM language that provides a well-lit path to building simple, highly concurrent, and scalable applications.</a></h2>
<h2 id="dependency-management-done-right"><a class="header" href="#dependency-management-done-right">Dependency Management Done Right</a></h2>
<hr />
<p>Claro was designed with modern build tooling in mind:</p>
<ul>
<li>Swap any dependency without changing a single line of source code</li>
<li>Runtime &quot;Dependency Injection&quot; frameworks are a thing of the past</li>
<li>First class <a href="module_system/module_system.generated_docs.html">Module system</a></li>
</ul>
<h2 id="fearless-concurrency"><a class="header" href="#fearless-concurrency">Fearless Concurrency</a></h2>
<hr />
<p>Developed by a Xoogler taking inspiration from years of hands-on development experience with Google-internal backend web
frameworks, Claro moves well beyond async/await. Claroâ€™s declarative, DAG-based structured concurrency model provides an
easy-to-use abstraction to statically guarantee that programs are:</p>
<ul>
<li>Non-blocking</li>
<li><a href="./guaranteed_data_race_free/guaranteed_data_race_free.generated_docs.html">Data-race free</a></li>
<li><a href="./guaranteed_deadlock_free.html">Deadlock free</a></li>
<li><a href="./graph_procedures/graph_procedures.generated_docs.html">Optimally scheduled</a></li>
<li>Scalable by default</li>
</ul>
<h2 id="data-oriented"><a class="header" href="#data-oriented">Data Oriented</a></h2>
<hr />
<ul>
<li>Strict separation between data and functionality</li>
<li><a href="static_typing/builtin_colls/builtin_collections.generated_docs.html#mutability">Mutability</a> tracked at the type system level</li>
<li>Extremely flexible built in algebraic data types</li>
<li>Model arbitrary data structures with <a href="static_typing/builtin_colls/builtin_collections.generated_docs.html#ad-hoc-declarations">zero boilerplate</a></li>
</ul>
<h2 id="unapologetically-practical"><a class="header" href="#unapologetically-practical">Unapologetically Practical</a></h2>
<hr />
<ul>
<li><a href="type_inference/type_inference.generated_docs.html">Bi-directional type inference</a></li>
<li>Robust <a href="stdlib/default_modules/default_modules.generated_docs.html">standard library</a></li>
<li>Builtin external package manager</li>
<li><a href="metaprogramming/metaprogramming.generated_docs.html">Build time metaprogramming</a></li>
</ul>
<h2 id="designed-to-scale-with-you"><a class="header" href="#designed-to-scale-with-you">Designed to Scale with You</a></h2>
<hr />
<ul>
<li>Incremental compilation out of the box</li>
<li>Code reuse made simple</li>
<li>Develop codebases of any size without devolving into a spaghetti labyrinth</li>
</ul>
<h2 id="actively-in-development"><a class="header" href="#actively-in-development">Actively In Development</a></h2>
<hr />
<div class="warning">
<p><strong>Claro is in active development and is not yet ready for production use</strong>. While Claro has been in active development 
for more than 3 years, its design and implementation has been done entirely by its single maintainer, 
<a href="https://www.linkedin.com/in/jasonsteving/" target="_blank">Jason Steving</a> - while the foundation has been 
laid, contributions are welcome! Anyone with interest is actively encouraged to reach out and get involved!</p>
</div><div style="break-before: page; page-break-before: always;"></div><p>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<h4 id="fig-1"><a class="header" href="#fig-1"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">print(&quot;Hello, world!&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Hello, world!
</code></pre>
<hr />
<p>As you can already see from the most minimal program possible, Claro programs eliminate unnecessary boilerplate. Every
Claro program is simply a sequence of statements that are executed from top-to-bottom as if it were a &quot;script&quot;. You
don't need to specify a &quot;main&quot; method&quot; as in other languages like Java, instead, much like Python, you simply specify a
starting file which will execute top-down at program start.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-your-first-claro-project-with-bazel"><a class="header" href="#create-your-first-claro-project-with-bazel">Create Your First Claro Project with Bazel!</a></h1>
<p>Claro is fundamentally designed around a deep integration with the extremely powerful 
<a href="https://bazel.build/" target="_blank">Bazel</a> build system - which enables Claro's 
<a href="https://bazel.build/run/build#correct-incremental-rebuilds" target="_blank">incremental builds</a>,
<a href="https://bazel.build/external/overview#bzlmod" target="_blank">external package management</a>, extremely 
flexible module system, and build-time metaprogramming capabilities - so you'll need to do a bit of Bazel-related setup 
to prepare your Claro project. </p>
<p><strong>You'll only need to do this once</strong>! Bazel does not mandate monorepo style development, but it really shines when used
in that context. From this single Bazel project, you'll be able to write, build, and run whatever (related or unrelated)
Claro programs as you see fit.</p>
<p>Follow the below steps to set up your first Claro project with Bazel! </p>
<h3 id="1---install-bazel-required"><a class="header" href="#1---install-bazel-required">1 - Install Bazel (Required)</a></h3>
<p>Simply install Bazel - follow <a href="https://bazel.build/install/bazelisk" target="_blank">these instructions</a> 
to install via Bazelisk.</p>
<div class="warning">
Important: Installing Bazel via Bazelisk makes managing Bazel versions an automated process. It's highly recommended you
don't bother managing Bazel's versioning manually.</div>
<p><em>Note: It's an explicit non-goal of Claro to support any other non-Bazel build environment</em>.</p>
<h3 id="2---auto-generate-your-project"><a class="header" href="#2---auto-generate-your-project">2 - Auto-Generate Your Project</a></h3>
<p>Get <code>create_claro_project.sh</code> from the 
<a href="https://github.com/JasonSteving99/claro-lang/releases/latest" target="_blank">latest Release</a> 
and run this command:</p>
<pre><code>$ ./create_claro_project.sh &lt;project name&gt;
</code></pre>
<p><em>Note: The below recording was made with <a href="https://asciinema.org/" target="_blank">asciinema</a> - try pausing 
and copying any text.</em></p>
<script async id="asciicast-630055" src="https://asciinema.org/a/630055.js" data-preload="true"></script>
<div class="warning">
The first time you build/run a Claro program, you will actually be building the Claro compiler and its dependencies from
source. This may take several minutes the first time, but Bazel will cache the built compiler after that first build.
</div>
<p>You can delete the <code>create_claro_project.sh</code> script once you're done with this initial setup.</p>
<h3 id="2-alternative---manually-copy-configuration-of-example-project"><a class="header" href="#2-alternative---manually-copy-configuration-of-example-project">2 (Alternative) - Manually Copy Configuration of Example Project</a></h3>
<p>Follow the example Claro project configuration at
<a href="https://github.com/JasonSteving99/claro-lang/tree/main/examples/bzlmod" target="_blank">examples/bzlmod/</a>.</p>
<div class="warning">
Important: In your MODULE.bazel file, you'll want to choose the latest release published to:
<a href="https://registry.bazel.build/modules/claro-lang" target="_blank">https://registry.bazel.build/modules/claro-lang</a>
</div>
<h2 id="supported-operating-systems"><a class="header" href="#supported-operating-systems">Supported Operating Systems</a></h2>
<p>As Claro is still firmly in development, <strong>it has only been tested on macOS</strong>. You may run into trouble running it on 
another OS as there are some known portability issues building the Claro compiler from source (currently the only 
supported way to consume the compiler). </p>
<h2 id="your-first-claro-program"><a class="header" href="#your-first-claro-program">Your First Claro Program</a></h2>
<p>Continue on to the next section to learn how to build and run your first Claro program!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-the-starter-project"><a class="header" href="#understanding-the-starter-project">Understanding the Starter Project</a></h1>
<p>The <code>create_claro_project.sh</code> script generated several files: </p>
<h4 id="fig-1-1"><a class="header" href="#fig-1-1"><em>Fig 1:</em></a></h4>
<hr />
<pre><code>demo
|-- .bazelrc
|-- .bazelversion
|-- MODULE.bazel
|-- README.md
`-- example
    |-- BUILD
    |-- demo.claro
    `-- input.txt

1 directory, 7 files
</code></pre>
<hr />
<p>Let's take a brief tour through each file to get a high level understanding of what's going on.</p>
<p><em>If you're already familiar with Bazel, jump ahead to writing your 
<a href="getting_started/understanding_starter_project/../first_program/first_program.tmpl.html">first Claro program</a>.</em></p>
<div class="warning">
<i>You do not need to be a Bazel expert to get up to speed with Claro! But, if you want a deeper understanding of Bazel as
a whole, check out Bazel's official 
<a href="https://bazel.build/concepts/build-ref" target="_blank">concepts guide</a>.</i>
</div>
<h2 id="modulebazel"><a class="header" href="#modulebazel">MODULE.bazel</a></h2>
<p><em>See: <a href="https://bazel.build/rules/lib/globals/module" target="_blank">Official Bazel reference</a></em> - This file 
marks the root of your Bazel project.</p>
<h4 id="fig-2"><a class="header" href="#fig-2"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">module(name = &quot;example-claro-module&quot;)

bazel_dep(name = &quot;claro-lang&quot;, version = &quot;0.1.509&quot;)
</code></pre>
<hr />
<h3 id="modulename--example-claro-module"><a class="header" href="#modulename--example-claro-module"><code>module(name = &quot;example-claro-module&quot;)</code></a></h3>
<p>This is the one place where you'll see the term &quot;module&quot; overloaded to refer to Bazel's concept of 
<a href="https://bazel.build/external/module" target="_blank">Modules</a> relating to Bazel's external package 
management solution. So, the name you pick for your top-level <code>module(name = &quot;...&quot;)</code> declaration should be something 
that you would be ok with using to publicly present your project to downstream users if you chose to publish your 
project to the <a href="https://registry.bazel.build/" target="_blank">Bazel Central Registry</a> later on.</p>
<h3 id="bazel_depname--claro-lang-version--01409"><a class="header" href="#bazel_depname--claro-lang-version--01409"><code>bazel_dep(name = &quot;claro-lang&quot;, version = &quot;0.1.409&quot;)</code></a></h3>
<p>This file is where you will declare your external dependencies for Bazel to resolve at build time. Every Claro project 
will need to declare an external dependency on the <code>claro-lang</code> project to get access to the Build Rules (e.g. 
<code>claro_binary()</code> and <code>claro_module()</code>) as well as the compiler itself. Keeping your installation of Claro up-to-date is
as simple as bumping the version number listed here.</p>
<p>Claro has been published to the BCR at
<a href="https://registry.bazel.build/modules/claro-lang" target="_blank">https://registry.bazel.build/modules/claro-lang</a>.
Check for new releases there to make sure that you're using the latest and greatest.</p>
<h2 id="bazelversion"><a class="header" href="#bazelversion">.bazelversion</a></h2>
<p><em>See: <a href="https://github.com/bazelbuild/bazelisk?tab=readme-ov-file#how-does-bazelisk-know-which-bazel-version-to-run" target="_blank">
Official Bazelisk reference</a></em> - This file configures Bazelisk to use the declared Bazel version.</p>
<h4 id="fig-3"><a class="header" href="#fig-3"><em>Fig 3:</em></a></h4>
<hr />
<pre><code>6.4.0
</code></pre>
<hr />
<p>Claro depends on Bzlmod which was introduced in Bazel version 6, so you'll need to use at least version 6.</p>
<h2 id="bazelrc"><a class="header" href="#bazelrc">.bazelrc</a></h2>
<p><em>See: <a href="https://bazel.build/run/bazelrc" target="_blank">Official Bazel reference</a></em> - This file is used to 
configure optional Bazel flags.</p>
<h4 id="fig-4"><a class="header" href="#fig-4"><em>Fig 4:</em></a></h4>
<hr />
<pre><code>common --enable_bzlmod
common --java_runtime_version=remotejdk_11
build --java_language_version=11
build --tool_java_language_version=11
</code></pre>
<hr />
<h3 id="common---enable_bzlmod"><a class="header" href="#common---enable_bzlmod"><code>common --enable_bzlmod</code></a></h3>
<p>This configures Bazel to opt in to enabling the
<a href="https://bazel.build/external/overview#bzlmod" target="_blank">Bzlmod</a>, external package manager. This will 
be necessary in all Claro projects to at least enable Bazel to resolve your dependency on the Claro compiler. </p>
<h3 id="common---java_runtime_versionremotejdk_11"><a class="header" href="#common---java_runtime_versionremotejdk_11"><code>common --java_runtime_version=remotejdk_11</code></a></h3>
<p>This configures Bazel to download a remote version of the JVM to execute compiled Claro programs. Technically, you can
<a href="https://bazel.build/docs/bazel-and-java#compile-using-jdk" target="_blank">opt in to using a local Java install</a>,
but keeping this flag as is ensures that you're running a JVM version that Claro's actually been tested against.</p>
<h2 id="build"><a class="header" href="#build">BUILD</a></h2>
<p><em>See: <a href="https://bazel.build/build/style-guide" target="_blank">Official Bazel reference</a></em> - BUILD files are
the fundamental building block of a Bazel project. Here you'll define &quot;build targets&quot; representing components of your
program and their dependencies.</p>
<h4 id="fig-5"><a class="header" href="#fig-5"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_binary&quot;)

claro_binary(
  name = &quot;demo_bin&quot;,
  main_file = &quot;demo.claro&quot;,
  resources = {
    &quot;Input&quot;: &quot;input.txt&quot;,
  }
)
</code></pre>
<hr />
<h3 id="loadclaro-langrulesbzl-claro_binary"><a class="header" href="#loadclaro-langrulesbzl-claro_binary"><code>load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_binary&quot;)</code></a></h3>
<p>This loads (a.k.a. &quot;imports&quot;) the <code>claro_binary()</code> Build Rule from the <code>rules.bzl</code> 
<a href="https://bazel.build/extending/concepts" target="_blank">Bazel extension file</a> located in the root directory
of the <code>claro-lang</code> project. After this <code>load</code>, you're able to define <code>claro_binary()</code> targets in this BUILD file by
calling it just as you would a function in any other programming language (albeit with mandatory named parameters).</p>
<h3 id="claro_binary"><a class="header" href="#claro_binary"><code>claro_binary(...)</code></a></h3>
<p>As mentioned above, this declares a build target that represents an executable Claro program (<code>*_binary()</code> is the
conventional naming of executable build targets in the Bazel ecosystem). </p>
<h4 id="name--demo_bin"><a class="header" href="#name--demo_bin"><code>name = &quot;demo_bin&quot;</code></a></h4>
<p>All Bazel build targets include a mandatory <code>name = &quot;...&quot;</code> parameter - in combination with the full path from the 
project root, this specific build target can be uniquely referenced as <code>//example:demo_bin</code>. Using this name, you can
execute Bazel build/run commands from the command line. </p>
<p>You can <strong>build</strong> the target to have Bazel invoke the Claro compiler to verify that your program is valid and if so 
generate the executable program artifacts that can be invoked separately:</p>
<pre><code>bazel build //example:demo_bin
</code></pre>
<p>During local development you can directly <strong>build and run</strong> the target by using the below command which will trigger
Bazel to build the target and then upon success invoke the built executable program automatically: </p>
<pre><code>bazel run //example:demo_bin
</code></pre>
<h4 id="main_file--democlaro"><a class="header" href="#main_file--democlaro"><code>main_file = &quot;demo.claro&quot;</code></a></h4>
<p>Claro programs begin execution by running top-level statements of a given &quot;main file&quot; top-down, rather than looking for
some special <code>main</code> function.</p>
<h4 id="resources---input-inputtxt-"><a class="header" href="#resources---input-inputtxt-"><code>resources = { &quot;Input&quot;: &quot;input.txt&quot;, }</code></a></h4>
<p>This declares that this program should bundle the file <code>input.txt</code> into the final compiled Jar file so that it's 
available at runtime no matter where the program is run. It makes this resource file available as <code>resources::Input</code> in
the compiled program. Find more details about resources in the Reference Guide.</p>
<h2 id="inputtxt"><a class="header" href="#inputtxt">input.txt</a></h2>
<p>Just a resource file read by the demo program.</p>
<h4 id="fig-6"><a class="header" href="#fig-6"><em>Fig 6:</em></a></h4>
<hr />
<pre><code>
look ma, no hands!
</code></pre>
<hr />
<h2 id="democlaro"><a class="header" href="#democlaro">demo.claro</a></h2>
<p>The main Claro file that contains the code to be executed. </p>
<h4 id="fig-7"><a class="header" href="#fig-7"><em>Fig 7:</em></a></h4>
<hr />
<pre><code class="language-claro">resources::Input
  |&gt; files::readOrPanic(^)
  |&gt; strings::trim(^)
  |&gt; strings::toUpperCase(^)
  |&gt; wrapInBox(^)
  |&gt; print(^);

function wrapInBox(s: string) -&gt; string {
  var line = strings::repeated(&quot;-&quot;, len(s) + 4);
  return &quot;{line}\n| {s} |\n{line}&quot;;
}
</code></pre>
<hr />
<p>This program just reads in the contents of the <a href="getting_started/understanding_starter_project/understanding_starter_project.generated_docs.html#resources---input-inputtxt-"><code>input.txt</code> resource file</a>, trims extra
whitespace, converts it to all caps, wraps it in a box of &quot;-&quot; characters, and prints it to stdout. </p>
<p>Note the calls to functions like <code>files::readOrPanic</code> and <code>strings::trim</code> are calling into functions declared in dep
modules. In this case there's no explicit mention of those dependencies in the <code>claro_binary(...)</code> target declaration
because <code>files</code> and <code>strings</code> are modules in the 
<a href="https://github.com/JasonSteving99/claro-lang/tree/main/stdlib" target="_blank">stdlib</a> so no explicit 
dependency is necessary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-program"><a class="header" href="#your-first-program">Your First Program</a></h1>
<p>Now that you've set up your starter Claro project in the previous section, let's go through the process of implementing 
your first program!</p>
<h2 id="create-hello_worldclaro"><a class="header" href="#create-hello_worldclaro">Create <code>hello_world.claro</code></a></h2>
<h4 id="fig-1-2"><a class="header" href="#fig-1-2"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">print(&quot;Hello, world!&quot;);
</code></pre>
<hr />
<p>Hello World is a one-liner in Claro, so it's a great place to start learning how to declare a new Claro program using
Bazel. Just to keep things simple, copy the above line into a new file at <code>//example/hello_world.claro</code>.</p>
<h4 id="fig-2-1"><a class="header" href="#fig-2-1"><em>Fig 2:</em></a></h4>
<hr />
<pre><code>demo
|-- .bazelrc
|-- .bazelversion
|-- MODULE.bazel
|-- README.md
`-- example
    |-- BUILD
    |-- demo.claro
    |-- hello_world.claro
    `-- input.txt

1 directory, 8 files
</code></pre>
<hr />
<h2 id="declare-a-new-claro_binary-target-in-your-build-file"><a class="header" href="#declare-a-new-claro_binary-target-in-your-build-file">Declare a New <code>claro_binary(...)</code> Target in Your BUILD File</a></h2>
<p>Now, we'll simply add a new build target for our Hello World program to the existing BUILD file that was generated as
part of the starter project.</p>
<h4 id="fig-3-1"><a class="header" href="#fig-3-1"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_binary&quot;)

claro_binary(
  name = &quot;demo_bin&quot;,
  main_file = &quot;demo.claro&quot;,
  resources = {
    &quot;Input&quot;: &quot;input.txt&quot;,
  }
)

claro_binary(
  name = &quot;hello_world&quot;,
  main_file = &quot;hello_world.claro&quot;,
)
</code></pre>
<hr />
<h2 id="now-execute-your-program"><a class="header" href="#now-execute-your-program">Now Execute Your Program!</a></h2>
<p>That's all there is to it! Now you can use the following command to have Bazel build and then run your program:</p>
<p><em>Note: The below recording was made with <a href="https://asciinema.org/" target="_blank">asciinema</a> - try pausing
and copying any text.</em></p>
<script async id="asciicast-bhFOGiVy3oQT07drghvf5Js5o" src="https://asciinema.org/a/bhFOGiVy3oQT07drghvf5Js5o.js" data-preload="true"></script>
<p><strong>Congratulations!</strong> You just wrote and executed your first Claro program entirely from scratch!</p>
<h3 id="avoiding-bazels-extra-output"><a class="header" href="#avoiding-bazels-extra-output">Avoiding Bazel's Extra Output</a></h3>
<p>Notice that when you used <code>bazel run ...</code> to run your executable build target, Bazel produced a bunch of <code>INFO: ...</code>
logs related to the build process. Since the program built successfully, this is something that you can usually just
ignore. However, if this extra noise bothers you, you can make use of Bazel's generated build artifacts to run the 
program directly, without any of Bazel's extra logging. Notice the very last line in Bazel's output:</p>
<pre><code>INFO: Running command line: bazel-bin/example/hello_world
</code></pre>
<p>This is a script that can be directly invoked to run the built executable program locally.</p>
<div class="warning">
This is not a portable executable! <b>Continue reading to learn how to generate a portable executable.</b>
</div>
<p><em>Note: The below recording was made with <a href="https://asciinema.org/" target="_blank">asciinema</a> - try pausing
and copying any text.</em></p>
<script async id="asciicast-630572" src="https://asciinema.org/a/630572.js" data-preload="true" data-start-at="7.0" data-autoplay="false"></script>
<h3 id="generating-a-portable-executable-deploy-jar"><a class="header" href="#generating-a-portable-executable-deploy-jar">Generating a Portable Executable (&quot;Deploy Jar&quot;)</a></h3>
<p>As Claro is a JVM language, you can easily generate a self-contained Jar file that can be run anywhere that a JVM is
installed. Generate the &quot;Deploy Jar&quot; by appending <code>_deploy.jar</code> to the end of any <code>claro_binary()</code> build target, and can
then run it using <code>java -jar ...</code> as you would any executable Jar:</p>
<p><em>Note: The below recording was made with <a href="https://asciinema.org/" target="_blank">asciinema</a> - try pausing
and copying any text.</em></p>
<script async id="asciicast-630573" src="https://asciinema.org/a/630573.js" data-preload="true"></script>
<div class="warning">
<b>Warning</b>: The `java -jar ...` command demonstrated above will make use of your local Java installation. Assuming 
that you've kept the flag `common --java_runtime_version=remotejdk_11` in your .bazelrc as described in the previous 
section, you may have been running Claro programs without even manually installing Java, meaning that this command will 
fail. Generally speaking, you shouldn't worry about this as it's encouraged to use `bazel run ...` during local 
development anyway.
</div>
<div style="break-before: page; page-break-before: always;"></div><p>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="intro-to-modules"><a class="header" href="#intro-to-modules">Intro to Modules</a></h1>
<p>Now, the Hello World program that you wrote in the previous section was extremely simple - just a one-liner in a single
file. Let's add a tiny bit more functionality to your first program as an excuse to learn about Claro's Module System!</p>
<p>Taking inspiration from the starter project's demo program, which printed the following to stdout: </p>
<pre><code>----------------------                                                                                        
| LOOK MA, NO HANDS! |                                                                                        
----------------------  
</code></pre>
<p>we'll extend our <code>hello_world.claro</code> program to also print out the classic greeting in the same boxed styling. We could
of course just copy-paste the demo program's <code>wrapInBox</code> function into <code>hello_world.claro</code>, but instead, in order to 
avoid having multiple implementations of the same function that could drift over time, we'll walk through the process of
refactoring both programs so that each can share a single function implementation as a common dependency.</p>
<h2 id="create-examplestylingclaro"><a class="header" href="#create-examplestylingclaro">Create <code>//example:styling.claro</code></a></h2>
<p>First thing first, create the file <code>//example:styling.claro</code> to hold the <code>wrapInBox</code> function definition:</p>
<h4 id="fig-1-3"><a class="header" href="#fig-1-3"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">function wrapInBox(s: string) -&gt; string {
  var line = strings::repeated(&quot;-&quot;, len(s) + 4);
  return &quot;{line}\n| {s} |\n{line}&quot;;
}
</code></pre>
<hr />
<h2 id="define-a-module-api-file"><a class="header" href="#define-a-module-api-file">Define a Module API File</a></h2>
<p>Claro Modules are extremely flexible by design (we'll only begin to scratch the surface here) and in order to achieve
that flexibility a Module API file is used to declare which definitions are exported to consumers of the Module. Any 
definition not listed in the Module API file is &quot;private&quot; by default. In this case we just have the one function 
definition so we'll add its signature to the new file <code>styling.claro_module_api</code> (the only naming requirement here is 
that it must end with the <code>.claro_module_api</code> suffix).</p>
<h4 id="fig-2-2"><a class="header" href="#fig-2-2"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># Wraps the given string in a &quot;box&quot; of dashes.
# E.g.
#   Input:
#     &quot;Foo&quot;
#   Output:
#     -------
#     | Foo |
#     -------
function wrapInBox(s: string) -&gt; string;
</code></pre>
<hr />
<p>As a general rule of thumb, when working in a Claro project, you should prioritize writing documentation for anything
exported in a Module API file. And when reading code, it's advisable to spend most of your time primarily referencing
Module API files rather than their corresponding source files, unless of course you are curious to understand the 
implementation.</p>
<h4 id="your-project-should-now-have-the-following-structure"><a class="header" href="#your-project-should-now-have-the-following-structure">Your project should now have the following structure:</a></h4>
<h4 id="fig-3-2"><a class="header" href="#fig-3-2"><em>Fig 3:</em></a></h4>
<hr />
<pre><code>demo
|-- .bazelrc
|-- .bazelversion
|-- MODULE.bazel
|-- README.md
`-- example
    |-- BUILD
    |-- demo.claro
    |-- hello_world.claro
    |-- input.txt
    |-- styling.claro
    `-- styling.claro_module_api

1 directory, 10 files
</code></pre>
<hr />
<h2 id="add-a-claro_modulename--styling--build-target"><a class="header" href="#add-a-claro_modulename--styling--build-target">Add a <code>claro_module(name = &quot;styling&quot;, ...)</code> Build Target</a></h2>
<p>The final step in defining a Module in Claro is defining a <code>claro_module(...)</code> build target. Add the following to your
<code>BUILD</code> file to create a Module by declaring explicitly that the <code>styling.claro</code> file implements the interface declared
by <code>styling.claro_module_api</code>:</p>
<h4 id="fig-4-1"><a class="header" href="#fig-4-1"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">load(&quot;//:rules.bzl&quot;, &quot;claro_binary&quot;, &quot;claro_module&quot;)  # &lt;-- New

claro_binary(
  name = &quot;demo_bin&quot;,
  main_file = &quot;demo.claro&quot;,
  resources = {
    &quot;Input&quot;: &quot;input.txt&quot;,
  }
)

claro_binary(
  name = &quot;hello_world&quot;,
  main_file = &quot;hello_world.claro&quot;,
  deps = {                                            # &lt;-- New
    &quot;Style&quot;: &quot;:styling&quot;,
  },
)

claro_module(                                         # &lt;-- New
  name = &quot;styling&quot;,
  module_api_file = &quot;styling.claro_module_api&quot;,
  srcs = [&quot;styling.claro&quot;],
)
</code></pre>
<hr />
<h3 id="updated-load-statement"><a class="header" href="#updated-load-statement">Updated <code>load(...)</code> Statement</a></h3>
<p>The <code>load(...)</code> statement also needed to be updated to include the newly used <code>claro_module</code> Build Rule.</p>
<h3 id="added-an-explicit-dependency-on-examplestyling"><a class="header" href="#added-an-explicit-dependency-on-examplestyling">Added an Explicit Dependency on <code>//example:styling</code></a></h3>
<p>Claro handles dependencies <strong>entirely</strong> within Bazel BUILD files, and <code>.claro</code> source files themselves do not have any
mechanism for the traditional <code>import</code> style that you will have gotten accustomed to in other languages. This is the key
to Claro's extremely flexible Module system and provides many powerful advantages over the traditional <code>import</code> style,
but we won't get any further into that here.</p>
<p>For now, just note that <code>claro_*()</code> Build targets all accept an (optional) <code>deps = {&lt;dep name&gt;: &lt;module target&gt;}</code> map 
that explicitly declares and names any dependencies the current compilation unit has on any other Module. Note that the
consuming compilation unit is <strong>free to choose any name</strong> to refer to the Module(s) that it depends on. Here we've 
chosen to name the <code>//example:styling</code> Module <code>Style</code>.</p>
<h2 id="update-hello_worldclaro-to-use-stylewrapinbox"><a class="header" href="#update-hello_worldclaro-to-use-stylewrapinbox">Update <code>hello_world.claro</code> to Use <code>Style::wrapInBox</code></a></h2>
<p>Now we're finally ready to update our Hello World program to wrap its output in a box using its new module dependency!
Update <code>hello_world.claro</code> to:</p>
<h4 id="fig-5-1"><a class="header" href="#fig-5-1"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">print(Style::wrapInBox(&quot;Hello, World!&quot;));
</code></pre>
<hr />
<h2 id="now-execute-your-updated-hello-world"><a class="header" href="#now-execute-your-updated-hello-world">Now Execute Your Updated Hello World!</a></h2>
<p><em>Note: The below recording was made with <a href="https://asciinema.org/" target="_blank">asciinema</a> - try pausing
and copying any text.</em></p>
<script async id="asciicast-630594" src="https://asciinema.org/a/630594.js" data-preload="true" data-start-at="7" data-autoplay="false"></script>
<h2 id="on-your-own-update-exampledemo_bin-to-use-the-new-module"><a class="header" href="#on-your-own-update-exampledemo_bin-to-use-the-new-module">On Your Own: Update <code>//example:demo_bin</code> to Use the New Module</a></h2>
<p>Using what you've learned, it should now be straightforward to update <code>//example:demo_bin</code> to also depend on the newly
defined Module so that there's only a single definition of the <code>wrapInBox</code> function in your project.</p>
<h2 id="on-your-own-refactor-examplestyling-to-its-own-directory"><a class="header" href="#on-your-own-refactor-examplestyling-to-its-own-directory">On Your Own: Refactor <code>//example:styling</code> to its Own Directory</a></h2>
<p>This will be a good way to test your understanding of how Claro and Bazel work together. </p>
<p><em>Hint: You can move the Module definition anywhere in the project that you want, but you'll need to update the 
<code>deps = {...}</code> declarations to reference its new location.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-programming-concepts"><a class="header" href="#common-programming-concepts">Common Programming Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables--primitive-types"><a class="header" href="#variables--primitive-types">Variables &amp; Primitive Types</a></h1>
<p>Claro is a statically-compiled, strictly typed language. Practically speaking, this means that the type of all variables
must be statically determined upon declaration of the variable, and may never change thereafter.</p>
<p>Claro has several builtin &quot;primitive&quot; types representing generally small or low-level &quot;value types&quot; that are immutable
to the programmer. They are referred to as &quot;primitive&quot; because they are foundational to the language's type system, and
make up the basic building blocks of which every other type in the language is just some structured combination. Values
of these primitive types are generally cheap to allocate on the stack, and are passed as copies to other functions
(strings, being handled in typical JVM fashion, are actually heap allocated with references to strings passed instead of
copying the value itself).</p>
<p>The supported set of primitives are: int, long, float, double, boolean, string, char. The example below shows how you'd
define variables to represent values of each type:</p>
<h4 id="fig-1-4"><a class="header" href="#fig-1-4"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var i: int = 10; # Any whole number from -2^31 to 2^31-1.
var l: long = 10L; # Any whole number from -2^63 to 2^63-1.
var f: float = 1.15F; # A single-precision 32-bit IEEE 754 floating point number.
var d: double = 1.15; # A double-precision 64-bit IEEE 754 floating point number.
var b: boolean = true; # true or false.
var s: string = &quot;very first string&quot;; # An immutable sequence of chars. Heap allocated.
var c: char = 'a'; # A single 16-bit Unicode character.
</code></pre>
<hr />
<p>To break the syntax down further:</p>
<p><code>var</code> : Keyword introducing / declaring a new variable.</p>
<p><code>b</code> : the name we chose for this particular var.</p>
<p><code>:</code> : a syntactic divider between a variable's name and its type.</p>
<p><code>boolean</code> : the type of the variable, which constrains the domain of values which this variable may hold. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="separate-variable-declaration--initialization"><a class="header" href="#separate-variable-declaration--initialization">Separate Variable Declaration &amp; Initialization</a></h1>
<p>The previous example demonstrates the simultaneous declaration and initialization of a new variable and its initial
value. It is also possible to delay initialization to happen independently of declaration.</p>
<h4 id="fig-1-5"><a class="header" href="#fig-1-5"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var i: int;
i = 10;
</code></pre>
<hr />
<p>(Note: this is particularly useful when you may want to initialize to different values in different branches of an
if-else chain for example.)</p>
<div style="break-before: page; page-break-before: always;"></div><p>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="variable-reassignment"><a class="header" href="#variable-reassignment">Variable Reassignment</a></h1>
<p>By definition, the value represented by a variable may vary, or change, over time throughout the program:</p>
<h4 id="fig-1-6"><a class="header" href="#fig-1-6"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var s: string = &quot;Hello&quot;;
print(s);

s = &quot;goodbye&quot;;
print(s);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Hello
goodbye
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-formatting"><a class="header" href="#string-formatting">String Formatting</a></h1>
<p>Formatting strings is an incredibly common programming task, whether it be for the sake of debugging or for building 
full-fledged CLI programs. Claro attempts to simplify this process by providing syntax sugar for directly templating
arbitrary expressions directly into a string. </p>
<div class="warning">
<p><strong>Note</strong>: At the moment, Claro only supports single-line strings, but multi-line strings are planned. Stay tuned for 
this in a future release.</p>
</div>
<p>To take advantage of this, any expression can be formatted into a string by wrapping it in <code>{...}</code>.</p>
<h4 id="fig-1-7"><a class="header" href="#fig-1-7"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var s = &quot;!EXAMPLE!&quot;;
print(&quot;prefix---{s}--suffix&quot;);

provider foo() -&gt; string {
  return &quot;WOW!&quot;;
}

# Formatted expressions really are arbitrary expressions, you can even call
# arbitrary procedures from them.
print(&quot;prefix---{foo()}---suffix&quot;);

# Format strings can even be nested, though you should probably have a good
# reason for doing this.
print(&quot;prefix---{&quot;inner+++{s}+++inner&quot;}---suffix&quot;);

# You can also use multiple fmt arg expressions!
print(&quot;Name:\t{getRandomName()}\nAge:\t{random::nextNonNegativeBoundedInt(random::forSeed(1), 20)}&quot;);

provider getRandomName() -&gt; string {
  # ...
<span class="boring">  var names = [&quot;Milo&quot;, &quot;Millie&quot;, &quot;Ruby&quot;];
</span><span class="boring">
</span><span class="boring">  random::forSeed(2)
</span><span class="boring">    |&gt; random::nextNonNegativeBoundedInt(^, 3)
</span><span class="boring">    |&gt; var ind = ^;
</span><span class="boring">
</span><span class="boring">  return names[ind];
</span>}
</code></pre>
<p><em>Output:</em></p>
<pre><code>prefix---!EXAMPLE!--suffix
prefix---WOW!---suffix
prefix---inner+++!EXAMPLE!+++inner---suffix
Name:	Millie
Age:	5
</code></pre>
<hr />
<h2 id="escaping-curly-braces-in-strings"><a class="header" href="#escaping-curly-braces-in-strings">Escaping Curly-Braces in Strings</a></h2>
<p>While Format Strings are very convenient, this does have the consequence of giving curly-braces a special significance
in string literals. So, to type a string literal that contains the <code>{</code> char, you must escape it using <code>\{</code>, for example:</p>
<h4 id="fig-2-3"><a class="header" href="#fig-2-3"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">print(&quot;This string has \{literal \{curlies} in it}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>This string has {literal {curlies} in it}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Claro has only a few control flow structures at the current moment. These structures allow programs to execute code
both conditionally and repeatedly. The only thing to keep an eye on, coming from a dynamic language like Python, is that
Claro will statically validate that do not misuse conditional execution to run code that may attempt to use a variable
before initialization. The examples in the following sections will also demonstrate invalid code that Claro throw a
compile-time error on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-else"><a class="header" href="#if-else">If-Else</a></h1>
<h4 id="fig-1-8"><a class="header" href="#fig-1-8"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var rng = random::forSeed(1);
var r = random::nextNonNegativeBoundedInt(rng, 100);

var s: string;
if (r &lt; 33) { # Curly braces are mandatory.
    s = &quot;small&quot;;
} else if (r &lt; 66) {
    s = &quot;medium&quot;;
} else {
    s = &quot;large&quot;;
}

print(s); # Prints &quot;small&quot;, &quot;medium&quot;, or &quot;large&quot;.
</code></pre>
<p><em>Output:</em></p>
<pre><code>large
</code></pre>
<hr />
<div class="warning">
Possible use of an uninitialized variable is a compile-time error:
</div>
<h4 id="fig-2-4"><a class="header" href="#fig-2-4"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var rng = random::forSeed(1);
var r = random::nextNonNegativeBoundedInt(rng, 100);

var s: string;
if (r &lt; 33) {
    s = &quot;red&quot;;
} else if (r &lt; 66) {
    s = &quot;green&quot;;
}

print(s); # `s` is uninitialized if r &gt;= 66.
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">if_else_EX2_example.claro:11: Variable &lt;s&gt; may not have been initialized!
print(s); # `s` is uninitialized if r &gt;= 66.
      ^
Warning! The following declared symbols are unused! [s]
2 Errors
</code></pre>
<hr />
<p><em>Note: Claro's error messaging is a work in progress - the above error message will be improved.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h1>
<h4 id="fig-1-9"><a class="header" href="#fig-1-9"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var i = 0;
while (i &lt; 10) {
    print(i++);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
0
1
2
3
4
5
6
7
8
9
</code></pre>
<hr />
<div class="warning">
Possible use of an uninitialized variable is a compile-time error:
</div>
<h4 id="fig-4-2"><a class="header" href="#fig-4-2"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">var s: string;
while (input(&quot;Should `s` be initialized? (Y/n)&quot;) == &quot;Y&quot;) {
    s = input(&quot;Enter the value for `s`:&quot;);
}
print(s);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">while_EX4_example.claro:5: Variable &lt;s&gt; may not have been initialized!
print(s);
      ^
Warning! The following declared symbols are unused! [s]
2 Errors
</code></pre>
<hr />
<h2 id="exiting-a-while-loop-early"><a class="header" href="#exiting-a-while-loop-early">Exiting a While Loop Early</a></h2>
<p>You can exit a loop early by using the <code>break</code> keyword as below.</p>
<h4 id="fig-2-5"><a class="header" href="#fig-2-5"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var i = 0;
while (i &lt; 10) {
    if (i == 5) {
      break;
    }
    print(i++);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>0
1
2
3
4
</code></pre>
<hr />
<h2 id="skipping-to-the-next-iteration-of-the-while-loop"><a class="header" href="#skipping-to-the-next-iteration-of-the-while-loop">Skipping to the Next Iteration of the While Loop</a></h2>
<p>You can also skip ahead to the loop's next iteration by using the 'continue' keyword as below.</p>
<h4 id="fig-3-3"><a class="header" href="#fig-3-3"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var i = 0;
while (i &lt; 10) {
    if (i % 2 == 0) {
      ++i;
      continue;
    }
    print(i++);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>1
3
5
7
9
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h1>
<p>For loops in Claro are closely analogous to Java's 
<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html#:~:text=the%20enhanced%20for%20to%20loop">&quot;enhanced for-loops&quot;</a>.
They enable you to easily iterate over the elements of a collection.</p>
<h2 id="for-loop-over-lists"><a class="header" href="#for-loop-over-lists">For Loop Over Lists</a></h2>
<h4 id="fig-1-10"><a class="header" href="#fig-1-10"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">for (e in [1, 2, 3, 4, 5]) {
    print(e);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>1
2
3
4
5
</code></pre>
<hr />
<h2 id="for-loop-over-sets"><a class="header" href="#for-loop-over-sets">For Loop Over Sets</a></h2>
<h4 id="fig-2-6"><a class="header" href="#fig-2-6"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">for (e in {1, 2, 3}) {
  print(e);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
1
2
3
</code></pre>
<hr />
<h2 id="for-loop-over-maps"><a class="header" href="#for-loop-over-maps">For Loop Over Maps</a></h2>
<p>Iterating over the elements of a map of type <code>{K: V}</code> using the for-loop construct will yield a loop variable whose type
is <code>tuple&lt;K, V&gt;</code>:</p>
<h4 id="fig-3-4"><a class="header" href="#fig-3-4"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">for (e in {'a': 1, 'b': 2, 'c': 3}) {
  print(&quot;Key: {e[0]} - Val: {e[1]}&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
Key: a - Val: 1
Key: b - Val: 2
Key: c - Val: 3
</code></pre>
<hr />
<h3 id="note-1"><a class="header" href="#note-1"><em>Note 1</em>:</a></h3>
<div class="warning">
For loops over tuples are not currently supported as it's unclear what the appropriate behavior would be iterating over
a collection of heterogeneous types. It's possible that in the future support may be added for a loop variable whose
type is oneof<...all unique types in the tuple...> but there are no current plans for prioritizing this.
</div>
<h3 id="note-2"><a class="header" href="#note-2"><em>Note 2</em>:</a></h3>
<div class="warning">
Possible use of an uninitialized variable is a compile-time error:
</div>
<h4 id="fig-4-3"><a class="header" href="#fig-4-3"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">random::create()
</span><span class="boring">  |&gt; random::nextNonNegativeBoundedInt(^, 10)
</span><span class="boring">  |&gt; var r = ^;
</span><span class="boring">var l: mut [int] = mut [];
</span><span class="boring">while (r-- &gt; 0) {
</span><span class="boring">  lists::add(l, r);
</span><span class="boring">}
</span><span class="boring">
</span>var s: int;
for (elem in l) {  # &lt;-- `l` could be empty.
    s = elem;
}
print(s);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">for_EX4_example.claro:13: Variable &lt;s&gt; may not have been initialized!
print(s);
      ^
Warning! The following declared symbols are unused! [s]
2 Errors
</code></pre>
<hr />
<h2 id="exiting-a-for-loop-early"><a class="header" href="#exiting-a-for-loop-early">Exiting a For Loop Early</a></h2>
<p>You can exit a loop early by using the <code>break</code> keyword as below.</p>
<h4 id="fig-5-2"><a class="header" href="#fig-5-2"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">for (e in [1, 2, 3, 4, 5]) {
    if (e == 3) {
      break;
    }
    print(e);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
1
2
</code></pre>
<hr />
<h2 id="skipping-to-the-next-iteration-of-the-for-loop"><a class="header" href="#skipping-to-the-next-iteration-of-the-for-loop">Skipping to the Next Iteration of the For Loop</a></h2>
<p>You can also skip ahead to the loop's next iteration by using the 'continue' keyword as below.</p>
<h4 id="fig-6-1"><a class="header" href="#fig-6-1"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro">for (e in [1, 2, 3, 4, 5]) {
    if (e % 2 == 0) {
      continue;
    }
    print(e);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>1
3
5
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="repeat-loops"><a class="header" href="#repeat-loops">Repeat Loops</a></h1>
<p>Repeat loops in Claro enable you to easily repeat a task some number of times:</p>
<h4 id="fig-1-11"><a class="header" href="#fig-1-11"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">repeat (5) {
    print(&quot;Repeating...&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>Repeating...
Repeating...
Repeating...
Repeating...
Repeating...
</code></pre>
<hr />
<p>The loop count can be computed at runtime:</p>
<h4 id="fig-2-7"><a class="header" href="#fig-2-7"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var loopCount = random::nextNonNegativeBoundedInt(random::create(), 10);

repeat (loopCount) {
    print(&quot;Repeating...&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>Repeating...
Repeating...
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipes"><a class="header" href="#pipes">Pipes</a></h1>
<p>Piping is a control flow mechanism that is not common to all languages, but is truly just syntactic sugar (one of the
few pure-sugar features in the language). Piping gives you a mechanism to decompose deeply nested function calls into a
linear chain of operations that happen one after the other much like any other imperative code you're familiar with. The
main thing to know is that on each line beginning with the &quot;pipe&quot; operator <code>|&gt;</code>, the token <code>^</code> (known as the
&quot;backreference&quot; operator) refers to the value of the expression before the pipe operator. It is intended that the <code>^</code>
operator, visually resembles an arrow pointing upwards to the value produced on the line above.</p>
<h4 id="fig-1-12"><a class="header" href="#fig-1-12"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">[&quot;Claro&quot;, &quot;piping&quot;, &quot;is&quot;, &quot;so&quot;, &quot;cool&quot;]
  |&gt; [^[0], ^[len(^) - 1]] # &lt;-- Get the first and last element of the list.
  |&gt; strings::join(&quot; is damn &quot;, ^)
  |&gt; &quot;{^}! I'll say it again... {^}!!&quot;  # &lt;-- Can backreference prev value more than once.
  |&gt; print(^);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
Claro is damn cool! I'll say it again... Claro is damn cool!!
</code></pre>
<hr />
<p>Compare to the alternative code without piping. Notice how use of piping in the above example even allows elimination of
multiple temporary variables - this is a powerful motivator for using pipelining as it's well known that <a href="https://martinfowler.com/bliki/TwoHardThings.html">naming is one
of the two hard problems in computer science</a>:</p>
<h4 id="fig-2-8"><a class="header" href="#fig-2-8"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># With piping, these temporary vars are unnecessary.
var nonPipingSource = [&quot;Claro&quot;, &quot;piping&quot;, &quot;is&quot;, &quot;so&quot;, &quot;cool&quot;];

var joinedTmp =
  strings::join(
    &quot; is damn &quot;,
    [nonPipingSource[0], nonPipingSource[len(nonPipingSource) - 1]]
  );

print(&quot;{joinedTmp}! I'll say it again... {joinedTmp}!!&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Claro is damn cool! I'll say it again... Claro is damn cool!!
</code></pre>
<hr />
<h2 id="textually-linear-data-flow"><a class="header" href="#textually-linear-data-flow">Textually Linear Data Flow</a></h2>
<p>It's worth noting that the primary motivation for pipelining support in Claro is to take what could otherwise be highly
nested procedure calls whose data flow conceptually runs &quot;inside-out&quot;, and allow it to instead be written in a style
that has the data flowing in the same linear direction as the textual source code itself. </p>
<p>As such, Claro's pipelines introduce a concept of &quot;source&quot; and &quot;sink&quot;. The &quot;source&quot; is the initial expression (data) 
that conceptually &quot;enters the pipeline&quot; and the &quot;sink&quot; is some terminal statement that consumes the data that &quot;comes out
of the end of the pipeline&quot;. This means that the pipeline's sink can be any valid Claro statement that uses the value
computed by the penultimate step in the pipeline.</p>
<p>Notice how the following variable assignment allows data to flow top-to-bottom in the same direction as the source code
is written textually:</p>
<h4 id="fig-3-5"><a class="header" href="#fig-3-5"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">[&quot;Hello&quot;, &quot;world!&quot;]
  |&gt; [strings::toUpperCase(s) | s in ^]
  |&gt; strings::join(&quot;, &quot;, ^)
  |&gt; var greeting = ^;

print(greeting);
</code></pre>
<p><em>Output:</em></p>
<pre><code>HELLO, WORLD!
</code></pre>
<hr />
<p>whereas, very confusingly, the non-pipelining style has source code written top-to-bottom, but yet the data is 
effectively flowing in a circuitous route from bottom-to-top and then back down again.</p>
<h4 id="fig-4-4"><a class="header" href="#fig-4-4"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">var greeting =
  strings::join(
    &quot;, &quot;,
    [strings::toUpperCase(s) | s in [&quot;Hello&quot;, &quot;world!&quot;]]
  );

print(greeting);
</code></pre>
<p><em>Output:</em></p>
<pre><code>HELLO, WORLD!
</code></pre>
<hr />
<p>This may be something that we all get used to in other languages, but it's certainly an obstacle to readability 
particularly for new programmers.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[0.003s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<div class="warning">
Note: Pattern Matching support is currently only partway through it's planned feature support (and has some open bugs to
be addressed). More to come!
</div>
<p>In addition to the typical if-else style branching construct, Claro offers a more powerful construct called &quot;Pattern 
Matching&quot;. In its simplest form, Pattern Matching can simply be used as a more concise replacement for if-else chains.</p>
<p>Compare the following if-else chain:</p>
<h4 id="fig-1-13"><a class="header" href="#fig-1-13"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">var x = 2;
</span><span class="boring">
</span>var sizeStr: string;
if (x &lt;= 1) {
  sizeStr = &quot;small&quot;;
} else if (x == 2) {
  sizeStr = &quot;medium&quot;;
} else {
  sizeStr = &quot;large&quot;;
}
<span class="boring">
</span><span class="boring">print(sizeStr);
</span></code></pre>
<hr />
<p>with the comparable match-statement:</p>
<h4 id="fig-2-9"><a class="header" href="#fig-2-9"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">var x = 2;
</span><span class="boring">
</span>var sizeStr: string;
match (x) {
  case 1 -&gt; sizeStr = &quot;small&quot;;
  case 2 -&gt; sizeStr = &quot;medium&quot;;
  case _ -&gt; sizeStr = &quot;large&quot;;
}
<span class="boring">
</span><span class="boring">print(sizeStr);
</span></code></pre>
<hr />
<p>The <code>match</code> statement takes in a single expression of any type, to be compared against the given <code>cases</code> clauses in 
order - the first one to successfully match is executed (there is no fallthrough like in a Java or C++ style switch).</p>
<h2 id="default-case"><a class="header" href="#default-case">&quot;Default&quot; Case</a></h2>
<p>The example above makes use of a &quot;default&quot; case that will match anything that the cases preceding it didn't match.</p>
<h4 id="fig-3-6"><a class="header" href="#fig-3-6"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">var x = 2;
</span><span class="boring">
</span><span class="boring">var sizeStr: string;
</span><span class="boring">match (x) {
</span><span class="boring">  case 1 -&gt; sizeStr = &quot;small&quot;;
</span><span class="boring">  case 2 -&gt; sizeStr = &quot;medium&quot;;
</span>  case _ -&gt; sizeStr = &quot;large&quot;;
<span class="boring">}
</span><span class="boring">
</span><span class="boring">print(sizeStr);
</span></code></pre>
<hr />
<p>In the context of pattern matching, the <code>_</code> token represents a &quot;wildcard&quot; pattern. Learn more about this in the 
<a href="control_flow/match/./wildcards/wildcards.generated_docs.html">Wildcard Patterns section</a>.</p>
<h2 id="multi-statement-cases"><a class="header" href="#multi-statement-cases">Multi-Statement Cases</a></h2>
<p>When a <code>case</code> is matched, the associated code block following the <code>-&gt;</code> and preceding the next <code>case</code> (or until the 
overall closing <code>}</code>) will all be executed. This code block can contain any number of statements.</p>
<h4 id="fig-4-5"><a class="header" href="#fig-4-5"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">var x = 2;
</span><span class="boring">
</span><span class="boring">var sizeStr: string;
</span><span class="boring">match (x) {
</span><span class="boring">  case 1 -&gt;
</span><span class="boring">    sizeStr = &quot;small&quot;;
</span>  case 2 -&gt;
    print(&quot;More than one line of code is valid.&quot;);
    sizeStr = &quot;medium&quot;;
<span class="boring">  case _ -&gt;
</span><span class="boring">    sizeStr = &quot;large&quot;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">print(sizeStr);
</span></code></pre>
<p><em>Output:</em></p>
<pre><code>More than one line of code is valid.
medium
</code></pre>
<hr />
<h2 id="patterns-must-not-reference-existing-variables"><a class="header" href="#patterns-must-not-reference-existing-variables">Patterns Must Not Reference Existing Variables</a></h2>
<div class="warning">
While this may seem like an arbitrary restriction, this is actually necessary in order to ensure that Claro's static
exhaustiveness and case reachability checks are actually guaranteed to be correct. Technically, it would be possible for
Claro to loosen this restriction, but this is a conscious, opinionated design choice to limit the number of special 
cases to keep in mind when writing or reading a match statement.
</div>
<p>The following is invalid:</p>
<h4 id="fig-5-3"><a class="header" href="#fig-5-3"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">var x = # ...
<span class="boring"> 2;
</span>match (2) {
  case x -&gt; print(&quot;Matched variable {x}&quot;);
  case 1 -&gt; print(&quot;1!&quot;);
  case _ -&gt; print(&quot;default!&quot;);
}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">match_EX5_example.claro:4: Wildcard Binding Shadows Declared Variable: Names of wildcard bindings in Match case patterns must not shadow any already-declared variable in scope.
  case x -&gt; print(&quot;Matched variable {x}&quot;);
       ^
match_EX5_example.claro:3: Illegal Duplicate Match Case: All case patterns should be unique within a match block.
match (2) {
       ^
match_EX5_example.claro:3: Illegal Duplicate Match Case: All case patterns should be unique within a match block.
match (2) {
       ^
match_EX5_example.claro:3: Illegal Match Containing Multiple Default Cases: Each match block should contain at most one case matching the `_` wildcard.
match (2) {
       ^
4 Errors
</code></pre>
<hr />
<p><em>Note: Claro's error messaging is a work in progress - the above error message will be improved.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matching-structured-data"><a class="header" href="#matching-structured-data">Matching Structured Data</a></h1>
<div class="warning">
Note: Pattern Matching support is currently only partway through it's planned feature support (and has some open bugs to
be addressed). More to come!
</div>
<p>Pattern Matching is much more than just a classic C-style switch statement. In particular, it can be used to match 
arbitrarily structured data.</p>
<h4 id="fig-1-14"><a class="header" href="#fig-1-14"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var employee = {name = &quot;Bob&quot;, title = &quot;Intern&quot;};

var permission: boolean;
match (employee) {
  case {name = &quot;Sarah&quot;, title = &quot;Manager&quot;} -&gt; permission = true;
  case {name = &quot;Joe&quot;,   title = &quot;Manager&quot;} -&gt; permission = true;
  case _                                   -&gt; permission = false;
}

print(&quot;Permission granted for {employee.name}?: {permission}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
Permission granted for Bob?: false
</code></pre>
<hr />
<h2 id="matching-arbitrarily-nested-structured-types"><a class="header" href="#matching-arbitrarily-nested-structured-types">Matching Arbitrarily Nested Structured Types</a></h2>
<p>Claro supports pattern matching over arbitrary (i.e. <code>tuple&lt;...&gt;</code> and <code>struct{...}</code>) structured types as their 
structures are fully known at compile time. </p>
<h4 id="fig-2-10"><a class="header" href="#fig-2-10"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var player = {name = &quot;Jason&quot;, currLoc = (1, 2)};

match (player) {
  case {name = &quot;Sarah&quot;, currLoc = (3, 4)} -&gt; print(&quot;Sarah wins!&quot;);
  case {name = &quot;Jason&quot;, currLoc = (1, 2)} -&gt; print(&quot;Jason wins!&quot;);
  case _                                  -&gt; print(&quot;Keep playing...&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>Jason wins!
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="wildcard-patterns"><a class="header" href="#wildcard-patterns">Wildcard Patterns</a></h1>
<div class="warning">
Note: Pattern Matching support is currently only partway through it's planned feature support (and has some open bugs to
be addressed). More to come!
</div>
<p>The utility of Pattern Matching is dramatically increased by making use of wildcards. For example, they enable the below
match with cases that only specify partial matches and then <strong>bind</strong> matched values to a variable:</p>
<h4 id="fig-1-15"><a class="header" href="#fig-1-15"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Square : int
newtype Rectangle : struct {height: int, width: int}
newtype Line : int

consumer printShapeArea(shape: oneof&lt;Square, Rectangle, Line&gt;) {
  var area: int;
  match (shape) {
    case Rectangle({height = H:int, width = W:int}) -&gt; area = H * W;
    case Square(W:int)                              -&gt; area = W * W;
    case _                                          -&gt; area = 0;
  }
  print(&quot;Area of {shape}: {area}&quot;);
}

printShapeArea(Square(2));
printShapeArea(Rectangle({height = 10, width = 10}));
printShapeArea(Line(2));
</code></pre>
<p><em>Output:</em></p>
<pre><code>Area of Square(2): 4
Area of Rectangle({height = 10, width = 10}): 100
Area of Line(2): 0
</code></pre>
<hr />
<p>The syntax <code>W:int</code> is a &quot;wildcard binding&quot; that matches any <code>int</code> value and declares a variable that the <code>int</code> will be 
assigned to in the <code>case</code> code block.</p>
<h2 id="case-ordering-and-wildcards"><a class="header" href="#case-ordering-and-wildcards">Case Ordering and Wildcards</a></h2>
<p>Cases are semantically matched in the order that they appear in the source code. This means that it's possible to define
unreachable cases if the cases above already cover the pattern:</p>
<p><em>Note: Claro's error messaging is a work in progress - the below error message will be improved.</em></p>
<h4 id="fig-2-11"><a class="header" href="#fig-2-11"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var t = (1, 2);
match (t) {
  case (1, 3) -&gt; # ...
<span class="boring">    print(&quot;(1, 3)&quot;);
</span>  case (_, 2) -&gt; # ...
<span class="boring">    print(&quot;(_, 2)&quot;);
</span>  case (1, 2) -&gt; # &lt;-- This is unreachable.
<span class="boring">    print(&quot;(1, 2)&quot;);
</span>  case _      -&gt; # ...
<span class="boring">    print(&quot;_&quot;);
</span>}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">wildcards_EX2_example.claro:2: Illegal Duplicate Match Case: All case patterns should be unique within a match block.
match (t) {
       ^
1 Error
</code></pre>
<hr />
<p>Simply changing the ordering of the cases above will fix this problem:</p>
<h4 id="fig-3-7"><a class="header" href="#fig-3-7"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var t = (1, 2);
match (t) {
  case (1, 3) -&gt; print(&quot;(1, 3)&quot;);
  case (1, 2) -&gt; print(&quot;(1, 2)&quot;);
  case (_, 2) -&gt; print(&quot;(_, 2)&quot;);
  case _      -&gt; print(&quot;_&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>(1, 2)
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-exhaustiveness-checks"><a class="header" href="#static-exhaustiveness-checks">Static Exhaustiveness Checks</a></h1>
<p>Pattern Matching is <strong>not</strong> just convenient syntax sugar. By using a <code>match</code> statement instead of an if-else chain, 
Claro is able to statically validate that every possible case is exhaustively handled by some <code>case</code>.</p>
<p>For example, the following <code>match</code> over a value of type <code>oneof&lt;Red, Yellow, Green&gt;</code> is missing a <code>case</code> to handle the 
<code>Green</code> atom and Claro rejects the <code>match</code> at compile-time:</p>
<h4 id="fig-1-16"><a class="header" href="#fig-1-16"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">atom Red
</span><span class="boring">atom Yellow
</span><span class="boring">atom Green
</span><span class="boring">
</span>var lightColor: oneof&lt;Red, Yellow, Green&gt; = Green;

var lightColorStr: string;
match (lightColor) {
  case _:Red    -&gt; lightColorStr = &quot;red&quot;;
  case _:Yellow -&gt; lightColorStr = &quot;yellow&quot;;
}

print(lightColorStr);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">exhaustiveness_checks_EX1_example.claro:8: Non-exhaustive Match: The given cases do not match every possible value of the matched type `oneof&lt;Red, Yellow, Green&gt;`.
	For example the following case is unhandled:
		case _:Green -&gt; ...;
	You can also ensure that all possible cases are being handled by adding a final fallback case as below:
		case _ -&gt; ...;
match (lightColor) {
       ^^^^^^^^^^
1 Error
</code></pre>
<hr />
<p>By following the suggestion in the error message above, we can fix the program:</p>
<h4 id="fig-2-12"><a class="header" href="#fig-2-12"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">atom Red
</span><span class="boring">atom Yellow
</span><span class="boring">atom Green
</span><span class="boring">
</span>var lightColor: oneof&lt;Red, Yellow, Green&gt; = Green;

var lightColorStr: string;
match (lightColor) {
  case _:Red    -&gt; lightColorStr = &quot;red&quot;;
  case _:Yellow -&gt; lightColorStr = &quot;yellow&quot;;
  case _:Green  -&gt; lightColorStr = &quot;green&quot;;
}

print(lightColorStr);
</code></pre>
<p><em>Output:</em></p>
<pre><code>green
</code></pre>
<hr />
<h2 id="non-trivial-exhaustiveness-checks-example"><a class="header" href="#non-trivial-exhaustiveness-checks-example">Non-Trivial Exhaustiveness Checks Example</a></h2>
<p>The above example is fairly trivial, just validating that all <code>oneof</code> type variants are handled. However, Claro's
exhaustiveness checks are fairly sophisticated, and should be able to catch mistakes in much more complicated scenarios:</p>
<h4 id="fig-3-8"><a class="header" href="#fig-3-8"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Foo&lt;T&gt; : T
var myStruct2 = {a = {x = 1, y = &quot;ninety-nine&quot;}, z = Foo(true)};

match (Foo(myStruct2)) {
  case Foo({a = {x = 1, y = &quot;two&quot;},  z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = 1, y = \&quot;two\&quot;},  z = Foo(false)})&quot;);
  case Foo({a = {x = 3, y = &quot;zero&quot;}, z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = 3, y = \&quot;zero\&quot;}, z = Foo(false)})&quot;);
  case Foo({a = {x = 1, y = _},      z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = 1, y = _},        z = Foo(false)})&quot;);
  case Foo({a = {x = _, y = &quot;two&quot;},  z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = _, y = \&quot;two\&quot;},  z = Foo(false)})&quot;);
  case Foo({a = A,                   z = Foo(true)})  -&gt; print(&quot;Foo(\{a = A, z = Foo(true)}) where A = {A}&quot;);
  case Foo({a = {x = 3, y = &quot;six&quot;},  z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = 3, y = \&quot;six\&quot;},  z = Foo(false)})&quot;);
}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">exhaustiveness_checks_EX3_example.claro:4: Non-exhaustive Match: The given cases do not match every possible value of the matched type `Foo&lt;struct{a: struct{x: int, y: string}, z: Foo&lt;boolean&gt;}&gt;`.
	For example the following case is unhandled:
		case Foo({a = {x = _, y = _}, z = Foo(false)}) -&gt; ...;
	You can also ensure that all possible cases are being handled by adding a final fallback case as below:
		case _ -&gt; ...;
match (Foo(myStruct2)) {
       ^^^^^^^^^^^^^^
1 Error
</code></pre>
<hr />
<p>Again, following the suggestion from the error message, we can fix the program:</p>
<h4 id="fig-4-6"><a class="header" href="#fig-4-6"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Foo&lt;T&gt; : T
var myStruct2 = {a = {x = 1, y = &quot;ninety-nine&quot;}, z = Foo(true)};

match (Foo(myStruct2)) {
  case Foo({a = {x = 1, y = &quot;two&quot;},  z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = 1, y = \&quot;two\&quot;},  z = Foo(false)})&quot;);
  case Foo({a = {x = 3, y = &quot;zero&quot;}, z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = 3, y = \&quot;zero\&quot;}, z = Foo(false)})&quot;);
  case Foo({a = {x = 1, y = _},      z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = 1, y = _},        z = Foo(false)})&quot;);
  case Foo({a = {x = _, y = &quot;two&quot;},  z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = _, y = \&quot;two\&quot;},  z = Foo(false)})&quot;);
  case Foo({a = A,                   z = Foo(true)})  -&gt; print(&quot;Foo(\{a = A, z = Foo(true)}) where A = {A}&quot;);
  case Foo({a = {x = 3, y = &quot;six&quot;},  z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = 3, y = \&quot;six\&quot;},  z = Foo(false)})&quot;);

  # Adding the case suggested by the prior error message.
  case Foo({a = {x = _, y = _},      z = Foo(false)}) -&gt; print(&quot;Foo(\{a = \{x = _, y = _},        z = Foo(false)})&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>Foo({a = A, z = Foo(true)}) where A = {x = 1, y = ninety-nine}
</code></pre>
<hr />
<p><em>Note: Claro's suggestions for resolving non-exhaustiveness</em> <code>match</code> <em>statements are intelligent and reliable, but Claro
will only warn about a single missing case example at a time (even if there are multiple unhandled cases). You may have
to apply multiple suggestions in succession, but simply following the suggestions will definitely (eventually) lead to a
fully exhaustive match statement.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection-comprehension"><a class="header" href="#collection-comprehension">Collection Comprehension</a></h1>
<p>Claro takes direct inspiration from Python's powerful &quot;Comprehensions&quot; syntax to provide powerful single-expression
operation to encode the common pattern of iterating some collection's elements and putting them into a new collection
after potentially filtering and transforming the elements. This allows you to do complex initializations of both mutable
and immutable collections directly in-line without having to drop down to multi-line initialization using some form of
loop. </p>
<h2 id="list-comprehension"><a class="header" href="#list-comprehension">List Comprehension</a></h2>
<p>Compare the following loop-based initialization:</p>
<h4 id="fig-1-17"><a class="header" href="#fig-1-17"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var mutList: mut [string] = mut [];
for (x in [1, 3, 99, 2, 1]) {
  if (x &lt;= 10) {
    lists::add(mutList, strings::repeated(&quot;*&quot;, x));
  }
}
print(mutList);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
mut [*, ***, **, *]
</code></pre>
<hr />
<p>with the List Comprehension based alternative:</p>
<h4 id="fig-2-13"><a class="header" href="#fig-2-13"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># The `|` below is read either &quot;for&quot; or &quot;given&quot;.
var mutList = mut [strings::repeated(&quot;*&quot;, x) | x in [1, 3, 99, 2, 1] where x &lt;= 10];
print(mutList);
</code></pre>
<p><em>Output:</em></p>
<pre><code>mut [*, ***, **, *]
</code></pre>
<hr />
<p>As you can see, taking the time to get comfortable with Comprehension expressions can serve to significantly simplify
your code.</p>
<div class="warning">
<p><strong>Optional</strong>: it may be useful to read a bit about the 
&quot;<a href="https://www.wikiwand.com/en/Set-builder_notation" target="_blank">Set Builder Notation</a>&quot; that inspires this
syntax in both Claro and Python.</p>
</div>
<h2 id="set-comprehension"><a class="header" href="#set-comprehension">Set Comprehension</a></h2>
<p>The same convenient Comprehension-based initialization is also supported for Sets. Simply swap the square brackets 
<code>[...]</code> for curly braces <code>{...}</code>:</p>
<h4 id="fig-3-9"><a class="header" href="#fig-3-9"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var immutableSet = {strings::repeated(&quot;*&quot;, x) | x in [1, 3, 99, 2, 1] where x &lt;= 10};
print(immutableSet);
</code></pre>
<p><em>Output:</em></p>
<pre><code>{**, *, ***}
</code></pre>
<hr />
<p>Notice now, even though the same mapping and filtering is done over the same input collection as in the list
comprehension examples above, the output here does not duplicate the entry <code>&quot;*&quot;</code> as Set Comprehension honors set 
semantics. (However, to be very explicit, <code>strings::repeated(&quot;*&quot;, 1)</code> was called twice).</p>
<h2 id="map-comprehension"><a class="header" href="#map-comprehension">Map Comprehension</a></h2>
<p>And finally, Comprehension-based initialization is also supported for Maps. Again, use curly braces <code>{...}</code> instead of
square brackets <code>[...]</code>, but this time a colon-separated key-value entry is computed from the input collection instead
of a single value:</p>
<h4 id="fig-4-7"><a class="header" href="#fig-4-7"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">var mutMap = mut {x : strings::repeated(&quot;*&quot;, x) | x in [1, 3, 99, 2] where x &lt;= 10};
print(mutMap);
</code></pre>
<p><em>Output:</em></p>
<pre><code>mut {1: *, 2: **, 3: ***}
</code></pre>
<hr />
<div class="warning">
<p><strong>Warning</strong>: Map Comprehension will Panic at runtime if you attempt to create multiple entries yielding the same key.
It's still up for debate whether this is desirable behavior - it's possible that this may be updated to some other model
such as &quot;last entry wins&quot;. TBD.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comprehension-is-more-than-syntax-sugar"><a class="header" href="#comprehension-is-more-than-syntax-sugar">Comprehension is More Than Syntax Sugar</a></h1>
<p>While the previous section emphasized the ergonomic and simplifying qualities of Comprehensions, it should be explicitly
stated that this construct is <strong>not just syntax sugar</strong>. Specifically, there is no other way in the language to directly
initialize a List/Set/Map with size and elements determined dynamically at runtime <strong>without incurring an extra copy</strong>:</p>
<h4 id="fig-1-18"><a class="header" href="#fig-1-18"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var mutList: mut [string] = mut [];
for (x in [1, 3, 99, 2, 1]) {
  if (x &lt;= 10) {
    lists::add(mutList, strings::repeated(&quot;*&quot;, x));
  }
}

# Claro is automatically coercing the copied list to be immutable.
var immutableList: [string] = copy(mutList);
print(immutableList);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[*, ***, **, *]
</code></pre>
<hr />
<p>Using List Comprehension instead not only produces much simpler code, but will also allow you to drop the unnecessary 
copy:</p>
<h4 id="fig-2-14"><a class="header" href="#fig-2-14"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var immutableList = [strings::repeated(&quot;*&quot;, x) | x in [1, 3, 99, 2, 1] where x &lt;= 10];
print(immutableList);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[*, ***, **, *]
</code></pre>
<hr />
<div class="warning">
<p><strong>Note</strong>: Read more about Claro's built-in <code>copy(...)</code> operator here (TODO(steving)).</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Claro is a statically typed, compiled programming language. This means that if you attempt to assign a value of the
wrong type to a variable, Claro will emit a compiler error asking for a correction before your program will be able to
run. This will prevent you from waiting until runtime to find many program errors.</p>
<h4 id="fig-1-19"><a class="header" href="#fig-1-19"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var s: string = 100.55;
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">static_typing_EX1_example.claro:1: Invalid type:
	Found:
		double
	Expected:
		string
var s: string = 100.55;
                ^^^^^^
1 Error
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="builtin-collections"><a class="header" href="#builtin-collections">Builtin Collections</a></h1>
<p>Claro also rounds out its builtin types with a small set of convenient collection types that allow you to manipulate
many values using a single variable. These are provided as builtins for your convenience, but their implementations have
been hand selected to cover the majority of your general purpose programming use cases.</p>
<h2 id="ad-hoc-declarations"><a class="header" href="#ad-hoc-declarations">Ad-Hoc Declarations</a></h2>
<p>Unlike many other languages (e.g. Java/C++/etc.) that require a formal declaration of any type before it can be 
instantiated, Claro's builtin collections can all be simply instantiated at will as if the type already exists. For 
example, any struct-like collection of named fields in Java would first require the declaration of a class, and 
potentially the declaration of other things like a constructor, hashCode() and equals() implementations. In Claro, you
simply skip all the boilerplate.</p>
<p>For example, the following Claro procedure declares a <code>struct {row: int, col: int}</code> inline as the function's return type
and doesn't need any top-level declaration of that type before it's used:</p>
<h4 id="fig-1-20"><a class="header" href="#fig-1-20"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">function findInNestedList&lt;T&gt;(l: [[T]], t: T) -&gt; struct {row: int, col: int} {
  var r = 0;
  for (row in l) {
    var c = 0;
    for (elem in row) {
      if (elem == t) {
        return {row = r, col = c};  # &lt;-- Just instantiate the struct.
      }
      ++c;
    }
    ++r;
  }
  return {row = -1, col = -1};
}

[[1, 2],
 [3, 4],
 [5, 6]]
  |&gt; findInNestedList(^, 4)
  |&gt; print(^);
</code></pre>
<p><em>Output:</em></p>
<pre><code>{row = 1, col = 1}
</code></pre>
<hr />
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>All of Claro's builtin collection types come in either a <strong>mutable</strong> or <strong>immutable</strong> variant - by default, Claro will
assume that any collection literals are intended to be <strong>immutable</strong>. </p>
<h4 id="fig-2-15"><a class="header" href="#fig-2-15"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var l = [1, 2, 3]; # Immutable list of ints.
print(l);

# The below line would be illegal as `lists::add` expects a mutable list.
# lists::add(l, 4);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[1, 2, 3]
</code></pre>
<hr />
<p>The following example demonstrates initialization of a <strong>mutable</strong> list of integers:</p>
<h4 id="fig-3-10"><a class="header" href="#fig-3-10"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var l = mut [1, 2, 3];
print(&quot;Before: {l}&quot;);

lists::add(l, 4);      # &lt;-- Mutation happens here.
print(&quot;After:  {l}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Before: mut [1, 2, 3]
After:  mut [1, 2, 3, 4]
</code></pre>
<hr />
<h2 id="mutability-annotations-are-shallow"><a class="header" href="#mutability-annotations-are-shallow">Mutability Annotations are Shallow</a></h2>
<p>Claro's mutability annotations are shallow by design so that you maintain fine-grained control over creating arbitrarily
complex nested data structures that mix mutability and immutability as needed. The following examples demonstrate 
different combinations of nested mutability annotations:</p>
<p>This example demonstrates a mutable list whose elements are immutable lists.</p>
<h4 id="fig-4-8"><a class="header" href="#fig-4-8"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">var l: mut [[int]] = mut [];
for (i in [1, 2, 3]) {
  lists::add(l, [i, i]); # &lt;-- Add an immutable list to the mutable list.
}
print(l);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
mut [[1, 1], [2, 2], [3, 3]]
</code></pre>
<hr />
<p>This example demonstrates an immutable list whose elements are mutable lists.</p>
<h4 id="fig-5-4"><a class="header" href="#fig-5-4"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">var l: [mut [int]] = [mut [], mut [], mut []];
var i = 1;
for (mutList in l) {
  lists::add(mutList, i); # &lt;-- Append an int to this inner mutable list.
  lists::add(mutList, i++);
}
print(l);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[mut [1, 1], mut [2, 2], mut [3, 3]]
</code></pre>
<hr />
<h2 id="data-race-safety-via-deep-immutability"><a class="header" href="#data-race-safety-via-deep-immutability">Data Race Safety via Deep Immutability</a></h2>
<div class="warning">
This builtin support for mutability annotations allows Claro to enforce some very strong safety guarantees in concurrent 
contexts, so this is about more than just providing a convenient library of data types.
</div>
<p>See the <a href="static_typing/builtin_colls/../../concurrency.html">Concurrency</a> section in this book for more details on how Claro will statically leverage 
knowledge of whether a type is deeply immutable or not to prevent unsafe data races.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lists"><a class="header" href="#lists">Lists</a></h1>
<p>The simplest collection type allows you to keep an arbitrary number of values in some ordering. The list is very much
like a Python list in that it allows arbitrary appends, and random access to read values at a O-based index. Unlike
Python, as Claro is statically typed, all values in the list must be of the same type, and this type must be
pre-determined upon declaration of the variable which reference the list.</p>
<h4 id="fig-1-21"><a class="header" href="#fig-1-21"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var l: mut [int] = mut [1, 3, 7, 2, -115, 0];
lists::add(l, 99);
print(len(l)); # 7
print(l[1] == l[0]); # false
print(l[6] == 99); # true
</code></pre>
<p><em>Output:</em></p>
<pre><code>7
false
true
</code></pre>
<hr />
<h2 id="accessing-list-elements"><a class="header" href="#accessing-list-elements">Accessing List Elements</a></h2>
<p>Lists support random-access indexing via traditional C-like syntax:</p>
<h4 id="fig-2-16"><a class="header" href="#fig-2-16"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var l = [1, 2];
print(l[0]);
print(l[1]);
</code></pre>
<p><em>Output:</em></p>
<pre><code>1
2
</code></pre>
<hr />
<h2 id="mutable-list-element-reassignment"><a class="header" href="#mutable-list-element-reassignment">Mutable List Element Reassignment</a></h2>
<p>You can update the individual values stored at a particular list index via traditional C-like syntax:</p>
<h4 id="fig-3-11"><a class="header" href="#fig-3-11"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var l = mut [1, 2];
l[0] = 99;
print(l);
</code></pre>
<p><em>Output:</em></p>
<pre><code>mut [99, 2]
</code></pre>
<hr />
<h2 id="index-out-of-bounds"><a class="header" href="#index-out-of-bounds">Index-Out-Of-Bounds</a></h2>
<p>As with most other languages that allow random-access to lists, you must be careful to always index into lists at valid
positions. Any accesses of index, i, where i &lt; 0 or i &gt;= len(l) will result in the program Panicking (exiting in an 
unrecoverable way).</p>
<pre><code>var l = mut [1, 2];
l[99] = 0;    # &lt;-- Panic: Index-out-of-Bounds!
</code></pre>
<p>(Note: it's possible that as the language evolves, Claro may instead opt to make all list subscripting operations
inherently safe by returning some structured result that models the possibility that the list index was invalid. This is
ideal for safety, however, this would impose a global runtime overhead so the tradeoff is still being evaluated.)</p>
<h2 id="stdlib-lists-module"><a class="header" href="#stdlib-lists-module">Stdlib <code>lists</code> Module</a></h2>
<p>A large variety of list operations are available in the 
<a href="https://github.com/JasonSteving99/claro-lang/tree/main/stdlib/lists">stdlib's <code>lists</code> module</a>. For example, the previous exapmle
added an element to the end of a mutable list by using the <code>lists::add</code> procedure whose signature is the following in
the <code>lists.claro_module_api</code> file:</p>
<pre><code># Appends the specified element to the end of this list.
consumer add&lt;T&gt;(l: mut [T], toAdd: T);
</code></pre>
<h2 id="empty-lists"><a class="header" href="#empty-lists">Empty Lists</a></h2>
<p>It's worth noting that Claro has no way of inferring the correct element type of an empty list when it's type is not
constrained by context. For example, the below variable declaration would be a compile-error:</p>
<pre><code>var l = []; # Compiler Error: ambiguous type.
</code></pre>
<h3 id="empty-list-type-inference-by-later-usage-will-never-be-supported"><a class="header" href="#empty-list-type-inference-by-later-usage-will-never-be-supported">Empty List Type Inference By Later Usage (Will Never Be Supported)</a></h3>
<p>You might think that Claro should be able to infer the type intended for this empty list based on the later usage of the
variable it's assigned to. <strong>Claro takes the opinionated stance that this would be inherently undesirable behavior</strong>.
Type inference shouldn't follow some esoteric resolution rules. It would be all too easy to implement a complex type
inference system that can infer types far better than any real world human reader could - the end result would simply be
enabling code to be written that is intrinsically difficult for your colleagues (and your future self) to read later on.
This is an anti-goal of Claro.</p>
<p><strong>The following will never be supported</strong>:</p>
<pre><code># Hypothetically, Claro could infer that the type of `l` is `mut [string]` based
# solely on the usage of `l` later on.
var l = mut [];

...a bunch of code...

append(l, &quot;foo&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sets"><a class="header" href="#sets">Sets</a></h1>
<p>Claro sets are much like Python sets, with a fixed, single type for all elements. You may initialize them with many
elements and then check for membership in the set later.</p>
<h4 id="fig-1-22"><a class="header" href="#fig-1-22"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var mySet: {int} = {1, 6, -12};
print(10 in mySet);
print(6 in mySet);
</code></pre>
<p><em>Output:</em></p>
<pre><code>false
true
</code></pre>
<hr />
<h2 id="adding-elements-to-a-mutable-set"><a class="header" href="#adding-elements-to-a-mutable-set">Adding Elements to a Mutable Set</a></h2>
<p>Elements can be added to a set by making use of the <code>sets::add</code> function from the
<a href="https://github.com/JasonSteving99/claro-lang/tree/main/stdlib/sets">stdlib's <code>sets</code> module</a>.</p>
<h4 id="fig-2-17"><a class="header" href="#fig-2-17"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># Adds the specified element to this set if it is not already present. If this set already contains the element, the
# call leaves the set unchanged and returns false. This ensures that sets never contain duplicate elements.
#
# Returns: true if this set did not already contain the specified element.
function add&lt;T&gt;(s: mut {T}, t: T) -&gt; boolean;
</code></pre>
<hr />
<h4 id="fig-3-12"><a class="header" href="#fig-3-12"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var s = mut {1, 2};
print(10 in s);
_ = sets::add(s, 10);  # &lt;-- Explicitly ignoring output of function call.
print(10 in s);
</code></pre>
<p><em>Output:</em></p>
<pre><code>false
true
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="maps"><a class="header" href="#maps">Maps</a></h1>
<p>A mapping of keys of a fixed value type, to values of a fixed type.</p>
<h4 id="fig-1-23"><a class="header" href="#fig-1-23"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var myMap: mut {string: int} = mut {};
myMap[&quot;Jason&quot;] = 28;
print(&quot;Jason&quot; in myMap); # true
myMap[&quot;Kenny&quot;] = 29;
print(myMap); # mut {&quot;Jason&quot;: 28, &quot;Kenny&quot;: 29}
</code></pre>
<p><em>Output:</em></p>
<pre><code>true
mut {Jason: 28, Kenny: 29}
</code></pre>
<hr />
<h2 id="checking-if-a-key-exists"><a class="header" href="#checking-if-a-key-exists">Checking if a Key Exists</a></h2>
<p>You can check for the existence of a key in a map by using the <code>in</code> keyword.</p>
<h4 id="fig-2-18"><a class="header" href="#fig-2-18"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var m = {&quot;a&quot;: 1, &quot;b&quot;: 2};

for (k in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) {
  print(&quot;{k} in map: {k in m}&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>a in map: true
b in map: true
c in map: false
</code></pre>
<hr />
<h2 id="iterating-over-the-entries-of-a-map"><a class="header" href="#iterating-over-the-entries-of-a-map">Iterating Over the Entries of a Map</a></h2>
<p>Claro's <code>for</code> loop supports iterating over the entries of a map, with each entry modeled as <code>tuple&lt;K, V&gt;</code>:</p>
<h4 id="fig-3-13"><a class="header" href="#fig-3-13"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var m = {&quot;a&quot;: 1, &quot;b&quot;: 2};

for (entry in m) {
  var k = entry[0];
  var v = entry[1];
  print(&quot;{k} -&gt; {v}&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>a -&gt; 1
b -&gt; 2
</code></pre>
<hr />
<h2 id="stdlib-maps-module"><a class="header" href="#stdlib-maps-module">Stdlib <code>maps</code> Module</a></h2>
<p>A large variety of map operations are available in the
<a href="https://github.com/JasonSteving99/claro-lang/tree/main/stdlib/maps">stdlib's <code>maps</code> module</a>. For example, you can 
declare a default value that will be used as fallback if the read key doesn't exist in the map by using the following
function declared in the <code>maps.claro_module_api</code> file:</p>
<h4 id="fig-4-9"><a class="header" href="#fig-4-9"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"># Returns the value to which the specified key is mapped, or `defaultValue` if this map contains no mapping for the key.
function getOrDefault&lt;K,V&gt;(m: {K:V}, k: K, defaultValue: V) -&gt; V;
</code></pre>
<hr />
<h4 id="fig-5-5"><a class="header" href="#fig-5-5"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">var m = {&quot;a&quot;: 1, &quot;b&quot;: 2};

for (k in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) {
  print(maps::getOrDefault(m, k, -1));
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>1
2
-1
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>Tuples are a fixed-order, fixed-size collection of values which do not all have to be of the same type.</p>
<h1 id="compile-time-validated-indexing"><a class="header" href="#compile-time-validated-indexing">Compile-Time Validated Indexing</a></h1>
<p>You can see in the example below, tuples interact w/ type validation in an interesting way worth making note of. When
you index into a tuple, you should generally prefer to use a literal int constant. When you do, Claro can statically
determine the type of the value you're accessing at compile time, which allows safer and more efficient code.</p>
<p>For example, Claro is able to statically find the bugs in the below program:</p>
<h4 id="fig-1-24"><a class="header" href="#fig-1-24"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var myPair: tuple&lt;int, string&gt; = (1, &quot;one&quot;);

# Claro will interpret literal int subscripts at compile-time for type validation.
var myInt: int = myPair[1];     # &lt;-- Wrong index.
print(myInt);
var myStr: string = myPair[3];  # &lt;-- Out-of-bounds index.
print(myStr);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">tuple_type_EX1_example.claro:4: Invalid type:
	Found:
		string
	Expected:
		int
var myInt: int = myPair[1];     # &lt;-- Wrong index.
                 ^^^^^^^^^
tuple_type_EX1_example.claro:6: Tuple Subscript Literal Out of Bounds:
	For subscript on tuple of type: tuple&lt;int, string&gt;
	Found:
		3
	Expected:
		index in range [0, 2)
var myStr: string = myPair[3];  # &lt;-- Out-of-bounds index.
                    ^^^^^^^^^
2 Errors
</code></pre>
<hr />
<p>Making it easy to apply the fix:</p>
<h4 id="fig-2-19"><a class="header" href="#fig-2-19"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var myPair: tuple&lt;int, string&gt; = (1, &quot;one&quot;);

# Claro will interpret literal int subscripts at compile-time for type validation.
var myInt: int = myPair[0];     # &lt;-- Correct index.
print(myInt);
var myStr: string = myPair[1];  # &lt;-- Correct index.
print(myStr);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
1
one
</code></pre>
<hr />
<h1 id="runtime-validated-indexing"><a class="header" href="#runtime-validated-indexing">Runtime Validated Indexing</a></h1>
<p>If your index value is hidden behind some indirection, Claro can't know the type at compile-time and will require a 
runtime type cast (which is slow &amp; opens the door to runtime Panics if the actual type doesn't match the asserted type).</p>
<p>Claro will warn you at compile-time when this is necessary:</p>
<h4 id="fig-3-14"><a class="header" href="#fig-3-14"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var myPair: tuple&lt;int, string&gt; = (1, &quot;one&quot;);

# Claro requires a type cast for non-literal index.
var index: int = 0;
var myInt = myPair[index];
print(myInt);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">tuple_type_EX3_example.claro:5: The type of this expression is UNDECIDED at compile-time! You must explicitly cast the Expr to the expected type to assert this type at compile-time.
var myInt = myPair[index];
            ^^^^^^^^^^^^^
tuple_type_EX3_example.claro:6: No variable &lt;myInt&gt; within the current scope!
print(myInt);
      ^^^^^
2 Errors
</code></pre>
<hr />
<p>Fix the error by explicitly asserting the expected type by casting:</p>
<h4 id="fig-4-10"><a class="header" href="#fig-4-10"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">var myPair: tuple&lt;int, string&gt; = (1, &quot;one&quot;);

# Claro requires a type cast for non-literal index.
var index: int = 0;
var myInt = cast(int, myPair[index]); # OK, opting into runtime type validation.
print(myInt);
</code></pre>
<p><em>Output:</em></p>
<pre><code>1
</code></pre>
<hr />
<h1 id="mutable-tuples"><a class="header" href="#mutable-tuples">Mutable Tuples</a></h1>
<p>Unlike some other languages with tuple support, Claro imposes no arbitrary restriction that all tuples must necessarily 
be immutable. Just like any other builtin collection type, a Claro tuple may be declared mutable using the <code>mut</code> 
keyword when declaring a variable or initializing the value. You may then update element values at will as long as the 
initial type declaration for each element is honored.</p>
<p>Claro won't allow you to mutate a tuple that isn't explicitly declared mutable:</p>
<h4 id="fig-5-6"><a class="header" href="#fig-5-6"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">var myPair = (1, &quot;one&quot;); # &lt;-- This is an **immutable** tuple.
print(myPair);

myPair[0] = 99;  # &lt;-- Illegal attempted mutation happens here.
print(myPair);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">tuple_type_EX5_example.claro:4: Illegal Mutation of Immutable Value: Mutation of immutable values is forbidden!
	Found the immutable type:
		tuple&lt;int, string&gt;
	In order to mutate this value, the value's type would need to be updated to:
		mut tuple&lt;int, string&gt;
myPair[0] = 99;  # &lt;-- Illegal attempted mutation happens here.
^^^^^^
1 Error
</code></pre>
<hr />
<p>The mutation is legal when the tuple is explicitly annotated <code>mut</code>:</p>
<h4 id="fig-6-2"><a class="header" href="#fig-6-2"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro">var myPair = mut (1, &quot;one&quot;);  # &lt;-- This is now a **mutable** tuple.
print(myPair);

myPair[0] = 99;  # &lt;-- Mutation happens here.
print(myPair);
</code></pre>
<p><em>Output:</em></p>
<pre><code>mut (1, one)
mut (99, one)
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Structs are similar to tuples with named field values of arbitrary pre-declared types.</p>
<h4 id="fig-1-25"><a class="header" href="#fig-1-25"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var myStruct: struct {x: int, y: int} = {x = 1, y = 2};
print(myStruct);
</code></pre>
<p><em>Output:</em></p>
<pre><code>{x = 1, y = 2}
</code></pre>
<hr />
<h2 id="field-access"><a class="header" href="#field-access">Field Access</a></h2>
<p>Struct field values can be directly accessed using &quot;dot-notation&quot; as below:</p>
<h4 id="fig-2-20"><a class="header" href="#fig-2-20"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var myStruct: struct {x: int, y: int} = {x = 1, y = 2};
print(myStruct.x);
print(myStruct.y);
</code></pre>
<p><em>Output:</em></p>
<pre><code>1
2
</code></pre>
<hr />
<h2 id="mutable-structs"><a class="header" href="#mutable-structs">Mutable Structs</a></h2>
<p>Just like any other builtin collection type, a Claro struct may be declared mutable using the <code>mut</code> keyword when 
declaring a variable or initializing the value. You may then update element values at will as long as the initial type 
declaration for each element is honored.</p>
<h4 id="fig-3-15"><a class="header" href="#fig-3-15"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var myStruct = mut {name = &quot;Jason&quot;, age = 29};  # &lt;-- Omitting optional type annotation.
print(myStruct);

myStruct.name = &quot;Claro&quot;;  # &lt;-- Mutation happens here.
myStruct.age = 3;         # &lt;-- Mutation happens here.
print(myStruct);
</code></pre>
<p><em>Output:</em></p>
<pre><code>mut {name = Jason, age = 29}
mut {name = Claro, age = 3}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="oneofs"><a class="header" href="#oneofs">Oneofs</a></h1>
<p>Something that's often left unaddressed by statically typed programming languages is the ability to model a value that
can take on one of an arbitrary set of types. Many other languages approximate this sort of ability through a notion of
&quot;sub-typing&quot; relationships between a hierarchy of types. While sub-typing as found broad use and much support throughout
the programming languages ecosystem, Claro has been designed under the belief that sub-typing leaves much to be desired
and opens the door to all sorts of unwanted and unnecessary complexity and leads to error-prone coding patterns. So,
on principle, Claro will never support sub-typing, and instead provides support for <code>oneof</code> types (also known as 
tagged-unions in other languages). </p>
<h4 id="fig-1-26"><a class="header" href="#fig-1-26"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var intOrStr: oneof&lt;int, string&gt;;
</code></pre>
<hr />
<h2 id="check-the-concrete-type-of-a-oneof-with-the-instanceof-operator"><a class="header" href="#check-the-concrete-type-of-a-oneof-with-the-instanceof-operator">Check the Concrete Type of a Oneof With the <code>instanceof</code> Operator</a></h2>
<p>The entire point of a <code>oneof</code> type is to be able to write branching logic on the concrete type that is <em>actually</em>
represented by the <code>oneof</code> at runtime. One way of achieving this is with the <code>instanceof</code> boolean operator that allows
you to check the concrete type at runtime:</p>
<h4 id="fig-2-21"><a class="header" href="#fig-2-21"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">var intOrStr: oneof&lt;int, string&gt;;
</span><span class="boring">
</span><span class="boring">random::forSeed(20000)
</span><span class="boring">  |&gt; random::nextNonNegativeBoundedInt(^, 2)
</span><span class="boring">  |&gt; var r = ^;
</span><span class="boring">
</span>match (r) {
  case 0 -&gt; intOrStr = 10;
  case _ -&gt; intOrStr = &quot;ten&quot;;
}
print(&quot;intOrStr: {intOrStr}&quot;);

if (intOrStr instanceof int) {
  print(&quot;Found an int!&quot;);
} else {
  print(&quot;Found a string!&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>intOrStr: 10
Found an int!
</code></pre>
<hr />
<div class="warning">
It's somewhat nonsensical to do an instanceof check on any concrete type so Claro statically rejects that.
</div>
<h4 id="fig-3-16"><a class="header" href="#fig-3-16"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">if (10 instanceof int) {
  print(&quot;Obviously an int&quot;);
}
if (10 instanceof string) {
  print(&quot;Obviously not a string&quot;);
}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">oneofs_EX3_example.claro:1: Illegal instanceof Check: int is a statically known concrete type! Using instanceof over a statically known concrete type is never necessary.
if (10 instanceof int) {
    ^^^^^^^^^^^^^^^^^
oneofs_EX3_example.claro:4: Illegal instanceof Check: int is a statically known concrete type! Using instanceof over a statically known concrete type is never necessary.
if (10 instanceof string) {
    ^^^^^^^^^^^^^^^^^^^^
2 Errors
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="narrowing--type-guards"><a class="header" href="#narrowing--type-guards">&quot;Narrowing&quot; / Type Guards</a></h1>
<p>Inspired by TypeScript's support for this, when you perform an <code>instanceof</code> check on a variable with a <code>oneof</code> type
within a conditional statement, Claro automatically &quot;narrows&quot; the type of the variable to the checked type. This is
logically valid because the only way that control-flow could possibly reach that context is if that was actually the
type at runtime.</p>
<h4 id="fig-1-27"><a class="header" href="#fig-1-27"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">var intOrStr: oneof&lt;int, string&gt; = 10;
</span><span class="boring">
</span>if (intOrStr instanceof int) {
  # Claro automatically &quot;narrows&quot; the variable to have type `int`.
  var addRes = intOrStr + 10;
  print(&quot;{intOrStr} + 10 = {addRes}&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.003s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
10 + 10 = 20
</code></pre>
<hr />
<div class="warning">
Note: Claro is not implementing full "flow typing" here. The type will be "widened" again to its originally declared
type if you assign a value of any type other than the narrowed type to a variable in a context where it's been narrowed.
</div>
<h4 id="fig-2-22"><a class="header" href="#fig-2-22"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">var intOrStr: oneof&lt;int, string&gt; = 10;
</span><span class="boring">
</span>if (intOrStr instanceof int) {
  # Claro automatically &quot;narrows&quot; the variable to have type `int`.
  var addRes = intOrStr + 10;
  print(&quot;{intOrStr} + 10 = {addRes}&quot;);

  # Claro automatically &quot;widens&quot; the variable to `oneof&lt;int, string&gt;`.
  intOrStr = &quot;ten&quot;;
  addRes = intOrStr + 10;  # &lt;-- This is no longer valid.
}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">narrowing_EX2_example.claro:10: Invalid type: found &lt;oneof&lt;int, string&gt;&gt;, but expected one of (&lt;int, long, float, double&gt;).
  addRes = intOrStr + 10;  # &lt;-- This is no longer valid.
           ^^^^^^^^
1 Error
</code></pre>
<hr />
<h2 id="non-trivial-example-usage"><a class="header" href="#non-trivial-example-usage">Non-Trivial Example Usage</a></h2>
<p>For a less trivial example of working with <code>oneof</code> types, the below function is able to pretty-print a linked list by
checking if the current node is the end of the list or not by branching on the type of the <code>next</code> reference:</p>
<h4 id="fig-3-17"><a class="header" href="#fig-3-17"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype LinkedNode&lt;T&gt; : struct {
  val: T,
  next: oneof&lt;LinkedNode&lt;T&gt;, std::Nothing&gt;
}

alias SB : string_builder::StringBuilder
function renderLinkedList&lt;T&gt;(head: LinkedNode&lt;T&gt;, sb: SB) -&gt; SB {
  _ = string_builder::add(sb, &quot;{unwrap(head).val} -&gt; &quot;);
  var next = unwrap(head).next;
  if (next instanceof LinkedNode&lt;T&gt;) {
    return renderLinkedList(next, sb);   # &lt;-- Type of `next` was &quot;narrowed&quot; to `LinkedNode&lt;T&gt;`.
  } else {
    return string_builder::add(sb, &quot;*END*&quot;);
  }
}

var linkedList = LinkedNode({val = 1, next = LinkedNode({val = 2, next = LinkedNode({val = 3, next = std::Nothing})})});

string_builder::create()
  |&gt; renderLinkedList(linkedList, ^)
  |&gt; string_builder::build(^)
  |&gt; print(^);
</code></pre>
<p><em>Output:</em></p>
<pre><code>1 -&gt; 2 -&gt; 3 -&gt; *END*
</code></pre>
<hr />
<p><em>The above example relies on concepts described in later sections, so consider checking out
<a href="static_typing/oneofs/narrowing/../user_defined_types/user_defined_types.generated_docs.html">User Defined Types</a> and <a href="static_typing/oneofs/narrowing/../../generics.generated_docs.html">Generics</a>
for some more info.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atoms"><a class="header" href="#atoms">Atoms</a></h1>
<p>Sometimes it's useful to represent a concept that doesn't necessarily have any meaningful &quot;data&quot; apart from a name. For
example, you may want to represent the states of a simple street-light (i.e. red, yellow, or green). </p>
<p>Claro's atoms provide a clean solution for modelling these states:</p>
<h4 id="fig-1-28"><a class="header" href="#fig-1-28"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">atom Red
atom Yellow
atom Green
</code></pre>
<hr />
<p>Now, you can write code that directly uses these <code>Red</code>, <code>Yellow</code> and <code>Green</code> as values. </p>
<h4 id="fig-2-23"><a class="header" href="#fig-2-23"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">random::forSeed(1)
  |&gt; random::nextNonNegativeBoundedInt(^, 3)
  |&gt; var r = ^;

var lightColor: oneof&lt;Red, Yellow, Green&gt;;
match (r) {
  case 0 -&gt; lightColor = Red;
  case 1 -&gt; lightColor = Yellow;
  case _ -&gt; lightColor = Green;
}
print(lightColor);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.011s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
Red
</code></pre>
<hr />
<h2 id="static-validation"><a class="header" href="#static-validation">Static Validation</a></h2>
<div class="warning">
You could try to use strings for this purpose, but then you would need to do runtime string equality checks throughout 
your codebase to distinguish one state from another as their types would all be the same, `string`, and even worse you 
open yourself to simple typo bugs.
</div>
<p>Using atoms, Claro will catch any accidental typos for you at compile-time:</p>
<h4 id="fig-3-18"><a class="header" href="#fig-3-18"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">random::forSeed(1)
</span><span class="boring">  |&gt; random::nextNonNegativeBoundedInt(^, 3)
</span><span class="boring">  |&gt; var r = ^;
</span><span class="boring">
</span><span class="boring">var lightColor: oneof&lt;Red, Yellow, Green&gt;;
</span><span class="boring">match (r) {
</span><span class="boring">  case 0 -&gt; lightColor = Red;
</span>  case 1 -&gt; lightColor = Yelow;  # &lt;-- Claro will catch this misspelling for you.
<span class="boring">  case _ -&gt; lightColor = Green;
</span><span class="boring">}
</span><span class="boring">print(lightColor);
</span></code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">atoms_EX3_example.claro:8: No variable &lt;Yelow&gt; within the current scope!
  case 1 -&gt; lightColor = Yelow;  # &lt;-- Claro will catch this misspelling for you.
                         ^^^^^
atoms_EX3_example.claro:8: Invalid type: found &lt;&lt;UNKNOWABLE DUE TO PRIOR TYPE VALIDATION ERROR&gt;&gt;, but expected one of (&lt;Red, Yellow, Green, oneof&lt;Red, Yellow, Green&gt;&gt;).
  case 1 -&gt; lightColor = Yelow;  # &lt;-- Claro will catch this misspelling for you.
                         ^^^^^
2 Errors
</code></pre>
<hr />
<h2 id="ad-hoc-enums"><a class="header" href="#ad-hoc-enums">Ad-Hoc &quot;Enums&quot;</a></h2>
<p>Unlike many other languages, if you want to define a type that has only a limited set of possible values you don't have
to declare an &quot;enum&quot; ahead of time. Instead, Claro encourages modeling this using the builtin <code>oneof&lt;...&gt;</code> type as in
the example above. It can be useful to define an alias to represent the &quot;enum&quot; in a concise way if it's widely used:</p>
<h4 id="fig-4-11"><a class="header" href="#fig-4-11"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">alias LightColor : oneof&lt;Red, Yellow, Green&gt;

<span class="boring">random::forSeed(1)
</span><span class="boring">  |&gt; random::nextNonNegativeBoundedInt(^, 3)
</span><span class="boring">  |&gt; var r = ^;
</span><span class="boring">
</span>var lightColor: LightColor;
<span class="boring">match (r) {
</span><span class="boring">  case 0 -&gt; lightColor = Red;
</span><span class="boring">  case 1 -&gt; lightColor = Yellow;
</span><span class="boring">  case _ -&gt; lightColor = Green;
</span><span class="boring">}
</span><span class="boring">print(lightColor);
</span></code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="aliases"><a class="header" href="#aliases">Aliases</a></h1>
<p>Aliases are a powerful feature that allow the expression of arbitrary types. In their simplest form, they may be used as
syntactic sugar to reduce keystrokes and cognitive overhead from typing out a full type literal.</p>
<h4 id="fig-1-29"><a class="header" href="#fig-1-29"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># You can imagine that typing this out could be verbose/annoying.
alias IntsToTupleFn: function&lt;|int, int| -&gt; tuple&lt;int, int&gt;&gt;

consumer prettyPrint(name: string, fn: IntsToTupleFn, arg1: int, arg2: int) {
  var res = fn(arg1, arg2);
  print(&quot;{name}({arg1}, {arg2}) -&gt; {res}&quot;);
}

var swapped: IntsToTupleFn = lambda (a, b) -&gt; (b, a);
prettyPrint(&quot;swapped&quot;, swapped, 1, 2);

var doubled: IntsToTupleFn = lambda (a, b) -&gt; (2*a, 2*b);
prettyPrint(&quot;doubled&quot;, doubled, 1, 2);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
swapped(1, 2) -&gt; (2, 1)
doubled(1, 2) -&gt; (2, 4)
</code></pre>
<hr />
<h3 id="aliases-are-syntactic-sugar"><a class="header" href="#aliases-are-syntactic-sugar">Aliases are Syntactic Sugar</a></h3>
<p>To be absolutely clear, Aliases are simply syntactic sugar as shown in the example above. They provide a mechanism for
reducing the amount of boilerplate code that may need to be written where full type annotations are explicitly required.
They also allow you to communicate some sort of &quot;intent&quot; where you would like to communicate the purpose of a value to
other developers (or your future self) without actually committing to defining a fully new custom type (though aliases 
should be used for this purpose with caution). For example, below you'll see an example of using aliases to indicate 
that different <code>int</code> values have different interpretations.</p>
<h4 id="fig-2-24"><a class="header" href="#fig-2-24"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">alias MPH : double
alias Hours : double # Arguably you should be using `duration::Duration`.
alias Miles : double

function timeTraveled(speed: MPH, distanceTraveled: Miles) -&gt; Hours {
  return distanceTraveled / speed;
}

var speed: MPH = 15.0;
var distance: Miles = 60.0;
print(timeTraveled(speed, distance));
</code></pre>
<p><em>Output:</em></p>
<pre><code>4.0
</code></pre>
<hr />
<h2 id="overuse-of-aliases-can-be-a-code-smell"><a class="header" href="#overuse-of-aliases-can-be-a-code-smell">Overuse of Aliases Can be a Code Smell</a></h2>
<div class="warning">
Keep in mind that excessive use of aliases can be a code smell. If you are using an alias to try to encode some semantic
distinction between values, it's very likely that you are writing highly bug-prone code as aliases do not provide any 
level of compile time verification that values of different alias types don't get accidentally conflated. 
</div>
<h4 id="fig-3-19"><a class="header" href="#fig-3-19"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var mySpeed: MPH = 15.0;
var myDistance: Miles = 60.0;

# Aliases provide zero compile-time protection from mistakenly passing these
# args out-of-order.
print(timeTraveled(myDistance, mySpeed));
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
0.25
</code></pre>
<hr />
<p>See <a href="static_typing/aliases/../user_defined_types/user_defined_types.generated_docs.html#compile-time-enforcement">User Defined Types</a> for an example of how to 
address this issue.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[0.007s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="aliases-are-not-a-new-type-declaration"><a class="header" href="#aliases-are-not-a-new-type-declaration">Aliases are <em>Not</em> a New Type Declaration</a></h1>
<p>It's important to know that, in general, defining an Alias does <em>not</em> declare a &quot;new type&quot;, instead it is just providing
a shorthand for referring to some type. With an Alias definition, you are simply defining an alternative, more 
convenient way to refer to a type that is semantically equivalent to typing out the explicit type itself.</p>
<p>The example below demonstrates how variables with types declared using equivalent aliases, will in fact type-check as
having the same type:</p>
<h4 id="fig-1-30"><a class="header" href="#fig-1-30"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">alias IntList1 : [int]
alias IntList2 : [int]

var i1: IntList1 = [1];
var i2: IntList2 = [2];
var i3: [int] = [3];

i2 = i3;   # &lt;-- IntList2 is equivalent to [int].
i1 = i2;   # &lt;-- IntList1 is equivalent to IntList2.

print(i1);
print(i2);
print(i3);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[3]
[3]
[3]
</code></pre>
<hr />
<h2 id="note-on-nominal-typing"><a class="header" href="#note-on-nominal-typing">Note on &quot;Nominal Typing&quot;</a></h2>
<p>Nominal typing can actually be very useful for enforcing maintenance of semantic interpretations of even simple data
types, and even for maintaining inter-field invariants of more complex structured data types. So, of course, Claro also 
provides a mechanism to define new, &quot;nominally typed&quot; type definitions. This will allow making a semantic distinction 
between two &quot;structurally equivalent&quot; types that have different names.</p>
<p>For more on this, see: <a href="static_typing/aliases/not_a_new_type_decl/../../user_defined_types/user_defined_types.generated_docs.html">User Defined Types</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="user-defined-types"><a class="header" href="#user-defined-types">User Defined Types</a></h1>
<p>Claro's type system already provides a very expansive expressive power to represent arbitrarily complex data structures,
so, technically speaking, there is no hard <em>requirement</em> for a user to ever define any new types in order write any
program. However, by using only the builtin primitive and collection types, you will not be able to leverage Claro's
static type validation to ensure that semantic differences between values with structurally equivalent types are 
actually maintained.</p>
<p>This section will attempt to clarify how you can make use of user defined types to enforce semantic constraints 
throughout your program.</p>
<h2 id="declaring-a-new-type"><a class="header" href="#declaring-a-new-type">Declaring a New Type</a></h2>
<p>The example below demonstrates the declaration of a new type that <strong>wraps</strong> <code>int</code>.</p>
<h4 id="fig-1-31"><a class="header" href="#fig-1-31"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Foo : int
</code></pre>
<hr />
<p>In fact, user defined types can wrap <em>any</em> type - even other user defined types:</p>
<h4 id="fig-2-25"><a class="header" href="#fig-2-25"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># The order of `newtype` declarations is unimportant.
newtype Baz : int
newtype Foo : Bar
newtype Bar : Baz
</code></pre>
<hr />
<h2 id="instantiating-an-instance-of-a-user-defined-type"><a class="header" href="#instantiating-an-instance-of-a-user-defined-type">Instantiating an Instance of a User Defined Type</a></h2>
<p>Claro automatically provides a one-arg constructor that allows the user defined type to be instantiated by wrapping the
declared type.</p>
<h4 id="fig-3-20"><a class="header" href="#fig-3-20"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var f = Foo(1);
print(f);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Foo(1)
</code></pre>
<hr />
<h2 id="user-defined-types-wrap-an-instance-of-another-type"><a class="header" href="#user-defined-types-wrap-an-instance-of-another-type">User Defined Types &quot;Wrap&quot; an Instance of Another Type</a></h2>
<p>Because Claro's builtin types already enable modelling any arbitrary data structure, the purpose of user defined types
is solely to &quot;wrap&quot; an existing type in a statically enforceable, semantic layer that distinguishes instances of the
user defined type, from the type that is being wrapped. As such, Claro does not do any automatic conversions from the
wrapped type to the unwrapped type.</p>
<p>So, although <code>newtype Foo : int</code> simply wraps <code>int</code>, it is not interchangeable with <code>int</code> and therefore operations like
<code>+</code> are not supported for <code>Foo</code> even though they are for <code>int</code>.</p>
<h4 id="fig-4-12"><a class="header" href="#fig-4-12"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Foo : int
var f = Foo(1);
print(f + 9);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">user_defined_types_EX4_example.claro:3: Invalid type: found &lt;Foo&gt;, but expected one of (&lt;int, long, float, double&gt;).
print(f + 9);
      ^
1 Error
</code></pre>
<hr />
<h2 id="unwrapping-a-user-defined-type"><a class="header" href="#unwrapping-a-user-defined-type">&quot;Unwrapping&quot; a User Defined Type</a></h2>
<p>The wrapped type can be accessed by explicitly using the builtin <code>unwrap()</code> function.</p>
<h4 id="fig-5-7"><a class="header" href="#fig-5-7"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Foo : int
var f = Foo(1);
print(unwrap(f) + 9);
</code></pre>
<p><em>Output:</em></p>
<pre><code>10
</code></pre>
<hr />
<h2 id="compile-time-enforcement"><a class="header" href="#compile-time-enforcement">Compile Time Enforcement</a></h2>
<p>In the <a href="static_typing/user_defined_types/../aliases/aliases.generated_docs.html#overuse-of-aliases-can-be-a-code-smell">Aliases section an example was given that demonstrates the pitfall of the overuse of aliases</a>.
One primary source of errors could be addressed by simply declaring a new type for each of <code>MPH</code>, <code>Hours</code>, and <code>Miles</code>.
In this case, this statically prevents accidentally passing args to the function out of order:</p>
<h4 id="fig-6-3"><a class="header" href="#fig-6-3"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype MPH : double
newtype Hours : double # Arguably you should be using `duration::Duration`.
newtype Miles : double

function timeTraveled(speed: MPH, distanceTraveled: Miles) -&gt; Hours {
  return Hours(unwrap(distanceTraveled) / unwrap(speed));
}

# Claro can identify this type mismatch.
print(timeTraveled(Miles(60.0), MPH(15.0)));
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">user_defined_types_EX6_example.claro:10: Invalid type:
	Found:
		Miles
	Expected:
		MPH
print(timeTraveled(Miles(60.0), MPH(15.0)));
                   ^^^^^^^^^^^
user_defined_types_EX6_example.claro:10: Invalid type:
	Found:
		MPH
	Expected:
		Miles
print(timeTraveled(Miles(60.0), MPH(15.0)));
                                ^^^^^^^^^
2 Errors
</code></pre>
<hr />
<p>The above error message would lead you to correct the order of arguments and thereby fix the problem:</p>
<h4 id="fig-7-1"><a class="header" href="#fig-7-1"><em>Fig 7:</em></a></h4>
<hr />
<pre><code class="language-claro">print(timeTraveled(MPH(15.0), Miles(60.0)));
</code></pre>
<p><em>Output:</em></p>
<pre><code>Hours(4.0)
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameterized-types"><a class="header" href="#parameterized-types">Parameterized Types</a></h1>
<p>Claro supports the definition of types that may be parameterized with a generic type so that they can be used to contain
arbitrary types. For example the following is a definition of a type <code>Maybe&lt;T&gt;</code> that has the generic type param <code>T</code>:</p>
<h4 id="fig-1-32"><a class="header" href="#fig-1-32"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Maybe&lt;T&gt; : oneof&lt;T, std::Error&lt;std::Nothing&gt;&gt;
</code></pre>
<hr />
<p>This type definition is useful for describing the generic concept of a value that may or may not be present, without
needing to define repeated declarations for each specific type that may or may not be present:</p>
<p><em>Note: Claro's error messaging is a work in progress - the below error message will be improved.</em></p>
<h4 id="fig-2-26"><a class="header" href="#fig-2-26"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var maybeInt: Maybe&lt;int&gt; = Maybe(10);
print(maybeInt);

var maybeStr = Maybe(&quot;hi&quot;);
print(maybeStr);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Maybe(10)
Maybe(hi)
</code></pre>
<hr />
<h2 id="generic-type-param-must-be-referenced-in-type-declaration"><a class="header" href="#generic-type-param-must-be-referenced-in-type-declaration">Generic Type Param Must be Referenced in Type Declaration</a></h2>
<div class="warning">
The generic type param must be referenced somewhere in the type definition or Claro will statically reject the 
definition with an explanation of the problem.
</div>
<h4 id="fig-3-21"><a class="header" href="#fig-3-21"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Invalid&lt;X&gt; : struct {row: int, col: int}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">Warning! The following declared symbols are unused! [X]
1 Error
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="concrete-type-inference"><a class="header" href="#concrete-type-inference">Concrete Type Inference</a></h1>
<p>Claro is able to automatically infer the type of <code>maybeStr</code> whenever it would be possible to do so. Generally speaking,
this is possible when the concrete type is actually referenced in the initialization.</p>
<h4 id="fig-1-33"><a class="header" href="#fig-1-33"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Maybe&lt;T&gt; : oneof&lt;T, std::Error&lt;std::Nothing&gt;&gt;

var maybeStr = Maybe(&quot;hi&quot;);
type(maybeStr);
print(maybeStr);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Maybe&lt;string&gt;
Maybe(hi)
</code></pre>
<hr />
<div class="warning">
It's not always possible to automatically infer the type of an instance of a parameterized type. In particular, the 
below example is impossible to automatically infer as the concrete type is not actually referenced in the 
initialization:
</div>
<p><em>Note: Claro's error messaging is a work in progress - the below error message will be improved.</em></p>
<h4 id="fig-2-27"><a class="header" href="#fig-2-27"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var maybeStr = Maybe(std::Error(std::Nothing));
print(maybeStr);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">concrete_type_inference_EX2_example.claro:1: Invalid Generic Procedure Call: For the call to the following generic procedure `Maybe$constructor` with the following signature:
		`function&lt;oneof&lt;T, [module at //stdlib:std]::Error&lt;Nothing&gt;&gt; -&gt; Maybe&lt;T&gt;&gt; Generic Over {T} Requiring Impls for Contracts {}`
	The output types cannot be fully inferred by the argument types alone. The output type must be contextually constrained by either a type annotation or a static cast.
var maybeStr = Maybe(std::Error(std::Nothing));
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1 Error
</code></pre>
<hr />
<p>In these situations Claro will require you to provide an explicit type annotation to disambiguate your intentions:</p>
<h4 id="fig-3-22"><a class="header" href="#fig-3-22"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var maybeStr: Maybe&lt;string&gt; = Maybe(std::Error(std::Nothing));
print(maybeStr);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Maybe(Error(Nothing))
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h1>
<p>Claro supports the definition of new types that contain recursive self-references. For example a binary tree structure
is a classic recursive data structure where each Node in the tree contains a left and right child that may either be
another Node or nothing. The below is the definition of a Node that can only hold ints:</p>
<h4 id="fig-1-34"><a class="header" href="#fig-1-34"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype IntNode : struct {
  val: int,
  left: oneof&lt;IntNode, std::Nothing&gt;,
  right: oneof&lt;IntNode, std::Nothing&gt;
}
</code></pre>
<hr />
<p>For example, the following initializes a simple tree with the root pointing to two children that have no children of 
their own:</p>
<h4 id="fig-2-28"><a class="header" href="#fig-2-28"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var tree =
  IntNode({
    val = 1,
    left = IntNode({val = 2, left = std::Nothing, right = std::Nothing}),
    right = IntNode({val = 3, left = std::Nothing, right = std::Nothing})
  });
print(tree);
</code></pre>
<p><em>Output:</em></p>
<pre><code>IntNode({val = 1, left = IntNode({val = 2, left = Nothing, right = Nothing}), right = IntNode({val = 3, left = Nothing, right = Nothing})})
</code></pre>
<hr />
<h2 id="parameterized-recursive-types"><a class="header" href="#parameterized-recursive-types">Parameterized Recursive Types</a></h2>
<p>Of course, the above <code>IntNode</code> definition is too constrained, so ideally we'd define a single Node type that's able to
represent trees of arbitrary data types. So, a better Node type definition looks like:</p>
<h4 id="fig-3-23"><a class="header" href="#fig-3-23"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Node&lt;T&gt; : struct {
  val: T,
  left: oneof&lt;Node&lt;T&gt;, std::Nothing&gt;,
  right: oneof&lt;Node&lt;T&gt;, std::Nothing&gt;
}
</code></pre>
<hr />
<p>Initialization looks exactly the same as in the concrete <code>IntNode</code> example above:</p>
<h4 id="fig-4-13"><a class="header" href="#fig-4-13"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">var tree =
  Node({
    val = 1,
    left = Node({val = 2, left = std::Nothing, right = std::Nothing}),
    right = Node({val = 3, left = std::Nothing, right = std::Nothing})
  });
print(tree);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Node({val = 1, left = Node({val = 2, left = Nothing, right = Nothing}), right = Node({val = 3, left = Nothing, right = Nothing})})
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="impossible-to-initialize-recursive-alias-type-definitions"><a class="header" href="#impossible-to-initialize-recursive-alias-type-definitions">Impossible-to-Initialize Recursive Alias Type Definitions</a></h1>
<div class="warning">
Some recursive type definitions are rejected at compile-time because they would be impossible to instantiate. 
</div>
<p>The issue with these type definitions is that the type recursion has no implicit &quot;bottom&quot; and implies an infinitely 
nested value. Because it's impossible to ever initialize a value composed of infinitely many values (you'd never finish
typing the code), Claro lets you know right away at compile time that the infinitely recursive type is rejected for 
being unusable.</p>
<p>The below recursive type definitions all trigger compile-time warnings from Claro indicating that these types aren't 
usable and are therefore illegal.</p>
<h4 id="fig-1-35"><a class="header" href="#fig-1-35"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype IllegalUnboundedRecursiveAlias : tuple&lt;int, IllegalUnboundedRecursiveAlias&gt;
newtype InfiniteRecursion : InfiniteRecursion
newtype PartialUnbounded : tuple&lt;PartialUnbounded, [PartialUnbounded]&gt;
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">Impossible Recursive Alias Type Definition: Alias `IllegalUnboundedRecursiveAlias` represents a type that is impossible to initialize in a finite number of steps. To define a recursive type you must ensure that there is an implicit &quot;bottom&quot; type to terminate the recursion. Try wrapping the Alias self-reference in some builtin empty-able collection:
	E.g.
		Instead of:
			alias BadType : tuple&lt;int, BadType&gt;
		Try something like:
			alias GoodType : tuple&lt;int, [GoodType]&gt;
1 Error
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h1>
<p>So far, through each code snippet you've seen, each variable has always included an explicit type declaration. This may
be useful for the sake of very explicit readability, however, these type annotations littering your entire codebase may
begin to feel very clunky and inconvenient - particularly when the type is very obvious to the reader, or sometimes if
it becomes very long to type (as the result of many layers of nested collections for example). In almost every case,
however, these explicit type annotations are optional in Claro!</p>
<p>Claro is smart enough to be able to infer the vast majority of types in any given program. So, unless you feel that the
type annotation being present makes the code more readable in a particular situation, then you can generally omit it
entirely! Please keep in mind, however, that while this may indeed make your code visually resemble something like
Python or JavaScript, Claro is 100% statically typed. Therefor, in this regard, Claro is much more alike
Rust/Java/Haskell than it is like any dynamic language. And, importantly, Claro is <em>not</em> an &quot;Optionally Statically
Typed&quot; language like Typescript - the compiler must always statically know the type of every value, you may at times
simply choose to avoid explicitly including the type annotation in the source code.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Instead of:</p>
<h4 id="fig-1-36"><a class="header" href="#fig-1-36"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var i: int = 1;
var b: boolean = true;
var l: [tuple&lt;int, boolean&gt;] = [(1, true), (2, false)];
</code></pre>
<hr />
<p>You could write:</p>
<h4 id="fig-2-29"><a class="header" href="#fig-2-29"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var i = 1;
var b = true;
var l = [(1, true), (2, false)];
</code></pre>
<hr />
<p>Each corresponding statement has exactly the same meaning. They differ only syntactically. Each variable is still
declared to have the same static type you'd expect.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="required-type-annotations"><a class="header" href="#required-type-annotations">Required Type Annotations</a></h1>
<p>There are same specific situations where Claro will require a type annotation to understand your intent. Note that these 
situations are not just a limitation of the compiler, even if Claro would somehow implicitly decide a type for you in 
these situations, your colleagues (or your future self) would struggle to comprehend what type was being inferred.</p>
<p>For clarity and correctness in the following situations, you will be required to write an explicit type annotation:</p>
<h3 id="procedure-signatures"><a class="header" href="#procedure-signatures">Procedure Signatures</a></h3>
<p>Most obvious is the fact that all <a href="type_inference/required_type_annotations/../../procedures.html">procedure</a> signatures must fully encode the types of any 
arguments and, if the procedure returns a value, its return type.</p>
<h4 id="fig-1-37"><a class="header" href="#fig-1-37"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">function add(lhs: int, rhs: int) -&gt; int {
  # ...
<span class="boring">  return lhs + rhs;
</span>}
</code></pre>
<hr />
<div class="warning">
<p>If you're thinking, <em>&quot;but sometimes I want to write procedures that can accept values of more than one type!&quot;</em>, then you
have a couple options:</p>
<ul>
<li>If you know the possible set of types ahead of time: use 
<a href="type_inference/required_type_annotations/../../static_typing/oneofs/oneofs.generated_docs.html"><code>oneof&lt;...&gt;</code></a></li>
<li>Otherwise: use <a href="type_inference/required_type_annotations/../../generics.generated_docs.html">generics</a></li>
</ul>
</div>
<h3 id="lambda-expressions-assigned-to-variables"><a class="header" href="#lambda-expressions-assigned-to-variables">Lambda Expressions assigned to variables</a></h3>
<p>As lambdas are just anonymous procedures, they must either be used in a context that already &quot;asserts&quot; the lambda's
signature, such as in this variable declaration:</p>
<h4 id="fig-2-30"><a class="header" href="#fig-2-30"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var add: function&lt;|int, int| -&gt; int&gt; = lambda (lhs, rhs) -&gt; lhs + rhs;
</code></pre>
<hr />
<p>Note: Claro does support an alternative syntax sugar to bake the type annotation directly into the lambda expression:</p>
<h4 id="fig-3-24"><a class="header" href="#fig-3-24"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var add = (lhs: int, rhs: int) -&gt; int { return lhs + rhs; };
</code></pre>
<hr />
<h3 id="initializing-empty-builtin-collections"><a class="header" href="#initializing-empty-builtin-collections">Initializing Empty Builtin Collections</a></h3>
<p>Claro would have no way of knowing what type the below list was intended to be without an explicit type annotation:</p>
<h4 id="fig-4-14"><a class="header" href="#fig-4-14"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">var l: [int] = [];
</code></pre>
<hr />
<h3 id="non-literal-tuple-subscript"><a class="header" href="#non-literal-tuple-subscript">Non-literal Tuple Subscript</a></h3>
<p>Unlike with literal integer tuple subscript indices, when you use a non-literal tuple subscript index value, you have
hidden the index from Claro's type inference behind a layer of indirection that Claro will not attempt to follow. In
these cases you'll be required to assert your intent via a runtime type cast:</p>
<h4 id="fig-5-8"><a class="header" href="#fig-5-8"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">var t = (1, &quot;one&quot;, 1.1);
var i = random::nextNonNegativeBoundedInt(random::create(), 3);

# This program crashes at runtime a third of the time...
var t_int = cast(int , t[i]);
print(t_int);
</code></pre>
<hr />
<div class="warning">
<p><strong>Warning</strong>: Claro allows this simply to avoid being too restrictive, but you should arguably take these runtime casts
as a code-smell and find a statically safe way to rewrite your code to avoid this sort of dynamic tuple subscripting.</p>
</div>
<h3 id="advanced-calls-to-generic-procedure-with-unconstrained-return-type"><a class="header" href="#advanced-calls-to-generic-procedure-with-unconstrained-return-type">(Advanced) Calls to Generic Procedure With Unconstrained Return Type</a></h3>
<p>When a generic return type can't be inferred from arg(s) referencing the same generic type, you must explicitly assert
the type that you intend for the procedure to return. </p>
<p>This is something that will likely only come up in more advanced usage of the language. Getting into this situation 
requires using multiple language features together in a rather intentional way, but for completeness here's an example 
of how this may happen:</p>
<h4 id="fig-6-4"><a class="header" href="#fig-6-4"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro">function assertVariant&lt;A, B, Asserted&gt;(o: oneof&lt;A, B&gt;) -&gt; oneof&lt;Asserted, std::Error&lt;std::Nothing&gt;&gt; {
  if (o instanceof Asserted) {
    return o;
  }
  return std::Error(std::Nothing);
}

var myOneof: oneof&lt;int, string&gt; = &quot;hello&quot;;

var assertedInt = cast(oneof&lt;int, std::Error&lt;std::Nothing&gt;&gt;, assertVariant(myOneof));
var assertedStr = cast(oneof&lt;string, std::Error&lt;std::Nothing&gt;&gt;, assertVariant(myOneof));

print(assertedInt);
print(assertedStr);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Error(Nothing)
hello
</code></pre>
<hr />
<p><em>See the <a href="type_inference/required_type_annotations/../../generics/generic_return_type_inference/generic_return_type_inference.generated_docs.html">Generic Return Type Inference</a>
section for more on this.</em></p>
<h3 id="any-ambiguously-typed-expression-passed-to-a-generic-function-arg-position"><a class="header" href="#any-ambiguously-typed-expression-passed-to-a-generic-function-arg-position">Any Ambiguously-Typed Expression Passed to a Generic Function Arg Position</a></h3>
<p>Because Claro monomorphizes <a href="type_inference/required_type_annotations/../../generics.generated_docs.html">generic procedures</a>, Claro must determine the called 
procedure's concrete types based on the types of the arguments. In the case that the type of an argument expression is
ambiguous, it must be explicitly annotated with a cast:</p>
<h4 id="fig-7-2"><a class="header" href="#fig-7-2"><em>Fig 7:</em></a></h4>
<hr />
<pre><code class="language-claro">consumer foo&lt;A&gt;(a: A) {
  # ...
<span class="boring">  print(a);
</span>}

var t = (1, &quot;one&quot;);
var i: int = # ...
<span class="boring">  random::nextNonNegativeBoundedInt(random::create(), 2);
</span>
foo(cast(int, t[i]));
</code></pre>
<hr />
<p>However, the effect of this can be limited in generic procedures with multiple arguments. The type cast may not be 
necessary if the type parameter is already constrained by another preceding argument:</p>
<h4 id="fig-8"><a class="header" href="#fig-8"><em>Fig 8:</em></a></h4>
<hr />
<pre><code class="language-claro">consumer apply&lt;A&gt;(a: A, c: consumer&lt;A&gt;) {
  c(a);
}

apply(1, x -&gt; { print(x + 10); });
</code></pre>
<p><em>Output:</em></p>
<pre><code>11
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedures"><a class="header" href="#procedures">Procedures</a></h1>
<p>All languages tend to have a way to encapsulate a block of logic in one place so that it can be reused throughout the
program. Generally, however, languages tend to provide only a single tool for this job, the function. The problem I see
with this is that not all functions in these languages are created equal - but yet they're all forced to share the same
structure which has some unfortunate implications. The general idea is straightforward: a function takes in some data,
manipulates it somehow, and possibly returns some data. However, not all functions take input, and not all of them
return data (&quot;void&quot; is not data... looking at you, Java and friends). To me, this is very unclear using a single
structure, functions, for meaningfully different purposes. Claro addresses this by getting specific. Claro provides
&quot;Procedures&quot; broken into a few sub-categories: Functions, Consumers, and Providers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>A Procedure that takes in same data <strong>and</strong> returns some data.</p>
<h4 id="fig-1-38"><a class="header" href="#fig-1-38"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">function add(x: int, y: int) -&gt; int {
    return x + y;
}

print(add(10, 5));
</code></pre>
<p><em>Output:</em></p>
<pre><code>15
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="consumers"><a class="header" href="#consumers">Consumers</a></h1>
<p>A Procedure that takes in some data but doesn't return any data.</p>
<h4 id="fig-1-39"><a class="header" href="#fig-1-39"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">consumer show(s: string, age: int, heightFt: int) {
    # String formatting.
    print(&quot;{s} is {age} years old and {heightFt}ish feet tall.&quot;);
}

# Calling the consumer. Syntactically, consumers are always used as statements,
# never as an expression (something that has a value).
show(&quot;Laura&quot;, 29, 5);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Laura is 29 years old and 5ish feet tall.
</code></pre>
<hr />
<div class="warning">
<p>Note: Consumers tend to be an inherent waste of computation time <strong>unless</strong> that consumer does some side-effecting
operation observable outside the program scope. So, it may be a useful hint that if you're reading code that includes a
call to a consumer, some I/O is very likely taking place (if not, you should delete the call entirely as it's a waste of
work).</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="providers"><a class="header" href="#providers">Providers</a></h1>
<p>A Procedure that takes in no data but returns some data.</p>
<h4 id="fig-1-40"><a class="header" href="#fig-1-40"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">provider getInt() -&gt; int {
    return 10;
}

print(getInt());
</code></pre>
<p><em>Output:</em></p>
<pre><code>10
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdas--first-class-procedures"><a class="header" href="#lambdas--first-class-procedures">Lambdas &amp; First Class Procedures</a></h1>
<p>Claro opens you up to taking full advantage of functional programming techniques by allowing you to assign Procedures to
variables and to pass them around as data, allowing you to hand them off to be called later. </p>
<h2 id="defining-lambdas"><a class="header" href="#defining-lambdas">Defining Lambdas</a></h2>
<p>Lambdas expressions look something like the examples below.</p>
<h4 id="fig-1-41"><a class="header" href="#fig-1-41"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var f: function&lt;int -&gt; int&gt; = x -&gt; x + 1;
var c: consumer&lt;int&gt; = x -&gt; { print(x); };
var p: provider&lt;int&gt; = () -&gt; 10;
</code></pre>
<hr />
<div class="warning">
<p><em><strong>Note</strong>: lambdas <a href="lambdas_and_first_class_procedures/../type_inference/required_type_annotations/required_type_annotations.generated_docs.html#lambda-expressions-assigned-to-variables">require explicit type annotations</a>
, but Claro does support an alternative syntax sugar to bake the type annotation directly into the lambda expression:</em></p>
</div>
<h4 id="fig-2-31"><a class="header" href="#fig-2-31"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var add = (lhs: int, rhs: int) -&gt; int { return lhs + rhs; };
</code></pre>
<hr />
<h2 id="first-class-procedure-references"><a class="header" href="#first-class-procedure-references">First Class Procedure References</a></h2>
<p>You may also reference named procedures as first-class data just like lambdas:</p>
<h4 id="fig-3-25"><a class="header" href="#fig-3-25"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">function add(x: int, y: int) -&gt; int {
  return x + y;
}

var applyBiConsumer =
    lambda (x: int, y: int, mapFn: function&lt;|int, int| -&gt; int&gt;) -&gt; {
        print(mapFn(x, y));
    };

# Pass a reference to the `add()` function as a first class arg.
applyBiConsumer(10, 5, add); #15.
</code></pre>
<p><em>Output:</em></p>
<pre><code>15
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdas-are-restricted-closures"><a class="header" href="#lambdas-are-restricted-closures">Lambdas are Restricted &quot;Closures&quot;</a></h1>
<p>A &quot;closure&quot; is an anonymous procedure that is able to capture long-lived references to the <strong>variables</strong> defined outside
the body of the lambda, importantly, keeping that reference even as the lambda itself leaves the scope. This is exactly 
how Python or Java lambdas work, for example.</p>
<p>Unfortunately, this leads to hard-to-understand code as you end up with &quot;spooky action at a distance&quot; where calling a
lambda can cause some faraway data to be changed without necessarily realizing or intending for that to be happening. 
This would be fatal for Claro's more advanced &quot;<strong>Fearless Concurrency</strong>&quot; goal, because it represents hidden mutable 
state which would invalidate Claro's goals of guaranteeing that multithreaded code unable to run into data races. </p>
<p>So, to address these issues, when lambdas reference variables in outer scopes, the variables are captured as a local 
copy of the <strong>current</strong> value referenced by that variable. <strong>Claro's Lambdas have no mechanism to mutate anything not 
passed in as an explicit argument, and they cannot carry any mutable state</strong>.</p>
<div class="warning">
<p>Read more about how Claro prevents data-races <a href="lambdas_and_first_class_procedures/lambda_closures/../../guaranteed_data_race_free/guaranteed_data_race_free.generated_docs.html">here</a>.</p>
</div>
<h3 id="static-validation-1"><a class="header" href="#static-validation-1">Static Validation</a></h3>
<p>Claro will statically validate that lambdas don't violate the above restrictions:</p>
<h4 id="fig-1-42"><a class="header" href="#fig-1-42"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var i = 0;
var f = (x: int) -&gt; int {
    i = x + i; # `i` is captured, and illegally updated.
    return i;
};
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">lambda_closures_EX1_example.claro:3: Illegal Mutation of Lambda Captured Variable: The value of all variables captured within a lambda context are final and may not be changed. This restriction ensures that lambdas do not lead to so-called &quot;spooky action at a distance&quot; and is essential to guaranteeing that Graph Procedures are data-race free by construction.
    i = x + i; # `i` is captured, and illegally updated.
    ^
Warning! The following declared symbols are unused! [f]
2 Errors
</code></pre>
<hr />
<h3 id="captured-variables-shadow-variables-in-the-outer-scope"><a class="header" href="#captured-variables-shadow-variables-in-the-outer-scope">Captured Variables &quot;Shadow&quot; Variables in the Outer Scope</a></h3>
<p>When a lambda captures a variable from the outer scope, the captured variable inside the lambda is effectively
completely independent from the original variable in the outer scope. It simply &quot;shadows&quot; the name of the outer scope
variable. In this way, lambdas are guaranteed to be safe to call in any threading context as thread-related ordering 
alone can't affect the value returned by the lambda:</p>
<h4 id="fig-2-32"><a class="header" href="#fig-2-32"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var i = 1;
var f = (x: int) -&gt; int {
    # This lambda captures a **copy** of the variable `i`.
    return x + i;
};

for (x in [0, 1, 5, 5]) {
  print(&quot;i:    {i}&quot;);
  print(&quot;f({x}): {f(x)}\n&quot;);
  i = i * 10;  # &lt;-- This update of `i` is not observed by the lambda.
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>i:    1
f(0): 1

i:    10
f(1): 2

i:    100
f(5): 6

i:    1000
f(5): 6
</code></pre>
<hr />
<h2 id="manually-emulating-traditional-closures"><a class="header" href="#manually-emulating-traditional-closures">Manually Emulating Traditional &quot;Closures&quot;</a></h2>
<p>While Claro's design decisions around Lambdas make sense in the name of enabling &quot;Fearless Concurrency&quot;, the 
restrictions may seem like they prevent certain design patterns that may be completely valid when used carefully in a
single-threaded context. But worry not! You can of course implement &quot;closure&quot; semantics yourself (albeit in a more C++
style with explicit variable captures).</p>
<h4 id="fig-3-26"><a class="header" href="#fig-3-26"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype ClosureFn&lt;State, Out&gt; : struct {
  state: State,
  fn: function&lt;State -&gt; Out&gt;
}

function callClosure&lt;State, Out&gt;(closureFn: ClosureFn&lt;State, Out&gt;) -&gt; Out {
  var toApply = unwrap(closureFn).fn;
  return toApply(unwrap(closureFn).state);
}

var mutList = mut [1];
var getAndIncrClosure: ClosureFn&lt;mut [int], int&gt; =
  ClosureFn({
    state = mutList,
    fn = l -&gt; {
      var res = l[0];
      l[0] = l[0] + 1; # Update the &quot;captured&quot; state.
      return res;
    }
  });

print(mutList);                        # mut [1]
print(callClosure(getAndIncrClosure)); # 1
print(callClosure(getAndIncrClosure)); # 2
print(callClosure(getAndIncrClosure)); # 3
# &quot;Spooky Action at a Distance&quot; mutating `mutList` on the lines above when
# `mutList` was never directly referenced.
print(mutList);                        # mut [4]
</code></pre>
<p><em>Output:</em></p>
<pre><code>mut [1]
1
2
3
mut [4]
</code></pre>
<hr />
<div class="warning">
<p><strong>Note</strong>: The beauty of this design is that even though Claro doesn't prevent you from emulating traditional &quot;closures&quot;
on your own if you so chose, Claro can still statically identify that this <code>ClosureFn&lt;State, Out&gt;</code> type is unsafe for
multithreaded contexts and will be able to prevent you from using this to create a data race! </p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Claro takes a very principled stance that all control flow in the language should be modeled in a way that is 
self-consistent within the type system - as such, Claro chooses not to model errors around &quot;throwing Exceptions&quot;. While 
many languages (e.g. Java/Python/C++/etc.) were designed around thrown exceptions as their error modeling tool, they all
suffer from the same antipattern that make it impossible to determine strictly from looking at a procedure signature
whether it's possible for the call to fail, and if so, what that failure might look like. This leads users into 
unnecessary digging to read implementation details to determine how and why certain unexpected error cases inevitably 
arise.</p>
<p>So, taking inspiration from many prior languages such as Rust, Haskell, and Go, Claro requires errors to be modeled
explicitly in procedures' signatures as possible return types so that all callers must necessarily either handle any 
potential errors, or explicitly ignore them or propagate them up the call stack.</p>
<h2 id="stderrort"><a class="header" href="#stderrort"><code>std::Error&lt;T&gt;</code></a></h2>
<p>Claro's 
<a href="https://github.com/JasonSteving99/claro-lang/blob/main/stdlib/std.claro_module_api" target="_blank">std</a>
module exports the following type definition:</p>
<h4 id="fig-1-43"><a class="header" href="#fig-1-43"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Error&lt;T&gt; : T
</code></pre>
<hr />
<p>This type is a trivial wrapper around any arbitrary type. Its power is in the special treatment that the compiler gives
to this type to power Claro's error handling functionality. But first, let's take a look at how a procedure might make
use of this type to represent states in practice - the below example demonstrates a function that models safe indexing
into a list:</p>
<h4 id="fig-2-33"><a class="header" href="#fig-2-33"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">atom IndexOutOfBounds
function safeGet&lt;T&gt;(l: [T], i: int) -&gt; oneof&lt;T, std::Error&lt;IndexOutOfBounds&gt;&gt; {
  if (i &lt; 0 or i &gt;= len(l)) {
    return std::Error(IndexOutOfBounds);
  }
  return l[i];
}

var l = [1, 2, 3];
match (safeGet(l, getRandomIndex())) {
  case _:std::Error&lt;IndexOutOfBounds&gt; -&gt; print(&quot;Index out of bounds!&quot;);
  case X                              -&gt; print(&quot;Successfully retrieved: {X}&quot;);
}
# ...
<span class="boring">provider getRandomIndex() -&gt; int {
</span><span class="boring">  random::forSeed(1)
</span><span class="boring">    |&gt; random::nextNonNegativeBoundedInt(^, 8)
</span><span class="boring">    |&gt; var i = ^;
</span><span class="boring">  return i;
</span><span class="boring">}
</span></code></pre>
<p><em>Output:</em></p>
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
Index out of bounds!
</code></pre>
<hr />
<p>To drive the example home, instead of wrapping an atom which doesn't provide any information beyond the description of
the error itself, the error could wrap a type that contains more information:</p>
<h4 id="fig-3-27"><a class="header" href="#fig-3-27"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">atom TooHigh
atom TooLow
newtype IndexOutOfBounds : struct {
  reason: oneof&lt;TooHigh, TooLow&gt;,
  index: int
}
function safeGet&lt;T&gt;(l: [T], i: int) -&gt; oneof&lt;T, std::Error&lt;IndexOutOfBounds&gt;&gt; {
  if (i &lt; 0) {
    return std::Error(IndexOutOfBounds({reason = TooLow, index = i}));
  } else if (i &gt;= len(l)) {
    return std::Error(IndexOutOfBounds({reason = TooHigh, index = i}));
  }
  return l[i];
}

var l = [1, 2, 3];
match (safeGet(l, getRandomIndex())) {
  case std::Error(ERR) -&gt;
    var unwrappedErr = unwrap(ERR);
    match (unwrappedErr.reason) {
      case _:TooHigh -&gt;
        print(&quot;Index {unwrappedErr.index} is too high!&quot;);
      case _:TooLow -&gt;
        print(&quot;Index {unwrappedErr.index} is too low!&quot;);
    }
  case X -&gt; print(&quot;Successfully retrieved: {X}&quot;);
}
# ...
<span class="boring">provider getRandomIndex() -&gt; int {
</span><span class="boring">  random::forSeed(1)
</span><span class="boring">    |&gt; random::nextNonNegativeBoundedInt(^, 8)
</span><span class="boring">    |&gt; var i = ^;
</span><span class="boring">  return i;
</span><span class="boring">}
</span></code></pre>
<p><em>Output:</em></p>
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
Index 5 is too high!
</code></pre>
<hr />
<p><strong>Continue on to the next section to learn about how Claro enables simple propagation of <code>std::Error&lt;T&gt;</code> values.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-propagation-via--operator"><a class="header" href="#error-propagation-via--operator">Error Propagation via <code>?=</code> Operator</a></h1>
<p>As mentioned in the previous section, the power of Claro's builtin <code>std::Error&lt;T&gt;</code> type comes from the special treatment
that the compiler gives to values of that type. Specifically, Claro gives you the ability to early-return an error value
from a procedure. If for some reason a procedure has no way of actually handling a potential error itself, it can opt to
delegate the handling of the error to any callers. This allows the procedure doing error propagation to be written to
handle only the &quot;happy path&quot;.</p>
<p>This example demonstrates a procedure that propagates potential errors to its callers:</p>
<h4 id="fig-1-44"><a class="header" href="#fig-1-44"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">atom IndexTooHigh
atom IndexTooLow
function safeGet&lt;T&gt;(l: [T], i: int)
  -&gt; oneof&lt;T, std::Error&lt;IndexTooHigh&gt;, std::Error&lt;IndexTooLow&gt;&gt; {
  # ...
<span class="boring">  if (i &lt; 0) {
</span><span class="boring">    return std::Error(IndexTooLow);
</span><span class="boring">  } else if (i &gt;= len(l)) {
</span><span class="boring">    return std::Error(IndexTooHigh);
</span><span class="boring">  }
</span><span class="boring">  return l[i];
</span>}

function getRandomPairFromList&lt;T&gt;(l: [T], rng: random::RandomNumberGenerator)
    -&gt; oneof&lt;tuple&lt;T, T&gt;, std::Error&lt;IndexTooHigh&gt;, std::Error&lt;IndexTooLow&gt;&gt; {
  # std::Error may propagate from either call to safeGet(...).
  var first: T ?= safeGet(l, random::nextNonNegativeBoundedInt(rng, 5));
  # Note the type annotation isn't necessary.
  var second ?= safeGet(l, random::nextNonNegativeBoundedInt(rng, 5));
  return (first, second);
}

var rng = random::forSeed(0);

var firstPair = getRandomPairFromList([1, 2, 3, 4], rng);
print(firstPair);
var secondPair = getRandomPairFromList([1, 2, 3, 4], rng);
print(secondPair);
</code></pre>
<p><em>Output:</em></p>
<pre><code>(1, 4)
Error(IndexTooHigh)
</code></pre>
<hr />
<div class="warning">
<p><strong>Note</strong>: The error propagation above doesn't allow the caller to know details about whether the error came from the 
first or second call to <code>safeGet()</code>. This may or may not be desirable - but the design space is left open to Claro users
to decide how they want to signal errors to best model the noteworthy states of their problem domain.</p>
</div>
<h2 id="-operator-drops-all-error-cases"><a class="header" href="#-operator-drops-all-error-cases"><code>?=</code> Operator Drops All Error Cases</a></h2>
<p>You can observe in the above example that the <code>?=</code> operator will propagate any <code>std::Error&lt;T&gt;</code> found on the 
right-hand-side of the assignment. So, as a result, the value that reaches the variable on the left-hand-side of the
assignment will drop all <code>std::Error&lt;T&gt;</code> variants from the <code>oneof&lt;...&gt;</code>. </p>
<p>Below, some examples are listed to indicate the resulting type of the <code>?=</code> operator:</p>
<h4 id="fig-2-34"><a class="header" href="#fig-2-34"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">atom A
</span><span class="boring">atom B
</span><span class="boring">atom C
</span><span class="boring">
</span>provider demoErrorPropagation() -&gt; oneof&lt;A, B, std::Error&lt;B&gt;, std::Error&lt;C&gt;&gt; {
  # When there would be multiple non-error variants, the result type remains a oneof&lt;...&gt;.
  var firstPotentialErr: oneof&lt;A, B, std::Error&lt;C&gt;&gt; = # ...
<span class="boring">    A;
</span>  var firstTypeDemo: oneof&lt;A, B&gt; ?= firstPotentialErr;
<span class="boring">  _ = firstTypeDemo;
</span>
  # When there would only be a single non-error variant, the result type is narrowed to a concrete type.
  var secondPotentialErr: oneof&lt;A, std::Error&lt;B&gt;, std::Error&lt;C&gt;&gt; = # ...
<span class="boring">    A;
</span>  var secondTypeDemo: A ?= secondPotentialErr;

  return secondTypeDemo;
}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Oftentimes, you'll find that some code patterns keep coming up over and over and you'll want to find same way to factor
out the major commonalities in logic from the minor specific details that you'd want to just plug in as needed. For
example, you might realize that you're writing loops to filter lists based on conditions all over your code; the only
difference between the implementation in any of these occurrences of filtering being the element types and the specific
condition. But because you want to filter lists of all kinds of types you might not immediately think you could write a
single function that could be called wherever filtering is needed. <strong>Enter Generics!</strong></p>
<h4 id="fig-1-45"><a class="header" href="#fig-1-45"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">function reduce&lt;A, B&gt;(l: [A], fn: function&lt;|B, A| -&gt; B&gt;, accum: B) -&gt; B {
  for (e in l) {
    accum = fn(accum, e);
  }
  return accum;
}
</code></pre>
<hr />
<p>The function <code>reduce&lt;A, B&gt;(...)</code> is defined to take a list of elements of some arbitrary (generic) type, <code>A</code>, and an 
accumulation function that takes in the current accumulated value, of type <code>B</code>, and the current element of that generic
type, <code>A</code>. In this example, the particular types <code>A</code> and <code>B</code> are &quot;unconstrained&quot;. The only constraint is the typical 
constraint that the given function's first arg must have the same type as the initial accumulated value, and the second
arg must have the same type as the elements of the reduced list.</p>
<p>So, the generic types take on the &quot;concrete&quot; types of the data that happens to be passed into the function's callsite:</p>
<h4 id="fig-2-35"><a class="header" href="#fig-2-35"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var sum: int = reduce([1, 2, 3, 4], lambda (accum, x) -&gt; accum + x, 0);

var totalChars: int =
  reduce(
    [&quot;Count&quot;, &quot;the&quot;, &quot;total&quot;, &quot;chars&quot;, &quot;in&quot;, &quot;these&quot;, &quot;strings&quot;],
    lambda (accum, s) -&gt; accum + len(s),
    0
  );

print(sum);
print(totalChars);
</code></pre>
<p><em>Output:</em></p>
<pre><code>10
32
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="contracts"><a class="header" href="#contracts">Contracts</a></h1>
<p>Consider the example of the generic function:</p>
<h4 id="fig-1-46"><a class="header" href="#fig-1-46"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">function filter&lt;A&gt;(l: [A], pred: function&lt;A -&gt; boolean&gt;) -&gt; [A] {
  # ...
<span class="boring">  return [a | a in l where pred(a)];
</span>}
</code></pre>
<hr />
<p>If you really squint, you might notice that there's very little information available in the body of the
<code>filter&lt;T&gt;(...)</code> function to tell you about the type <code>T</code>. As a result, you're unable to do much with values of such an
unconstrained generic type beyond passing the value along to another generic function accepting an unconstrained generic
arg, <em>or</em> putting it into some collection defined over the same generic type. This would be very limiting if this was
all that could be done with generics.</p>
<p><strong>Enter Contracts!</strong> It will take a bit of a buildup, but we should be able to write generic functions that will be able
to put constraints on the acceptable types, for example saying something like &quot;this procedure will accept any type, <code>T</code>,
for which the function <code>foo(arg1: T, arg2: T)</code> exists.&quot;</p>
<p>For example, we should be able to write the following generic function:</p>
<h4 id="fig-2-36"><a class="header" href="#fig-2-36"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">requires(Operators&lt;T&gt;)    # &lt;-- What is this `requires(...)`?
function sum&lt;T&gt;(l: [T]) -&gt; T {
    var res = l[0];
    var i = 0;
    while (++i &lt; len(l)) {
        res = Operators::add(res, l[i]); # &lt;-- What is this `Operators::add`?
    }
    return res;
}
</code></pre>
<hr />
<p>The function above has a new <code>requires(...)</code> clause in the signature which we haven't seen before. This is the mechanism
by which a function constrains the set of types that may be passed into this function to only types that definitely have
a certain associated procedure implementation existing. The <code>requires(...)</code> clause takes in a list of &quot;Contracts&quot; that
must be implemented over the generic type. In this case that contract's definition looks like:</p>
<h4 id="fig-3-28"><a class="header" href="#fig-3-28"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">contract Operators&lt;X&gt; {
    function add(lhs: X, rhs: X) -&gt; X;
}
</code></pre>
<hr />
<p>This Contract specifies a single function signature that any implementation of this Contract must implement. Other
Contracts may specify more than one signature, or even more than one generic type param. There are no restrictions on
where the generic Contract param(s) may be used in the procedure signatures, so it may even be included in the return
type as shown in the example above.</p>
<p>The only requirement on signatures is that each one <strong>must</strong> make use of <strong>each</strong> generic arg type listed in the
Contract's signature. This is mandatory as Claro looks up the particular implementations by inspecting the arg types
provided at the Contract procedure's call-sites.</p>
<h3 id="contracts-are-not-interfaces"><a class="header" href="#contracts-are-not-interfaces">Contracts are <em>Not</em> Interfaces</a></h3>
<p>Coming from an Object-Oriented background, you may be tempted to compare Contracts to &quot;Interfaces&quot;, but you'll find that
while they may be used to a similar effect, they are <em>not</em> the same thing. The intention of an &quot;Interface&quot; is to encode
subtyping relationships between types, whereas <strong>Claro has absolutely no notion of subtyping</strong>. All defined types are
strictly independent of one another. Claro asks you to simplify your mental model and simply think of Contracts as a
mechanism for encoding a required bit of functionality that needs to be implemented uniquely over values of unrelated,
arbitrary (generic) types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-contract"><a class="header" href="#implementing-a-contract">Implementing a Contract</a></h1>
<p>Simply defining a contract is not sufficient to actually be useful, however, since the definition itself doesn't provide
any logic. So, to actually <em>use</em> a Contract, we must implement it for a certain (set of) concrete type(s):</p>
<h4 id="fig-1-47"><a class="header" href="#fig-1-47"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">implement Operators&lt;int&gt; {
    function add(lhs: int, rhs: int) -&gt; int {
        return lhs + rhs;
    }
}

implement Operators&lt;string&gt; {
    function add(lhs: string, rhs: string) -&gt; string {
        return &quot;{lhs}{rhs}&quot;;
    }
}
</code></pre>
<hr />
<p>Now that you have implementations, you can either call them directly:</p>
<h4 id="fig-2-37"><a class="header" href="#fig-2-37"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">print(Operators::add(10, 20));
print(Operators::add(&quot;Hello, &quot;, &quot;world&quot;));
</code></pre>
<p><em>Output:</em></p>
<pre><code>30
Hello, world
</code></pre>
<hr />
<p>Or, even more valuable, you can also call the generic <code>sum</code> function from the 
<a href="generics/contracts/implementing_contracts/../contracts.generated_docs.html#fig-2">previous section</a> over concrete types <code>int</code> or <code>string</code> because the requirements are 
met for both!</p>
<h4 id="fig-3-29"><a class="header" href="#fig-3-29"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">print(sum([1, 2, 3]));
print(sum([&quot;a&quot;, &quot;bc&quot;, &quot;d&quot;]));
</code></pre>
<p><em>Output:</em></p>
<pre><code>6
abcd
</code></pre>
<hr />
<p>In this way, Claro's Contracts interact with Generics to create a powerful form of code reuse where custom behavior can
be uniquely dictated by type information. And, unlike in an Object-Oriented language, this code reuse did not rely on
creating any subtyping relationships.</p>
<h2 id="static-enforcement-of-requires-clauses"><a class="header" href="#static-enforcement-of-requires-clauses">Static Enforcement of <code>requires(...)</code> Clauses</a></h2>
<p>Of course, if you attempted to call a generic procedure that requires some contract(s) to be implemented, a compilation
error will be triggered if the contract was not actually implemented.</p>
<h4 id="fig-4-15"><a class="header" href="#fig-4-15"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"># Operators&lt;double&gt; hasn't been implemented, so this call will be rejected.
print(sum([1.0, 2.0, 3.0]));
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">Invalid Generic Procedure Call: For the call to the following generic procedure `sum` with the following signature:
		`function&lt;[T] -&gt; T&gt; Generic Over {T} Requiring Impls for Contracts {Operators$&lt;T&gt;}`
	No implementation of the required contract Operators$&lt;double&gt;.
1 Error
</code></pre>
<hr />
<p><em>Note: Claro's error messaging is a work in progress - the above error message will be improved.</em></p>
<h2 id="a-note-on-static-dispatch-via-monomorphization"><a class="header" href="#a-note-on-static-dispatch-via-monomorphization">A Note on Static Dispatch via &quot;Monomorphization&quot;</a></h2>
<p>As a performance note - even beyond the conceptual simplification benefits of avoiding dependence on subtyping
relationships to achieve custom behaviors, Claro also achieves performance gains through its ability at compile-time to
statically <em>know</em> which custom Contract implementation will be called. In the Object-Oriented approach, generally
speaking the procedure receiving an arg of an interface type doesn't know which particular implementation will be called
at runtime. This leads to the situation where a runtime &quot;dispatch table&quot;/&quot;vtable&quot; lookup is required to determine which
particular implementation to call for each particular value passed into the procedure. Claro is a &quot;monomorphizing&quot;
compiler, meaning that during compilation each Generic Procedure has a customized implementation codegen'd for each set
of concrete types the procedure is <em>actually</em> called with. In this way, there's no runtime dispatch overhead when types
are statically known (which is <strong>always</strong> true unless you're explicitly calling a generic procedure over a <code>oneof&lt;...&gt;</code>
type - but in this case you're consciously opting into dynamic dispatch overhead).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contracts-with-multiple-type-params"><a class="header" href="#contracts-with-multiple-type-params">Contracts with Multiple Type Params</a></h1>
<p>So far we've only demonstrated very simple contracts with over a single generic type parameter - however, there is no
hard restriction on the number of type parameters that a contract can reference. (Of course, typical software design 
principles still apply, a contract with many type params is probably going to be too complex to actually be used 
effectively in practice.)</p>
<p>Here's a contract defined over multiple type params:</p>
<h4 id="fig-1-48"><a class="header" href="#fig-1-48"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">atom IndexOutOfBounds
contract RandomAccess&lt;C, E&gt; {
  function read(collection: C, index: int) -&gt; oneof&lt;E, std::Error&lt;IndexOutOfBounds&gt;&gt;;
  function write(collection: C, index: int, elem: E) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt;;
}
</code></pre>
<hr />
<p>And an implementation of that contract:</p>
<h4 id="fig-2-38"><a class="header" href="#fig-2-38"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Node&lt;T&gt; : mut struct {
  val: T,
  next: oneof&lt;Node&lt;T&gt;, std::Nothing&gt;
}
function findNode&lt;T&gt;(head: Node&lt;T&gt;, index: int) -&gt; oneof&lt;Node&lt;T&gt;, std::Error&lt;IndexOutOfBounds&gt;&gt; {
  # ...
<span class="boring">  if (index &lt; 0) { return std::Error(IndexOutOfBounds); }
</span><span class="boring">  repeat (index) {
</span><span class="boring">    var next = unwrap(head).next;
</span><span class="boring">    if (next instanceof Node&lt;T&gt;) {
</span><span class="boring">      head = next;
</span><span class="boring">    } else {
</span><span class="boring">      return std::Error(IndexOutOfBounds);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">  return head;
</span>}

implement RandomAccess&lt;Node&lt;string&gt;, string&gt; {
  function read(head: Node&lt;string&gt;, index: int) -&gt; oneof&lt;string, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    var found ?= findNode(head, index);
    return unwrap(found).val;
  }
  function write(head: Node&lt;string&gt;, index: int, elem: string) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    var found ?= findNode(head, index);
    unwrap(found).val = elem;
    return std::OK;
  }
}
</code></pre>
<hr />
<div class="warning">
<p><strong>Note</strong>: Learn more about the <code>?=</code> operator used in the above example in the 
<a href="generics/contracts/multiple_type_params/../../../error_handling/error_handling.generated_docs.html">Error Handling</a> section.</p>
</div>
<h2 id="calling-a-contract-procedure-over-multiple-type-params"><a class="header" href="#calling-a-contract-procedure-over-multiple-type-params">Calling a Contract Procedure Over Multiple Type Params</a></h2>
<p>A contract procedure is always called in exactly the same way regardless of how many type parameters the contract was
defined over. </p>
<h4 id="fig-3-30"><a class="header" href="#fig-3-30"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">newtype Node&lt;T&gt; : mut struct {
</span><span class="boring">  val: T,
</span><span class="boring">  next: oneof&lt;Node&lt;T&gt;, std::Nothing&gt;
</span><span class="boring">}
</span><span class="boring">function findNode&lt;T&gt;(head: Node&lt;T&gt;, index: int) -&gt; oneof&lt;Node&lt;T&gt;, std::Error&lt;IndexOutOfBounds&gt;&gt; {
</span><span class="boring">  if (index &lt; 0) { return std::Error(IndexOutOfBounds); }
</span><span class="boring">  repeat (index) {
</span><span class="boring">    var next = unwrap(head).next;
</span><span class="boring">    if (next instanceof Node&lt;T&gt;) {
</span><span class="boring">      head = next;
</span><span class="boring">    } else {
</span><span class="boring">      return std::Error(IndexOutOfBounds);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">  return head;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">implement RandomAccess&lt;Node&lt;string&gt;, string&gt; {
</span><span class="boring">  function read(head: Node&lt;string&gt;, index: int) -&gt; oneof&lt;string, std::Error&lt;IndexOutOfBounds&gt;&gt; {
</span><span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    return unwrap(found).val;
</span><span class="boring">  }
</span><span class="boring">  function write(head: Node&lt;string&gt;, index: int, elem: string) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt; {
</span><span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    unwrap(found).val = elem;
</span><span class="boring">    return std::OK;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>var myLinkedList = Node(mut {val = &quot;head&quot;, next = Node(mut {val = &quot;middle&quot;, next = Node(mut {val = &quot;tail&quot;, next = std::Nothing})})});

for (i in [-1, 0, 1, 2, 3]) {
  var readRes =
    # Explicitly constrain the return type, so Claro knows which contract implementation to dispatch to.
    cast(
      oneof&lt;string, std::Error&lt;IndexOutOfBounds&gt;&gt;,
      RandomAccess::read(myLinkedList, i)
    );
  print(&quot;index {i}: {readRes}&quot;);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>index -1: Error(IndexOutOfBounds)
index 0: head
index 1: middle
index 2: tail
index 3: Error(IndexOutOfBounds)
</code></pre>
<hr />
<h2 id="limitation-of-the-above-contract-definition"><a class="header" href="#limitation-of-the-above-contract-definition">Limitation of the Above Contract Definition</a></h2>
<div class="warning">
<p>Notice that in the <a href="generics/contracts/multiple_type_params/multiple_type_params.generated_docs.html#calling-a-contract-procedure-over-multiple-type-params">prior example</a>, the call to 
<code>RandomAccess::read(...)</code> is wrapped in an explicit static <code>cast(...)</code>. If you read closely, you can see that this is 
because the arguments alone <strong>do not fully constrain the type that the call should return</strong> (it could be that you intend
to dispatch to some other impl <code>RandomAccess&lt;Node&lt;string&gt;, Foo&gt;</code>). Read more about this situation in
<a href="generics/contracts/multiple_type_params/../../../type_inference/required_type_annotations/required_type_annotations.generated_docs.html">Required Type Annotations</a>.</p>
</div>
<p>By allowing this sort of contract definition, Claro actually opens up a design space for contracts that can have 
multiple slight variations implemented, enabling callers can conveniently just get the return type that they need based
on context. </p>
<p>However, you could argue that this particular contract definition does not benefit from that flexibility. This contract
would arguably be more useful if <code>RandomAccess::read(...)</code> didn't have an ambiguous return type.</p>
<p><strong>Learn how to address this issue using <a href="generics/contracts/multiple_type_params/./implied_types/implied_types.generated_docs.html">&quot;Implied Types&quot;</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-implied-types"><a class="header" href="#advanced-implied-types">(Advanced) Implied Types</a></h1>
<p>In the previous section we 
<a href="generics/contracts/multiple_type_params/implied_types/../multiple_type_params.generated_docs.html#limitation-of-the-above-contract-definition">noticed a problem</a>
with the definition of the contract:</p>
<h4 id="fig-1-49"><a class="header" href="#fig-1-49"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">atom IndexOutOfBounds
contract RandomAccess&lt;C, E&gt; {
  function read(collection: C, index: int) -&gt; oneof&lt;E, std::Error&lt;IndexOutOfBounds&gt;&gt;;
  function write(collection: C, index: int, elem: E) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt;;
}
</code></pre>
<hr />
<p>Specifically, we decided that this contract definition is too unconstrained: knowing the types of the arguments in a
<code>RandomAccess::read(...)</code> call is insufficient to know which contract implementation the call should dispatch to.</p>
<p>To drive this point home, in the below example there are <strong>two implementations of the contract</strong> both over the same
collection type, but over different element types. In this definition of the contract, there's nothing stopping this
from happening.</p>
<h4 id="fig-2-39"><a class="header" href="#fig-2-39"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">newtype Node&lt;T&gt; : mut struct {
</span><span class="boring">  val: T,
</span><span class="boring">  next: oneof&lt;Node&lt;T&gt;, std::Nothing&gt;
</span><span class="boring">}
</span><span class="boring">function findNode&lt;T&gt;(head: Node&lt;T&gt;, index: int) -&gt; oneof&lt;Node&lt;T&gt;, std::Error&lt;IndexOutOfBounds&gt;&gt; {
</span><span class="boring">  # ...
</span><span class="boring">  if (index &lt; 0) { return std::Error(IndexOutOfBounds); }
</span><span class="boring">  repeat (index) {
</span><span class="boring">    var next = unwrap(head).next;
</span><span class="boring">    if (next instanceof Node&lt;T&gt;) {
</span><span class="boring">      head = next;
</span><span class="boring">    } else {
</span><span class="boring">      return std::Error(IndexOutOfBounds);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">  return head;
</span><span class="boring">}
</span><span class="boring">
</span>implement RandomAccess&lt;Node&lt;string&gt;, string&gt; {
  function read(head: Node&lt;string&gt;, index: int) -&gt; oneof&lt;string, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    return unwrap(found).val;
</span>  }
  function write(head: Node&lt;string&gt;, index: int, elem: string) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    unwrap(found).val = elem;
</span><span class="boring">    return std::OK;
</span>  }
}
implement RandomAccess&lt;Node&lt;string&gt;, int&gt; {
  function read(head: Node&lt;string&gt;, index: int) -&gt; oneof&lt;int, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    return len(unwrap(found).val);
</span>  }
  function write(head: Node&lt;string&gt;, index: int, elem: int) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    unwrap(found).val = &quot;{elem}&quot;;
</span><span class="boring">    return std::OK;
</span>  }
}
</code></pre>
<hr />
<p>As a result, any calls to the <code>RandomAccess::read(...)</code> function are inherently ambiguous, and require the return type
to be explicitly, statically constrained. Any unconstrained calls to this contract procedure would result in a 
compilation error where Claro tries to ask the user which contract implementation they actually intend to dispatch to:</p>
<h4 id="fig-3-31"><a class="header" href="#fig-3-31"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var myLinkedList = Node(mut {val = &quot;head&quot;, next = Node(mut {val = &quot;middle&quot;, next = Node(mut {val = &quot;tail&quot;, next = std::Nothing})})});

print(RandomAccess::read(myLinkedList, 1));
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">implied_types_EX3_example.claro:3: Ambiguous Contract Procedure Call: Calls to the procedure `RandomAccess$&lt;C, E&gt;::read` is ambiguous without an explicit type annotation to constrain the expected generic return type `oneof&lt;E, [module at //stdlib:std]::Error&lt;IndexOutOfBounds&gt;&gt;`.
print(RandomAccess::read(myLinkedList, 1));
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1 Error
</code></pre>
<hr />
<div class="warning">
<p><strong>Note</strong>: This ambiguity is an inherent feature of the <code>RandomAccess&lt;C, E&gt;</code> definition itself. <strong>Claro would still
produce a compilation error if there <em>happened</em> to only be a single implementation</strong> because another conflicting
implementation could be added at any time.</p>
</div>
<h2 id="statically-preventing-ambiguous-contract-definitions-with-implied-types"><a class="header" href="#statically-preventing-ambiguous-contract-definitions-with-implied-types">Statically Preventing Ambiguous Contract Definitions with Implied Types</a></h2>
<p>Of course, there's arguably very little reason for this particular contract to <strong>actually</strong> allow multiple 
implementations over the same collection type (the second implementation <code>RandomAccess&lt;Node&lt;string&gt;, int&gt;</code> above is very
contrived). So ideally this contract definition should statically encode a restriction on such implementations. It
should only be possible to implement this contract <strong>once</strong> for a given collection type - meaning that there would be
no more ambiguity on the return type of calls to <code>RandomAccess::read(...)</code>.</p>
<p>Thankfully, you can encode this restriction directly into contract definition using &quot;Implied Types&quot;:</p>
<h4 id="fig-4-16"><a class="header" href="#fig-4-16"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">atom IndexOutOfBounds

# Type `C` implies type `E`. There can only be a single RandomAccess impl for any given `C`.
contract RandomAccess&lt;C =&gt; E&gt; {
  function read(collection: C, index: int) -&gt; oneof&lt;E, std::Error&lt;IndexOutOfBounds&gt;&gt;;
  function write(collection: C, index: int, elem: E) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt;;
}
</code></pre>
<hr />
<p>The <strong>only</strong> change is in the declaration of the contract's generic type parameters: <code>&lt;C =&gt; E&gt;</code> (read: &quot;C implies E&quot;) 
was used instead of <code>&lt;C, E&gt;</code>. This explicitly declares to Claro that this implication <strong>must be maintained</strong> for all
types, <code>C</code>, over which the contract is implemented throughout the entire program. </p>
<p>As a result, it will now be a compilation error for two separate implementations <code>RandomAccess&lt;C, E1&gt;</code> and 
<code>RandomAccess&lt;C, E2&gt;</code> <em>(where <code>E1 != E2</code>)</em> to coexist, as this would violate the constraint that <code>C =&gt; E</code>.</p>
<p>So now, attempting to define the two implementations given in the <a href="generics/contracts/multiple_type_params/implied_types/implied_types.generated_docs.html#fig-2">previous example</a> would result in a 
compilation error:</p>
<h4 id="fig-5-9"><a class="header" href="#fig-5-9"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">newtype Node&lt;T&gt; : mut struct {
</span><span class="boring">  val: T,
</span><span class="boring">  next: oneof&lt;Node&lt;T&gt;, std::Nothing&gt;
</span><span class="boring">}
</span><span class="boring">function findNode&lt;T&gt;(head: Node&lt;T&gt;, index: int) -&gt; oneof&lt;Node&lt;T&gt;, std::Error&lt;IndexOutOfBounds&gt;&gt; {
</span><span class="boring">  # ...
</span><span class="boring">  if (index &lt; 0) { return std::Error(IndexOutOfBounds); }
</span><span class="boring">  repeat (index) {
</span><span class="boring">    var next = unwrap(head).next;
</span><span class="boring">    if (next instanceof Node&lt;T&gt;) {
</span><span class="boring">      head = next;
</span><span class="boring">    } else {
</span><span class="boring">      return std::Error(IndexOutOfBounds);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">  return head;
</span><span class="boring">}
</span><span class="boring">
</span>implement RandomAccess&lt;Node&lt;string&gt;, string&gt; {
  function read(head: Node&lt;string&gt;, index: int) -&gt; oneof&lt;string, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    return unwrap(found).val;
</span>  }
  function write(head: Node&lt;string&gt;, index: int, elem: string) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    unwrap(found).val = elem;
</span><span class="boring">    return std::OK;
</span>  }
}
implement RandomAccess&lt;Node&lt;string&gt;, int&gt; {
  function read(head: Node&lt;string&gt;, index: int) -&gt; oneof&lt;int, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    return len(unwrap(found).val);
</span>  }
  function write(head: Node&lt;string&gt;, index: int, elem: int) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    unwrap(found).val = &quot;{elem}&quot;;
</span><span class="boring">    return std::OK;
</span>  }
}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">Invalid Contract Implementation: The Contract you're attempting to implement is defined as RandomAccess$&lt;C =&gt; E&gt; which means that there can only be exactly one implementation of RandomAccess$ for the unconstrained type params C.
		However, the following conflicting implementations were found:
			RandomAccess$&lt;Node&lt;string&gt;, int&gt;
		AND
			RandomAccess$&lt;Node&lt;string&gt;, string&gt;
1 Error
</code></pre>
<hr />
<p>Now, by eliminating one of the implementations you fix the compilation error. In addition, <strong>you're now able to call
<code>RandomAccess::read(...)</code> without any ambiguity!</strong></p>
<h4 id="fig-6-5"><a class="header" href="#fig-6-5"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">newtype Node&lt;T&gt; : mut struct {
</span><span class="boring">  val: T,
</span><span class="boring">  next: oneof&lt;Node&lt;T&gt;, std::Nothing&gt;
</span><span class="boring">}
</span><span class="boring">function findNode&lt;T&gt;(head: Node&lt;T&gt;, index: int) -&gt; oneof&lt;Node&lt;T&gt;, std::Error&lt;IndexOutOfBounds&gt;&gt; {
</span><span class="boring">  # ...
</span><span class="boring">  if (index &lt; 0) { return std::Error(IndexOutOfBounds); }
</span><span class="boring">  repeat (index) {
</span><span class="boring">    var next = unwrap(head).next;
</span><span class="boring">    if (next instanceof Node&lt;T&gt;) {
</span><span class="boring">      head = next;
</span><span class="boring">    } else {
</span><span class="boring">      return std::Error(IndexOutOfBounds);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">  return head;
</span><span class="boring">}
</span><span class="boring">
</span># This is now the only implementation in the entire program.
implement RandomAccess&lt;Node&lt;string&gt;, string&gt; {
  function read(head: Node&lt;string&gt;, index: int) -&gt; oneof&lt;string, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    return unwrap(found).val;
</span>  }
  function write(head: Node&lt;string&gt;, index: int, elem: string) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt; {
    # ...
<span class="boring">    var found ?= findNode(head, index);
</span><span class="boring">    unwrap(found).val = elem;
</span><span class="boring">    return std::OK;
</span>  }
}

var myLinkedList = Node(mut {val = &quot;head&quot;, next = Node(mut {val = &quot;middle&quot;, next = Node(mut {val = &quot;tail&quot;, next = std::Nothing})})});

print(RandomAccess::read(myLinkedList, 1));
</code></pre>
<p><em>Output:</em></p>
<pre><code>middle
</code></pre>
<hr />
<h2 id="deciding-whether-to-use-implied-types-to-constrain-a-contracts-implementations-is-a-judgement-call"><a class="header" href="#deciding-whether-to-use-implied-types-to-constrain-a-contracts-implementations-is-a-judgement-call">Deciding Whether to Use Implied Types to Constrain a Contract's Implementations is a Judgement Call</a></h2>
<p>If you made it through this entire section, you should have a strong understanding of the purpose and value add of 
implied types. However, keep in mind that <strong>both unconstrained and implied types have their uses!</strong> In particular, the 
return type ambiguity demonstrated in this section may actually be used to good effect, particularly in the case of 
designing more &quot;fluent&quot; APIs.</p>
<p>Don't just assume that every contract should be defined using implied types. You should be applying good design
judgement to determine if and when to use this feature or to leave a contract's type parameters unconstrained.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-dispatch"><a class="header" href="#dynamic-dispatch">Dynamic Dispatch</a></h1>
<p>&quot;Dynamic Dispatch&quot; is a fancy term for a call to an overloaded procedure (one with multiple implementations whose 
signatures differ only in the types of args/return value) being routed (a.k.a. &quot;dispatched&quot;) to the appropriate
implementation <strong>based on type information solely available at runtime</strong>. </p>
<h2 id="tldr"><a class="header" href="#tldr">TLDR;</a></h2>
<p>The short version of this section is that Claro supports the following:</p>
<h4 id="fig-1-50"><a class="header" href="#fig-1-50"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">requires(Stringify&lt;T&gt;)
consumer prettyPrintList&lt;T&gt;(l: [T]) {
  for (e in l) {
    print(Stringify::displayStr(e));
  }
}

var elems: [oneof&lt;Foo, Bar, Buzz&gt;] = [Foo(1234), Bar(&quot;some string&quot;), Buzz(&quot;another&quot;)];
prettyPrintList(elems);
<span class="boring">
</span><span class="boring">contract Stringify&lt;T&gt; {
</span><span class="boring">  function displayStr(t: T) -&gt; string;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">newtype Foo : int
</span><span class="boring">implement Stringify&lt;Foo&gt; {
</span><span class="boring">  function displayStr(t: Foo) -&gt; string {
</span><span class="boring">    var boundingLine = strings::repeated(&quot;*&quot;, len(&quot;{unwrap(t)}&quot;) + len(&quot;* Foo() *&quot;));
</span><span class="boring">    return &quot;{boundingLine}\n* {t} *\n{boundingLine}&quot;;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">newtype Bar : string
</span><span class="boring">implement Stringify&lt;Bar&gt; {
</span><span class="boring">  function displayStr(t: Bar) -&gt; string {
</span><span class="boring">    var boundingLine = strings::repeated(&quot;-&quot;, len(unwrap(t)) + len(&quot;| Bar() |&quot;));
</span><span class="boring">    return &quot;{boundingLine}\n| {t} |\n{boundingLine}&quot;;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">newtype Buzz : string
</span><span class="boring">implement Stringify&lt;Buzz&gt; {
</span><span class="boring">  function displayStr(t: Buzz) -&gt; string {
</span><span class="boring">    var boundingLine = strings::repeated(&quot;#&quot;, len(unwrap(t)) + len(&quot;# Buzz() #&quot;));
</span><span class="boring">    return &quot;{boundingLine}\n# {t} #\n{boundingLine}&quot;;
</span><span class="boring">  }
</span><span class="boring">}
</span></code></pre>
<p><em>Output:</em></p>
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
*************
* Foo(1234) *
*************
--------------------
| Bar(some string) |
--------------------
#################
# Buzz(another) #
#################
</code></pre>
<hr />
<p><em>Feel free to ponder how this works. But keep reading if it's not immediately obvious what's going on here.</em></p>
<h2 id="by-comparison-to-object-oriented-programming"><a class="header" href="#by-comparison-to-object-oriented-programming">By Comparison to Object-Oriented Programming</a></h2>
<div class="warning">
<b>This entire section is intended to build up your intuition for Claro's approach to Dynamic Dispatch by comparing and
contrasting with Java.</b>
<p><a href="generics/contracts/dynamic_dispatch/dynamic_dispatch.generated_docs.html#dynamic-dispatch">Skip ahead TODO(steving) Add link</a> if you're already familiar with the concept of Dynamic Dispatch,
or keep reading for something of a deep dive.</p>
</div>
<p>Claro is truly a procedural language, and so is philosophically opposed to the personification of data that is a
fundamental property of &quot;Object-Oriented&quot; programming (OOP) languages like Java/Python/C++/etc. So, you won't find
anything resembling &quot;Objects&quot; or &quot;Classes&quot; in Claro. Additionally, Claro is philosophically opposed to the complexity of
inheritance, so again Claro's type system does not support it.</p>
<p>However, though Claro takes issue with the path OOP takes to achieve it, the paradigm provides some obviously useful 
abstractions that help programmers write very expressive code. Of particular interest in this section is the ability to 
write code that treats values of distinct types <em>interchangeably</em> for the sake of dispatching to procedures that are 
known to be implemented over each of the distinct types in question.</p>
<p>In a language like Java, you'll accomplish this either by using <em>interfaces</em>, or by creating <em>subtype relationships 
between types using inheritance</em>.</p>
<h3 id="using-an-interface-type-as-a-procedure-arg-in-an-oop-language"><a class="header" href="#using-an-interface-type-as-a-procedure-arg-in-an-oop-language">Using an Interface &quot;Type&quot; as a Procedure Arg (<em>in an OOP language</em>)</a></h3>
<p>For example, the below <strong>Java</strong> code defines an interface with a single &quot;method&quot; that three classes implement.</p>
<h4 id="fig-2-40"><a class="header" href="#fig-2-40"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-java">/*** JAVA ***/
<span class="boring">import java.util.List;
</span><span class="boring">import java.util.ArrayList;
</span><span class="boring">import java.lang.StringBuilder;
</span><span class="boring">
</span>interface Stringify {
  String displayStr();
}
<span class="boring">
</span>class Foo implements Stringify {
  // ...
<span class="boring">  private final int wrapped;
</span><span class="boring">  public Foo(int wrapped) {
</span><span class="boring">    this.wrapped = wrapped;
</span><span class="boring">  }
</span><span class="boring">
</span>  @Override
  public String displayStr() {
    // ...
<span class="boring">    String boundingLine = Util.repeated('*', String.valueOf(this.wrapped).length() + &quot;* Foo() *&quot;.length());
</span><span class="boring">    return String.format(&quot;%s\n* Foo(%s) *\n%s&quot;, boundingLine, this.wrapped, boundingLine);
</span>  }
}
<span class="boring">
</span>class Bar implements Stringify {
  // ...
<span class="boring">  private final String wrapped;
</span><span class="boring">  public Bar(String wrapped) {
</span><span class="boring">    this.wrapped = wrapped;
</span><span class="boring">  }
</span><span class="boring">
</span>  @Override
  public String displayStr() {
    // ...
<span class="boring">    String boundingLine = Util.repeated('-', this.wrapped.length() + &quot;| Bar() |&quot;.length());
</span><span class="boring">    return String.format(&quot;%s\n| Foo(%s) |\n%s&quot;, boundingLine, this.wrapped, boundingLine);
</span>  }
}
<span class="boring">
</span>class Buzz implements Stringify {
  // ...
<span class="boring">  private final String wrapped;
</span><span class="boring">  public Buzz(String wrapped) {
</span><span class="boring">    this.wrapped = wrapped;
</span><span class="boring">  }
</span><span class="boring">
</span>  @Override
  public String displayStr() {
    // ...
<span class="boring">    String boundingLine = Util.repeated('#', this.wrapped.length() + &quot;# Buzz() #&quot;.length());
</span><span class="boring">    return String.format(&quot;%s\n# Buzz(%s) #\n%s&quot;, boundingLine, this.wrapped, boundingLine);
</span>  }
}
<span class="boring">
</span><span class="boring">class Util {
</span><span class="boring">  public static String repeated(char c, int n) {
</span><span class="boring">    StringBuilder sb = new StringBuilder();
</span><span class="boring">    for (; n &gt; 0; n--) {
</span><span class="boring">      sb.append(c);
</span><span class="boring">    }
</span><span class="boring">    return sb.toString();
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span></code></pre>
<hr />
<p>And so a <strong>Java</strong> programmer can write a method that accepts an argument of type <code>Stringify</code>... but in <strong>Java</strong> parlance
any type that <em>implements</em> the <code>Stringify</code> interface can be considered a <strong>subtype</strong> of <code>Stringify</code> and passed in its 
place:</p>
<h4 id="fig-3-32"><a class="header" href="#fig-3-32"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-java">/*** JAVA ***/
public class Demo {
  public static void main(String... args) {
    // Foo, Bar, and Buzz are all &quot;subtypes&quot; of Stringify.
    prettyPrint(new Foo(1234));
    prettyPrint(new Bar(&quot;some string&quot;));
    prettyPrint(new Buzz(&quot;another&quot;));
  }

  static void prettyPrint(Stringify x) {
    System.out.println(x.displayStr());
  }
}
</code></pre>
<hr />
<p>This is a very convenient abstraction. However, in Java this <strong>single</strong> method implementation must handle multiple 
possible concrete subtypes of <code>Stringify</code> (in this case <code>Foo</code>, <code>Bar</code>, and <code>Buzz</code>). Java addresses this by dispatching to
the correct implementation of the <code>displayStr()</code> method <strong>at runtime</strong>, by dynamically checking the actual concrete type
of the object currently being handled. <strong>This is already an example of Dynamic Dispatch. In Java, Dynamic Dispatch
is the norm</strong>.</p>
<h3 id="requiring-a-contract-to-be-implemented-over-generic-type-params-in-claro"><a class="header" href="#requiring-a-contract-to-be-implemented-over-generic-type-params-in-claro">Requiring a Contract to Be Implemented Over Generic Type Params (In Claro)</a></h3>
<p>But subtyping is by no means essential for this to be possible. By now you've already seen that 
<a href="generics/contracts/dynamic_dispatch/../contracts.generated_docs.html">Contracts</a> provide a mechanism to express the same thing without resorting to creating
any subtyping relationships between types.</p>
<h4 id="fig-4-17"><a class="header" href="#fig-4-17"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">#### CLARO ####
prettyPrint(Foo(1234));
prettyPrint(Bar(&quot;some string&quot;));
prettyPrint(Buzz(&quot;another&quot;));

requires(Stringify&lt;T&gt;)
consumer prettyPrint&lt;T&gt;(t: T) {
  print(Stringify::displayStr(t));
}
<span class="boring">
</span><span class="boring">contract Stringify&lt;T&gt; {
</span><span class="boring">  function displayStr(t: T) -&gt; string;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">newtype Foo : int
</span><span class="boring">implement Stringify&lt;Foo&gt; {
</span><span class="boring">  function displayStr(t: Foo) -&gt; string {
</span><span class="boring">    var boundingLine = strings::repeated(&quot;*&quot;, len(&quot;{unwrap(t)}&quot;) + len(&quot;* Foo() *&quot;));
</span><span class="boring">    return &quot;{boundingLine}\n* {t} *\n{boundingLine}&quot;;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">newtype Bar : string
</span><span class="boring">implement Stringify&lt;Bar&gt; {
</span><span class="boring">  function displayStr(t: Bar) -&gt; string {
</span><span class="boring">    var boundingLine = strings::repeated(&quot;-&quot;, len(unwrap(t)) + len(&quot;| Bar() |&quot;));
</span><span class="boring">    return &quot;{boundingLine}\n| {t} |\n{boundingLine}&quot;;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">newtype Buzz : string
</span><span class="boring">implement Stringify&lt;Buzz&gt; {
</span><span class="boring">  function displayStr(t: Buzz) -&gt; string {
</span><span class="boring">    var boundingLine = strings::repeated(&quot;#&quot;, len(unwrap(t)) + len(&quot;# Buzz() #&quot;));
</span><span class="boring">    return &quot;{boundingLine}\n# {t} #\n{boundingLine}&quot;;
</span><span class="boring">  }
</span><span class="boring">}
</span></code></pre>
<p><em>Output:</em></p>
<pre><code>*************
* Foo(1234) *
*************
--------------------
| Bar(some string) |
--------------------
#################
# Buzz(another) #
#################
</code></pre>
<hr />
<p>And additionally, as Claro's 
<a href="generics/contracts/dynamic_dispatch/../implementing_contracts/implementing_contracts.generated_docs.html#a-note-on-static-dispatch-via-monomorphization">generic procedures are &quot;monomorphized&quot;</a>,
there is actually <strong>no Dynamic Dispatch going on in the above example</strong>. And when you stop and think about it, why would
there be? As a human looking at the three calls to <code>prettyPrint(...)</code>, there's zero uncertainty of the types in 
question. Unlike in the Java case, the Claro compiler actually takes advantage of this type information as well to 
generate code that <strong>statically dispatches</strong> to the correct implementations without requiring any runtime type checks.</p>
<h3 id="a-not-so-brief-aside-on-the-limitations-of-subtyping"><a class="header" href="#a-not-so-brief-aside-on-the-limitations-of-subtyping">A (Not So) Brief Aside on the Limitations of Subtyping</a></h3>
<p>You may be thinking that Java's use of subtyping makes the language simpler because it allows you to avoid the use of
Generics, but this is debatable at best. Consider a very slightly modified version of the above <code>prettyPrint()</code> function
that instead takes two arguments:</p>
<h4 id="fig-5-10"><a class="header" href="#fig-5-10"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-java">/*** JAVA ***/
public class Demo {
  public static void main(String... args) {
    // Java allows **both** of these calls - whether you want this or not.
    prettyPrintPair(new Foo(1234), new Foo(56678));
    prettyPrintPair(new Foo(1234), new Bar(&quot;some string&quot;));
  }

  static void prettyPrintPair(Stringify x, Stringify y) {
    System.out.println(&quot;First:&quot; + x.displayStr());
    System.out.println(&quot;Second:&quot; + x.displayStr());
  }
}
</code></pre>
<hr />
<p>As it's currently defined, there's nothing requiring the two arguments to <em>actually</em> have the same type. In this trivial
example, that may be fine, but if I were to actually want to ensure that two arguments both implement an interface 
<strong><em>and</em></strong> they both actually have the same type, then I'm out of luck - <strong>there's no way to statically encode this 
constraint in Java!</strong></p>
<p>In Claro, you would simply write:</p>
<h4 id="fig-6-6"><a class="header" href="#fig-6-6"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro">#### CLARO ####
requires(Stringify&lt;T&gt;)
consumer prettyPrintPair&lt;T&gt;(x: T, y: T) {
  print(&quot;First:\n{Stringify::displayStr(x)}&quot;);
  print(&quot;Second:\n{Stringify::displayStr(y)}&quot;);
}
</code></pre>
<hr />
<p>And it will be a compilation error to pass arguments of different types:</p>
<h4 id="fig-7-3"><a class="header" href="#fig-7-3"><em>Fig 7:</em></a></h4>
<hr />
<pre><code class="language-claro">#### CLARO ####
prettyPrintPair(Foo(1234), Bar(&quot;some string&quot;));
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">dynamic_dispatch_EX7_example.claro:2: Invalid type:
	Found:
		Bar
	Expected:
		Foo
prettyPrintPair(Foo(1234), Bar(&quot;some string&quot;));
                           ^^^^^^^^^^^^^^^^^^
1 Error
</code></pre>
<hr />
<p>But yet it will still be completely valid to pass arguments of the same type just like we wanted:</p>
<h4 id="fig-8-1"><a class="header" href="#fig-8-1"><em>Fig 8:</em></a></h4>
<hr />
<pre><code class="language-claro">#### CLARO ####
prettyPrintPair(Foo(1234), Foo(5678));
print(&quot;&quot;);
prettyPrintPair(Bar(&quot;some string&quot;), Bar(&quot;another&quot;));
</code></pre>
<p><em>Output:</em></p>
<pre><code>First:
*************
* Foo(1234) *
*************
Second:
*************
* Foo(5678) *
*************

First:
--------------------
| Bar(some string) |
--------------------
Second:
----------------
| Bar(another) |
----------------
</code></pre>
<hr />
<p>And for the sake of completeness, Claro's generics <em>also</em> allow you to explicitly express that you would like to allow 
both arguments to potentially have different types:</p>
<h4 id="fig-9"><a class="header" href="#fig-9"><em>Fig 9:</em></a></h4>
<hr />
<pre><code class="language-claro">requires(Stringify&lt;T&gt;, Stringify&lt;V&gt;)
consumer prettyPrintPair&lt;T, V&gt;(x: T, y: V) {
  print(&quot;First:\n{Stringify::displayStr(x)}&quot;);
  print(&quot;Second:\n{Stringify::displayStr(y)}&quot;);
}

prettyPrintPair(Foo(1234), Bar(&quot;some string&quot;));
</code></pre>
<hr />
<p><em>*For the sake of transparency, as Claro's a WIP, there's actually currently an open compiler regression
that broke this functionality at the moment. TODO(steving) Fix this.</em></p>
<div class="warning">
<p><strong>HOT TAKE:</strong> While Java's support for subtyping may <strong><em>seem</em></strong> like a powerful tool (and sometimes it really is 
convenient), it's actually explicitly <strong><em>taking away type information</em></strong>. You in fact end up with a 
<strong><em>less expressive</em></strong> language as a result of depending on subtyping.</p>
</div>
<h2 id="values-of-unknown-type"><a class="header" href="#values-of-unknown-type">Values Of Unknown Type</a></h2>
<p>So far we've seen that Claro programs do not need to resort to Dynamic Dispatch in situations where the types are
actually statically guaranteed to be fixed. However, it's not that difficult to conceive of a situation where a specific
type cannot be known until runtime. </p>
<p>For example, consider a simple game where different units are dynamically created throughout the course of gameplay. It 
would be very convenient for the game to be able to implement drawing arbitrary units without being forced to resort to 
painstakingly hand-write rendering logic for each unit explicitly. In fact, the below video demonstrates a simple
Asteroids game written in Claro that accomplishes exactly that:</p>
<script async id="asciicast-633650" src="https://asciinema.org/a/633650.js" data-preload="true" data-start-at="9" data-autoplay="true" data-loop="true"></script>
<p>The game's implementation contains a function with the following signature that fully handles the game's rendering logic
(see the game's full implementation 
<a href="https://github.com/JasonSteving99/claro-lang/blob/d6177ff8719e894f709c42811bd0b7f0a3d6c4d9/examples/claro_programs/asteroids.claro#L121-L123">here</a>):</p>
<h4 id="fig-10"><a class="header" href="#fig-10"><em>Fig 10:</em></a></h4>
<hr />
<pre><code class="language-claro">contract Unit&lt;T&gt; {
  consumer move(t: T);
  function hasSpeedBoost(t: T) -&gt; boolean;
}

contract Render&lt;T&gt; {
  function render(t: T) -&gt; char;
  function getLoc(t: T) -&gt; Location;
}

requires(Unit&lt;T&gt;, Render&lt;T&gt;)
function gameTick&lt;T&gt;(gameUnits: mut [T], gameBoard: [mut [char]], spaceship: Spaceship, onlyUnitsWSpeedBoost: boolean)
    -&gt; tuple&lt;GameOverStatus, ExplosionCount&gt; {
<span class="boring">  # The full implementation is too long for these docs. For the full implementation, see:
</span><span class="boring">  # See https://github.com/JasonSteving99/claro-lang/blob/d6177ff8719e894f709c42811bd0b7f0a3d6c4d9/examples/claro_programs/asteroids.claro#L121-L123
</span>  # ...
  # Update unit locations.
  for (unit in gameUnits) {
    # ...
    Unit::move(unit);
  }
  # ...
  # Populate gameBoard.
  for (unit in gameUnits) {
    # ...
    gameBoard[loc.r][loc.c] = Render::render(unit);
  }
  # ...
}
</code></pre>
<hr />
<p>Looking more closely, the function accepts an argument <code>gameUnits: mut [T]</code> that contains all of the units, including
the asteroids, the player's ship, and any missiles that the player fired. This function is able to actually handle all
of these unit types without the programmer needing to hardcode any specific details about them explicitly because of the
<code>requires(Unit&lt;T&gt;, Render&lt;T&gt;)</code> constraint on the function that ensures that whatever is inside the <code>gameUnits</code> list,
all elements will certainly implement the specified contracts. As a result, the function is able to treat all elements
within the <code>gameUnits</code> list interchangeably, even though it has no knowledge whatsoever of what types are actually
represented within. </p>
<p>To make things even more interesting, the call (see 
<a href="https://github.com/JasonSteving99/claro-lang/blob/d6177ff8719e894f709c42811bd0b7f0a3d6c4d9/examples/claro_programs/asteroids.claro#L289">full source</a>
) to the <code>gameTick()</code> function, passes a <code>gameUnits</code> list defined to contain various different unit types:</p>
<h4 id="fig-11"><a class="header" href="#fig-11"><em>Fig 11:</em></a></h4>
<hr />
<pre><code class="language-claro">var gameUnits: mut [oneof&lt;Asteroid, Missile, Spaceship&gt;];
# ...
var gameTickRes = gameTick(gameUnits, ...);
</code></pre>
<hr />
<p>This goes to demonstrate that Claro is smart enough to actually understand that the type
<code>oneof&lt;Asteroid, Missile, Spaceship&gt;</code> satisfies the <code>requires(Unit&lt;T&gt;, Render&lt;T&gt;)</code> constraint, because each variant
implements the required contract (if any didn't, the call would be rejected with a compilation error).</p>
<p>This is Dynamic Dispatch! Because the call was made over types that can't be known until runtime, Claro generates code
that will perform the necessary type checks to dispatch to the appropriate procedures at runtime.</p>
<h2 id="dynamic-dispatch-is-rare"><a class="header" href="#dynamic-dispatch-is-rare">Dynamic Dispatch is Rare</a></h2>
<p>If you've made it this far, then congrats! You should have a deep understanding of Dynamic Dispatch in Claro! </p>
<p>The last thing to mention is that Dynamic Dispatch is <strong>very intentionally</strong> something that you have to explicitly opt
into in Claro. It is slower and more complicated than the typical Static Dispatch, and Claro has been carefully designed
to make Dynamic Dispatch a rare occurrence as it's actually only necessary in very specific, limited situations. Your
takeaway from this section should be that while it is very simple to achieve Dynamic Dispatch in Claro, it is actually
not a very common situation that you are very likely to run into on a regular basis. But when it does, Claro makes your
life easy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-return-type-inference"><a class="header" href="#generic-return-type-inference">Generic Return Type Inference</a></h1>
<p>One very interesting capability that you get from the combination of Claro's bidirectional type inference and generics
is the ability to infer which Contract implementation to defer to based on the expected/requested return type at a
procedure call-site. Let's get more specific.</p>
<h4 id="fig-1-51"><a class="header" href="#fig-1-51"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">contract Index&lt;T, R&gt; {
    function get(l: T, ind: int) -&gt; R;
}

implement Index&lt;[int], int&gt; {
    function get(l: [int], ind: int) -&gt; int {
        return l[ind];
    }
}

atom IndexOutOfBounds
newtype SafeRes&lt;T&gt; : oneof&lt;T, std::Error&lt;IndexOutOfBounds&gt;&gt;

implement Index&lt;[int], SafeRes&lt;int&gt;&gt; {
    function get(l: [int], ind: int) -&gt; SafeRes&lt;int&gt; {
        if (ind &gt;= 0 and ind &lt; len(l)) {
            return SafeRes(l[ind]);
        }
        return SafeRes(std::Error(IndexOutOfBounds));
    }
}
</code></pre>
<hr />
<p>For the above implementations of <code>Index&lt;T, R&gt;</code>, you'll notice that each function, <code>Index::get</code>, only differs in its
return type but not in the arg types. So, Claro must determine which implementation to defer to by way of the
contextually expected return type. This, I believe leads to some very convenient ergonomics for configurability, though
the onus for &quot;appropriate&quot; use of this feature is a design decision given to developers.</p>
<h4 id="fig-2-41"><a class="header" href="#fig-2-41"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var l = [1,2,3];

var unsafeRes: int = Index::get(l, 1);
var safeRes: SafeRes&lt;int&gt; = Index::get(l, 1);

print(unsafeRes);
print(safeRes);

safeRes = Index::get(l, 10);
print(safeRes);

# Out of bounds runtime err.
# unsafeRes: int = Index::get(l, 10);
</code></pre>
<p><em>Output:</em></p>
<pre><code>2
SafeRes(2)
SafeRes(Error(IndexOutOfBounds))
</code></pre>
<hr />
<h2 id="ambiguous-calls"><a class="header" href="#ambiguous-calls">Ambiguous Calls</a></h2>
<p>As described in further detail in the section on 
<a href="generics/generic_return_type_inference/../../type_inference/required_type_annotations/required_type_annotations.generated_docs.html">Required Type Annotations</a>,
certain generic procedures that return a value of a generic type may require the call to be explicitly constrained by
context. In particular, this will be the case when the generic type does not appear in any of the procedure's declared
arguments. </p>
<p>For example, calling the above <code>Index::get</code> Contract Procedure will statically require the &quot;requested&quot; return type to be
statically constrained by context:</p>
<h4 id="fig-3-33"><a class="header" href="#fig-3-33"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># Ambiguous Contract Procedure Call - should the call return `int` or `SafeRes`?
var ambiguous = Index::get(l, 10);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">generic_return_type_inference_EX3_example.claro:2: Ambiguous Contract Procedure Call: Calls to the procedure `Index$&lt;T, R&gt;::get` is ambiguous without an explicit type annotation to constrain the expected generic return type `R`.
var ambiguous = Index::get(l, 10);
                ^^^^^^^^^^^^^^^^^
1 Error
</code></pre>
<hr />
<h3 id="ambiguity-via-indirect-calls-to-contracts"><a class="header" href="#ambiguity-via-indirect-calls-to-contracts">Ambiguity via Indirect Calls to Contracts</a></h3>
<p>Note that while this specific ambiguity can only possibly arise as a result of calls to a Contract procedure, even 
indirect calls can cause this problem:</p>
<h4 id="fig-4-18"><a class="header" href="#fig-4-18"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">requires(Index&lt;C, R&gt;)
function pickRandom&lt;C, R&gt;(collection: C, maxInd: int) -&gt; R {
  return Index::get(collection, random::nextNonNegativeBoundedInt(random::create(), maxInd + 1));
}

# Ambiguous Contract Procedure Call - should the call return `int` or `SafeRes`?
var ambiguous = pickRandom([1, 2, 3], 10);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">generic_return_type_inference_EX4_example.claro:7: Invalid Generic Procedure Call: For the call to the following generic procedure `pickRandom` with the following signature:
		`function&lt;|[int], int| -&gt; R&gt; Generic Over {[int], R} Requiring Impls for Contracts {Index$&lt;[int], R&gt;}`
	The output types cannot be fully inferred by the argument types alone. The output type must be contextually constrained by either a type annotation or a static cast.
var ambiguous = pickRandom([1, 2, 3], 10);
                ^^^^^^^^^^^^^^^^^^^^^^^^^
1 Error
</code></pre>
<hr />
<p>Again, you can resolve this issue by explicitly declaring the &quot;requested&quot; return type:</p>
<h4 id="fig-5-11"><a class="header" href="#fig-5-11"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">requires(Index&lt;C, R&gt;)
</span><span class="boring">function pickRandom&lt;C, R&gt;(collection: C, maxInd: int) -&gt; R {
</span><span class="boring">  return Index::get(collection, random::nextNonNegativeBoundedInt(random::create(), maxInd + 1));
</span><span class="boring">}
</span><span class="boring">
</span># Ambiguous Contract Procedure Call - should the call return `int` or `SafeRes`?
var unambiguous: SafeRes&lt;int&gt; = pickRandom([1, 2, 3], 10);
print(unambiguous);
</code></pre>
<p><em>Output:</em></p>
<pre><code>SafeRes(Error(IndexOutOfBounds))
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-data"><a class="header" href="#copying-data">Copying Data</a></h1>
<p>In the course of writing software, it can be very common that you'll need to copy some data. In particular, when dealing
with collections that are either themselves mutable, or contain mutable elements, copying can be needed so that one copy
of the data can be updated while leaving the other unchanged.</p>
<p>However, you may find that many languages (e.g. Java/C++) make this extremely simple task prohibitively difficult 
requiring planning ahead to explicitly implement copying support on every data type that you think you'll want to copy 
in the future. To address this, Claro supports <strong>deep copying</strong> out-of-the-box with the builtin <code>copy(...)</code> function. </p>
<h4 id="fig-1-52"><a class="header" href="#fig-1-52"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var l = mut [1, 2, 3];
var myCopy = copy(l);

print(&quot;Before update:&quot;);
print(&quot;l:      {l}&quot;);
print(&quot;myCopy: {myCopy}&quot;);

myCopy[2] = -99999;

print(&quot;\nAfter update:&quot;);
print(&quot;l:      {l}&quot;);
print(&quot;myCopy: {myCopy}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Before update:
l:      mut [1, 2, 3]
myCopy: mut [1, 2, 3]

After update:
l:      mut [1, 2, 3]
myCopy: mut [1, 2, -99999]
</code></pre>
<hr />
<h2 id="deep-copying"><a class="header" href="#deep-copying">Deep Copying</a></h2>
<p>Claro's builtin <code>copy(...)</code> function performs a <strong>deep copy</strong>, meaning that the entire nested structure is traversed
and copied (as needed). The below example copies some nested data and demonstrates that the resulting internal data can
be mutated in isolation:</p>
<h4 id="fig-2-42"><a class="header" href="#fig-2-42"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var original = {left = mut (1, [10]), right = ([&quot;aaa&quot;], mut [&quot;bbb&quot;])};
var copied = copy(original);

print(original);
print(copied);
print(&quot;&quot;);

copied.left[0] = -99;
copied.right[1][0] = &quot;MODIFIED&quot;;

print(original);
print(copied);
print(&quot;&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.003s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
{left = mut (1, [10]), right = ([aaa], mut [bbb])}
{left = mut (1, [10]), right = ([aaa], mut [bbb])}

{left = mut (1, [10]), right = ([aaa], mut [bbb])}
{left = mut (-99, [10]), right = ([aaa], mut [MODIFIED])}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutability-coercion-on-copy"><a class="header" href="#mutability-coercion-on-copy">Mutability Coercion on Copy</a></h1>
<p>Claro's builtin <code>copy(...)</code> function supports the ability to <em>coerce</em> the mutability of the data being copied. This is
primarily a matter of convenience to, in as many cases as possible, avoid Claro programmers to needing to manually write
custom copy implementations.</p>
<p>In order to convey that a mutability coercion is being requested, the return type of the <code>copy(...)</code> call simply needs 
to be constrained to some variant of the original value's type with mutability annotations updated as desired. Claro 
will automatically codegen the appropriate logic to perform the requested copying + coercion. Note that this feature
relies on compile-time knowledge to ensure that any coercions would not actually invalidate any language semantics or
violate type system rules.</p>
<p>In the below example, a <code>mut [[int]]</code> is copied, with the type simultaneously coerced to <code>[mut [int]]</code>: </p>
<h4 id="fig-1-53"><a class="header" href="#fig-1-53"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var original = mut [[1, 2, 3], [4, 5], [6]];
var coercedCopy: [mut [int]] = copy(original);
type(coercedCopy);
print(&quot;Elements of `coercedCopy` match `original`?: {checkElementsMatch(original, coercedCopy)}\n&quot;);

# Now demonstrate that the lists are now independent.
print(&quot;Before mutation -&quot;);
print(&quot;original:    {original}&quot;);
print(&quot;coercedCopy: {coercedCopy}\n&quot;);

original[0]       = [-11111111];
coercedCopy[0][0] = -22222222;  # &lt;-- Outer list is now immutable, so modifying now mutable inner list.

print(&quot;After mutation -&quot;);
print(&quot;original:    {original}&quot;);
print(&quot;coercedCopy: {coercedCopy}&quot;);

function checkElementsMatch(original: mut [[int]], coercedCopy: [mut [int]]) -&gt; boolean {
  # ...
<span class="boring">  var i = 0;
</span><span class="boring">  while (i &lt; len(original)) {
</span><span class="boring">    var j = 0;
</span><span class="boring">    while (j &lt; len(original[i])) {
</span><span class="boring">      if (original[i][j] != coercedCopy[i][j]) {
</span><span class="boring">        return false;
</span><span class="boring">      }
</span><span class="boring">      ++j;
</span><span class="boring">    }
</span><span class="boring">    ++i;
</span><span class="boring">  }
</span><span class="boring">  return true;
</span>}
</code></pre>
<p><em>Output:</em></p>
<pre><code>[mut [int]]
Elements of `coercedCopy` match `original`?: true

Before mutation -
original:    mut [[1, 2, 3], [4, 5], [6]]
coercedCopy: [mut [1, 2, 3], mut [4, 5], mut [6]]

After mutation -
original:    mut [[-11111111], [4, 5], [6]]
coercedCopy: [mut [-22222222, 2, 3], mut [4, 5], mut [6]]
</code></pre>
<hr />
<h2 id="mutability-coercion-can-apply-to-type-parameters-of-a-user-defined-type"><a class="header" href="#mutability-coercion-can-apply-to-type-parameters-of-a-user-defined-type">Mutability Coercion Can Apply to Type Parameters of a User Defined Type</a></h2>
<p>It's worth noting explicitly that Claro's <code>newtype</code> declarations statically encode the mutability any collections they
happen to wrap. Claro's builtin <code>copy(...)</code> <strong>cannot</strong> be used to invalidate these <strong>explicit</strong> mutability declarations,
for example:</p>
<h4 id="fig-2-43"><a class="header" href="#fig-2-43"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># There's nothing that can possibly be done to make Foo&lt;T&gt; wrap a mutable list.
newtype Foo&lt;T&gt; : [T]
</code></pre>
<hr />
<p>However, parameterized User Defined Types may accept any concrete type in the place of the generic type parameter, and
Claro's builtin <code>copy(...)</code> function <em>can</em> be used to do mutability coercion on these values. </p>
<p>The below example demonstrates setting the concrete type <code>T = mut tuple&lt;string, int&gt;</code> meaning that <code>Foo&lt;T&gt;</code> originally 
wraps the type <code>[mut tuple&lt;string, int&gt;]</code>. Then, upon copying the original value, the type is coerced to 
<code>T = tuple&lt;string, int&gt;</code> resulting in <code>Foo&lt;T&gt;</code> wrapping the deeply immutable type <code>[tuple&lt;string, int&gt;]</code>: </p>
<h4 id="fig-3-34"><a class="header" href="#fig-3-34"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Foo&lt;T&gt; : [T]

var original: Foo&lt;mut tuple&lt;string, int&gt;&gt; = Foo([mut (&quot;original&quot;, 1)]);
var coercedCopy: Foo&lt;tuple&lt;string, int&gt;&gt; = copy(original);

unwrap(original)[0][0] = &quot;UPDATED&quot;;
unwrap(original)[0][1] = 2;

print(&quot;original:    {original}&quot;);
print(&quot;coercedCopy: {coercedCopy}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>original:    Foo([mut (UPDATED, 2)])
coercedCopy: Foo([(original, 1)])
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance Optimizations</a></h1>
<p>As Claro's builtin <code>copy(...)</code> performs a <strong>deep copy</strong>, performance becomes an important consideration when data can 
become arbitrarily large (whether as a result of a deeply nested type or not). Fortunately, Claro is able to perform one
significant optimization that can have an incredible effect on the runtime performance of copying large data structures.</p>
<h2 id="claros-copy-is-aware-of-mutability"><a class="header" href="#claros-copy-is-aware-of-mutability">Claro's <code>copy(...)</code> is Aware of Mutability</a></h2>
<p>The key observation that enables this performance optimization is that, as Claro does not expose a value's memory 
location to users, if a piece of data is deeply-immutable (and in a few other situations that Claro takes advantage of),
there is no possible way to distinguish between the two situations below:</p>
<ol>
<li>having equal values located at different addresses in memory</li>
<li>having &quot;shared references&quot; to the exact same value in memory</li>
</ol>
<p>Claro takes advantage of this fact to generate the most efficient possible code to copy the specific type in question.
It does so by eliminating any <em>actual</em> copying of deeply immutable data found nested anywhere within a copied value.</p>
<p>For example, take the below <strong>mutable</strong> list containing <strong>immutable</strong> lists. When it is copied, a new mutable list must
be initialized to represent the outer list so that the original and copied values may be mutated independently. However,
the internal immutable lists can just be referenced directly in the copied list (thus establishing what are known as 
&quot;shared references&quot; to the underlying memory). </p>
<h4 id="fig-1-54"><a class="header" href="#fig-1-54"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">var original = mut [[1, 2, 3], [4, 5], [6]];
var copied = copy(original);

print(original);
print(copied);
</code></pre>
<p><em>Output:</em></p>
<pre><code>mut [[1, 2, 3], [4, 5], [6]]
mut [[1, 2, 3], [4, 5], [6]]
</code></pre>
<hr />
<h2 id="demonstrating-the-performance-win"><a class="header" href="#demonstrating-the-performance-win">Demonstrating the Performance Win</a></h2>
<p>Again, I'll reiterate that it's impossible to <em>directly observe</em> from Claro code itself that this optimization has taken
place as Claro doesn't provide any mechanism for actually checking a value's memory address. So, instead, I'll try to
demonstrate <em>indirectly</em> that this optimization must actually be occurring. </p>
<p>The below example sets up an experiment where a very large, nested list is populated and then copied twice. The first 
copy is done manually using list comprehension. Then, the second copy uses the builtin <code>copy(...)</code>. Each copy is timed
to get a sense of the impact of this optimization. </p>
<p>To make things interesting, the outermost level of the list is mutable so that the overall copy is <strong>not a no-op</strong>. 
However, the performance gain comes from being able to avoid the unnecessary copies <strong>all</strong> of the inner lists. </p>
<div class="warning">
<p><strong>Note</strong>: I'm not claiming that this is a rigorous &quot;benchmark&quot; of any sort - just that this broadly demonstrates the 
claim.</p>
</div>
<h4 id="fig-2-44"><a class="header" href="#fig-2-44"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring"># Claro's list comprehension needs to support unused elem variable: [someExpr | _ in coll]
</span><span class="boring">function discardFirst&lt;A,B&gt;(a: A, b: B) -&gt; B {
</span><span class="boring">  _ = a;
</span><span class="boring">  return b;
</span><span class="boring">}
</span><span class="boring">var numbers: mut [int] = mut [];
</span><span class="boring">lists::ensureCapacity(numbers, 1000);
</span><span class="boring">var i = 0;
</span><span class="boring">while (i++ &lt; 1000) {
</span><span class="boring">  lists::add(numbers, i);
</span><span class="boring">}
</span><span class="boring">var GIANT_TEST_LIST: mut [[[int]]] = mut [];
</span><span class="boring">repeat (100) {
</span><span class="boring">  var innerList = [discardFirst(unused, [x | x in numbers]) | unused in numbers];
</span><span class="boring">  lists::add(GIANT_TEST_LIST, innerList);
</span><span class="boring">}
</span><span class="boring">
</span># Compute the number of ints in the test list.
print(&quot;GIANT_TEST_LIST dimensions: {len(GIANT_TEST_LIST)}x{len(GIANT_TEST_LIST[0])}x{len(GIANT_TEST_LIST[0][0])}\n&quot;);

# Now, manually copy the test lest using list comprehension.
var firstTestStart = instant::now();
var manuallyCopied = mut [[[x | x in l2] | l2 in l1] | l1 in GIANT_TEST_LIST];
var firstTestEnd = instant::now();

# Now, copy using the builtin `copy(...)` function.
var secondTestStart = instant::now();
var efficientlyCopied = copy(GIANT_TEST_LIST);
var secondTestEnd = instant::now();

# Let's see approximately how much time each took!
var MILLIS_PER_SECOND = 1000.0;
var NANOS_PER_SECOND = 1000000000.0;
duration::between(firstTestStart, firstTestEnd)
  |&gt; duration::toMillis(^)
  |&gt; print(&quot;Manual copy time:  {^/MILLIS_PER_SECOND} seconds&quot;);
duration::between(secondTestStart, secondTestEnd)
  |&gt; duration::toNanos(^)
  |&gt; print(&quot;Builtin copy time: {^/NANOS_PER_SECOND} seconds&quot;);

# Now just to really finish the demonstration, let's confirm that these copies actually contain equal elements to the
# giant copied list.
print(&quot;\nmanuallyCopied == GIANT_TEST_LIST:    {manuallyCopied == GIANT_TEST_LIST}&quot;);
print(&quot;efficientlyCopied == GIANT_TEST_LIST: {efficientlyCopied == GIANT_TEST_LIST}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>GIANT_TEST_LIST dimensions: 100x1000x1000

Manual copy time:  2.669 seconds
Builtin copy time: 8.9E-5 seconds

manuallyCopied == GIANT_TEST_LIST:    true
efficientlyCopied == GIANT_TEST_LIST: true
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-copy-bugs"><a class="header" href="#known-copy-bugs">Known <code>copy(...)</code> Bugs</a></h1>
<p>Currently Claro's copy implementation suffers from two different implementation problems that will be resolved in a
future release. I'll describe them below just for the sake of clarity.</p>
<div class="warning">Please feel free to reach out if you'd like to help to address these bugs!</div>
<h2 id="compiler-stack-overflows-on-copying-recursive-types"><a class="header" href="#compiler-stack-overflows-on-copying-recursive-types">Compiler Stack Overflows on Copying Recursive Types</a></h2>
<p>Currently, the Claro compiler doesn't do any special handling of recursively defined types, and so as it attempts to
generate code for an inlined copy of a recursive type, it ends up infinitely looping over the codegen phase.</p>
<h4 id="fig-1-55"><a class="header" href="#fig-1-55"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># This type is recursive (with int as its &quot;bottom&quot; to terminate recursion).
newtype ComplexData : oneof&lt;int, tuple&lt;ComplexData, ComplexData&gt;, {ComplexData}&gt;

function generateRandomComplexData(rng: random::RandomNumberGenerator, maxDepth: int) -&gt; ComplexData {
  # ...
<span class="boring">  return generateRandomComplexData_impl(rng, 0, maxDepth);
</span>}
<span class="boring">
</span><span class="boring">function generateRandomComplexData_impl(rng: random::RandomNumberGenerator, currDepth: int, maxDepth: int) -&gt; ComplexData {
</span><span class="boring">  if (currDepth == maxDepth) {
</span><span class="boring">    return ComplexData(-1); # Let's just avoid attempting to create some infinitely large data structure.
</span><span class="boring">  }
</span><span class="boring">  var next = lambda () -&gt; ComplexData { return generateRandomComplexData_impl(rng, currDepth + 1, maxDepth); };
</span><span class="boring">  match (random::nextNonNegativeBoundedInt(rng, 3)) {
</span><span class="boring">    case 0 -&gt; # int
</span><span class="boring">      return ComplexData(random::nextNonNegativeBoundedInt(rng, 100));
</span><span class="boring">    case 1 -&gt; # tuple&lt;ComplexData, ComplexData&gt;
</span><span class="boring">      return ComplexData((next(), next()));
</span><span class="boring">    case _ -&gt; # {ComplexData}
</span><span class="boring">      return ComplexData({next(), next(), next()});
</span><span class="boring">  }
</span><span class="boring">}
</span>
var someComplexData = generateRandomComplexData(random::forSeed(3), 3);
print(someComplexData);

# KNOWN COMPILER BUG: CURRENTLY CLARO IS UNABLE TO CORRECTLY GENERATE COPY LOGIC OVER RECURSIVE TYPES!
#     This currently causes the compiler to stack overflow. This will be resolved in a future release.
# var copied = copy(someComplexData);
# print(copied);
</code></pre>
<p><em>Output:</em></p>
<pre><code>ComplexData({ComplexData((ComplexData((ComplexData(-1), ComplexData(-1))), ComplexData(82))), ComplexData({ComplexData(37), ComplexData(6), ComplexData((ComplexData(-1), ComplexData(-1)))}), ComplexData({ComplexData(64), ComplexData(81), ComplexData(2)})})
</code></pre>
<hr />
<p>In the future, this will be fixed by statically identifying when a recursive type is being copied, and then generating
a custom copy function for that particular type that will actually recurse <strong>at runtime</strong> rather than at compile time.
Note, this will put the onus on the programmer to ensure that they <strong>never call <code>copy(...)</code> on any cyclical data 
structure</strong>. </p>
<h2 id="generated-copy-logic-severs-shared-references-to-mutable-data"><a class="header" href="#generated-copy-logic-severs-shared-references-to-mutable-data">Generated Copy Logic Severs Shared References to Mutable Data</a></h2>
<p>Potentially more nefarious than the previous bug, Claro's current copy implementation handles the copying of shared
references to mutable data in a way that is potentially likely to cause confusion or lead to bugs. A piece of nested
data that contains multiple fields of the same mutable type has the potential to contain shared references to the 
<strong>same</strong> mutable value. This is a semantically meaningful feature, not just some esoteric feature of the low-level 
memory layout. Mutation of this shared mutable data will be observable via each reference in the containing structure.
Problematically, when a copy is made, every single mutable value within the entire recursive structure will be 
guaranteed to have a single, unique reference. This may be a useful guarantee in some contexts, but I believe that this
goes against Claro's goals of being as unsurprising as possible. </p>
<p>The copied data should have the exact same semantics as the original data that it was derived from, but in this one 
subtle way that is not currently the case. This will be fixed in a future release. </p>
<h4 id="fig-2-45"><a class="header" href="#fig-2-45"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">var X = mut [99];
var l1 = [X, X];
var l2 = copy(l1);
print(&quot;l1: {l1}&quot;);
print(&quot;l2: {l2}&quot;);

l1[0][0] = -1;
print(&quot;\nl1: {l1}  # &lt;-- Notice that both list elements have updated after a single write to the shared reference.&quot;);
print(&quot;l2: {l2}&quot;);

l2[0][0] = -2;
print(&quot;\nl1: {l1}&quot;);
print(&quot;l2: {l2}  # &lt;-- This is arguably a bug. The shared reference was severed.&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>l1: [mut [99], mut [99]]
l2: [mut [99], mut [99]]

l1: [mut [-1], mut [-1]]  # &lt;-- Notice that both list elements have updated after a single write to the shared reference.
l2: [mut [99], mut [99]]

l1: [mut [-1], mut [-1]]
l2: [mut [-2], mut [99]]  # &lt;-- This is arguably a bug. The shared reference was severed.
</code></pre>
<hr />
<h2 id="mutability-coercion-can-circumvent-a-user-defined-types-initializers-restrictions"><a class="header" href="#mutability-coercion-can-circumvent-a-user-defined-types-initializers-restrictions">Mutability Coercion Can Circumvent a User Defined Type's <code>initializers</code> Restrictions</a></h2>
<p>User Defined Types support the declaration of <code>initializers</code> that restrict the usage of the type's default constructor
to only the procedures defined within the <code>initializers</code> block. Claro's builtin <code>copy(...)</code> <strong>currently provides a 
backdoor to initialize and instance of a user defined type without actually using one its initializers</strong>.</p>
<p>This is fortunately of limited impact as the worst thing a user can do is create instances with a mutability declaration
that the type would otherwise not support. But regardless, this will be addressed in a future release.</p>
<h4 id="fig-3-35"><a class="header" href="#fig-3-35"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">newtype Foo&lt;T&gt; : T

initializers Foo {
  # Calling this function should be the **only** way to get an instance of Foo&lt;T&gt;.
  function getFooForInts(ints: [int]) -&gt; Foo&lt;[int]&gt; {
    return Foo(ints);
  }
}

var original: Foo&lt;[int]&gt; = getFooForInts([0, 1, 2]);

# The fact that this is somehow permitted is arguably a bug... why are you able
# to initialize a Foo&lt;T&gt; without invoking the declared initializer?? This seems
# to break the semantic intent of declaring initializers to restrict the direct
# instantiation of user defined types to have to &quot;go through the front door&quot;.
var coercedCopy: Foo&lt;mut [int]&gt; = copy(original);
print(coercedCopy);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
Foo(mut [0, 1, 2])
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-files"><a class="header" href="#resource-files">Resource Files</a></h1>
<p>Strangely, bundling files into builds to be read at runtime regardless of where the executable program gets moved and
run from can be a significant pain point in many languages. Of course, each language provides some mechanism to address
this concern, but it typically requires either learning about some external build system feature, or figuring out how to
pass the correct sequence of flags to compilers. And then even once you do, figuring out the correct incantation to
successfully read that resource file can be just as frustrating 
(<a href="https://howtodoinjava.com/java/io/read-file-from-resources-folder/" target="_blank">looking at you Java</a>).</p>
<p>Claro tries to make this much simpler by directly modelling Resource Files as part of the exposed <code>claro_binary()</code> and
<code>claro_module()</code> build rules that you'll be using already. Declaring a Resource File to be bundled into the final deploy
Jar is as simple as listing it in your Build target similarly to how a Module dependency would be declared:</p>
<h4 id="fig-1-56"><a class="header" href="#fig-1-56"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-python">load(&quot;//@claro-lang:rules.bzl&quot;, &quot;claro_binary&quot;)

claro_binary(
    name = &quot;example&quot;,
    main_file = &quot;ex1.claro&quot;,
    resources = {
        &quot;MyReource&quot;: &quot;example_resource.txt&quot;,
    }
)
</code></pre>
<hr />
<p>The Build target above has an explicit build time dependency on a Resource File named <code>example_resource.txt</code>. As you've
by now come to expect, if the file is missing for some reason Bazel will raise a Build error letting you know. You won't
simply have to try running your program and go through a whole debugging process just to find out 5 minutes later that
you misspelled the file name.</p>
<p>Now, your program has access to the Resource File <code>MyResource</code> by using the auto-generated <code>resources::MyResource</code> 
static value. It can then be read using one of the available functions exported by the StdLib's
<a href="resource_files/../stdlib/files_module.generated_docs.html"><code>files</code> Module</a>:</p>
<h4 id="fig-2-46"><a class="header" href="#fig-2-46"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">resources::MyResource
  |&gt; files::readOrPanic(^)
  |&gt; print(&quot;Resource File Content:\n\n{^}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Resource File Content:

this is just
some arbitrary text
in a file
to use as an example
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-system"><a class="header" href="#module-system">Module System</a></h1>
<p>All but the most trivial programs will require some mechanism for decomposing a larger program into smaller, reusable 
components that can be composed into a larger whole. In Claro projects, this is accomplished via the Module System
whereby distinct functionality can be organized logically to facilitate encapsulation. In addition, Claro's Module 
System is the source of Claro's build incrementality - modules are compiled in isolation, allowing caching such that
modules do not need to be recompiled unless its own or its dependencies implementations have changed.</p>
<h2 id="defining-a-module"><a class="header" href="#defining-a-module">Defining a Module</a></h2>
<p>A Module exposes an API that is implemented by some set of source files which may depend on other modules.</p>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<p>Module APIs are explicitly defined using a .claro_module_api file that will list exported procedure signatures, type
declarations, static values, and Contract implementations that are publicly exposed to consumers that place a dependency
on this module.</p>
<h4 id="fig-1-57"><a class="header" href="#fig-1-57"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># example.claro_module_api

contract Numeric&lt;T&gt; {
  function add(lhs: T, rhs: T) -&gt; T;
  function multiply(lhs: T, rhs: T) -&gt; T;
}

newtype Foo : int
implement Numeric&lt;Foo&gt;;

consumer prettyPrint(lhs: Foo);
</code></pre>
<hr />
<h3 id="sources"><a class="header" href="#sources">Sources</a></h3>
<p>An API alone simply defines an interface that the module will satisfy in its implementation sources. So implementations
must be provided in the form of one or more .claro files. The above API could be satisfied by the below implementation
files (note: this could be done in a single source file, but here it's split into multiple just as an example):</p>
<h4 id="fig-2-47"><a class="header" href="#fig-2-47"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># contract_impl.claro

implement Numeric&lt;Foo&gt; {
  function add(lhs: Foo, rhs: Foo) -&gt; Foo {
    return Foo(unwrap(lhs) + unwrap(rhs));
  }
  function multiply(lhs: Foo, rhs: Foo) -&gt; Foo {
    return Foo(unwrap(lhs) * unwrap(rhs));
  }
}
</code></pre>
<hr />
<h4 id="fig-3-36"><a class="header" href="#fig-3-36"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># pretty_print.claro

consumer prettyPrint(f: Foo) {
  unwrap(f)
    |&gt; &quot;Foo: {^}&quot;
    |&gt; Boxes::wrapInBox(^)  # &lt;-- Calling dep Module function.
    |&gt; print(^);
}
</code></pre>
<hr />
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>While Modules are intended to be consumed as a reusable component, it may also itself depend on other modules in order
to implement its public API. </p>
<p>Notice that the implementation of <code>prettyPrint</code> above makes a call to <code>Boxes::wrapInBox(...)</code>. This is an example of
calling a procedure from a downstream dep Module in Claro. In order to build, this Module must place a dep on some 
Module that has <em>at least</em> the following signature in its API: <code>function wrapInBox(s: string) -&gt; string;</code>. As you'll see
below, this Module will <em>choose</em> to give that downstream dependency Module the name <code>Boxes</code>, but any other name could've
been chosen.</p>
<div class="warning">
<p><strong>Dependency Naming:</strong> While consumers are allowed to pick any name they want for Modules that they depend on, it should
be noted that Claro will adopt the convention that all non-StdLib Module names <strong>must begin with an uppercase letter</strong>.
All StdLib Modules will be named beginning with a lowercase letter. This is intended to allow the set of StdLib modules
to expand over time without ever having to worry about naming collisions with user defined Modules in existing programs.</p>
<p>Static enforcement of this convention hasn't been implemented yet, but just know that it's coming in a future release. </p>
</div>
<h2 id="defining-build-target"><a class="header" href="#defining-build-target">Defining BUILD Target</a></h2>
<p>A Claro Module is fully defined from the above pieces by adding a <code>claro_module(...)</code> definition to the corresponding 
Bazel BUILD file:</p>
<h4 id="fig-4-19"><a class="header" href="#fig-4-19"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD

load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_module&quot;)

claro_module(
    name = &quot;example&quot;,
    module_api_file = &quot;example.claro_module_api&quot;,
    srcs = [
        &quot;contract_impl.claro&quot;,
        &quot;pretty_print.claro&quot;,
    ],
    deps = {
        &quot;Boxes&quot;: &quot;:box&quot;,  # &lt;-- Notice the name &quot;Boxes&quot; is chosen by the consumer.
    },
    # This Module can be consumed by anyone.
    visibility = [&quot;//visibility:public&quot;],
)

claro_module(
    name = &quot;box&quot;,
    module_api_file = &quot;boxes.claro_module_api&quot;,
    srcs = [&quot;boxes.claro&quot;],
    # No visibility declared means that this Module is private to this Bazel package.
)

# ...
</code></pre>
<hr />
<h3 id="building-a-module"><a class="header" href="#building-a-module">Building a Module</a></h3>
<p>In order to validate that a <code>claro_module(...)</code> target compiles successfully, you can run a Bazel command like the 
following:</p>
<p>(Assuming the BUILD file is located at //path/to/target)</p>
<pre><code>$ bazel build //path/to/target:example
</code></pre>
<p>This will build the explicitly named target and its entire transitive closure of dependencies (assuming their build 
results have not been previously cached in which case they'll be skipped and the cached artifacts reused).</p>
<h2 id="executable-using-above-example-module"><a class="header" href="#executable-using-above-example-module">Executable Using Above Example Module</a></h2>
<p>To close the loop, the above example Module could be consumed and used in the following executable Claro program in the
following way.</p>
<h4 id="fig-5-12"><a class="header" href="#fig-5-12"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD

load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_binary&quot;)

...

claro_binary(
    name = &quot;test&quot;,
    main_file = &quot;test.claro&quot;,
    deps = {
        &quot;Ex&quot;: &quot;:example&quot;,
    },
)
</code></pre>
<hr />
<h4 id="fig-6-7"><a class="header" href="#fig-6-7"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro"># test.claro

var f1 = Ex::Foo(1);
var f2 = Ex::Foo(2);

var addRes = Ex::Numeric::add(f1, f2);
Ex::prettyPrint(addRes);

var mulRes = Ex::Numeric::multiply(f2, Ex::Foo(5));
Ex::prettyPrint(mulRes);
</code></pre>
<p><em>Output:</em></p>
<pre><code>----------
| Foo: 3 |
----------
-----------
| Foo: 10 |
-----------
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-apis"><a class="header" href="#module-apis">Module APIs</a></h1>
<p>As you've seen in the previous section, a Claro Module is defined by its API which fully declares what downstream
consumers of the Module will gain access to by placing a dependency on it. In Claro, this API is explicitly declared 
using a <code>.claro_module_api</code> file that simply contains type information, signatures, and names of what's implemented 
within, but does not contain any concrete implementations itself. This may seem like it's just extra boilerplate, but in
fact, this separation of API and implementation is actually the source of the extreme modularity that Claro programs can
leverage. </p>
<p>In particular, it's very important to note that this separation implies that <strong>it is impossible for two separate modules 
to be</strong> 
<a href="https://www.wikiwand.com/en/Coupling_(computer_programming)#introduction" target="_blank">&quot;tightly coupled&quot;</a>!
Whereas in other programming languages like Java or Python, you must consciously plan ahead in order to maintain 
<a href="https://www.wikiwand.com/en/Loose_coupling" target="_blank">&quot;loose coupling&quot;</a> between program components.</p>
<p>This guarantee of loose coupling between Modules will be evaluated in more detail in a 
<a href="module_system/module_apis/../swapping_deps/swapping_deps.generated_docs.html">following section</a>, but for now, we'll just take a moment to 
explicitly outline exactly what can be exported by a Module's API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedure-signatures-1"><a class="header" href="#procedure-signatures-1">Procedure Signatures</a></h1>
<p>Of course, the most obvious reason to create a new Module is to factor out some logic for the sake of making it reusable
in multiple places in your program, or even just to keep another Module's implementation from growing in size
indefinitely. So, the first thing that you're likely to export from a Module are procedures. To do so, you will simply
declare the signature of the procedure(s) to be exported - that is, everything but the implementation of the procedure.
A procedure signature ends with a <code>;</code> instead of the usual implementation logic inside curly braces.</p>
<p>For example, the following signatures are exported from the StdLib's 
<a href="module_system/module_apis/procedure_signatures/../../../stdlib/strings_module.generated_docs.html">strings module</a>:</p>
<h4 id="fig-1-58"><a class="header" href="#fig-1-58"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># strings.claro_module_api

function fromChar(c: char) -&gt; string;
function charAt(s: string, i: int) -&gt; char;

# ...
</code></pre>
<hr />
<div class="warning">
<p>Including a procedure signature in a Module's API file is a declaration that any dependent of this Module will have 
access to a procedure with the given signature, so Claro will statically validate that any <code>claro_module(...)</code> target
exporting any procedure signatures <strong>actually</strong> implements that procedure within its given <code>srcs</code>.</p>
</div>
<p>So, your build target will be required to declare which <code>.claro</code> source file(s) actually <em>implement</em> the exported
procedures as explained in the introduction to <a href="module_system/module_apis/procedure_signatures/../../module_system.generated_docs.html#sources">defining Modules</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="type--alias-definitions"><a class="header" href="#type--alias-definitions">Type &amp; Alias Definitions</a></h1>
<p>Modules can also be used to export definitions of Types or Aliases that are intended to be used throughout your overall
program. </p>
<h2 id="exporting-type-definitions"><a class="header" href="#exporting-type-definitions">Exporting Type Definitions</a></h2>
<p>Exporting a Type definition can be as simple as just using the same Type definition syntax that you'd use within a
<code>.claro</code> source file.</p>
<p>For example, the <a href="module_system/module_apis/type_definitions/../../../stdlib/std_module.generated_docs.html">std module</a> exports the following Type:</p>
<h4 id="fig-1-59"><a class="header" href="#fig-1-59"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># std.claro_module_api

newtype Error&lt;T&gt; : T

# ...
</code></pre>
<hr />
<div class="warning">
The one thing to keep in mind when exporting a Type definition using this basic syntax is that you're explicitly giving
consumers access to the internal details of the type itself. This has the potential to make for a very unstable API as
any consumers can freely unwrap values of the type and manipulate its underlying representation at will. This is 
obviously unsafe if the Type happens to be mutable as downstream consumers may not know how to maintain any inter-field
invariants if they're allowed to mutate it at will. 
<p>And beyond mutability, perhaps more subtly, you should also consider whether there will be lots of downstream users 
directly accessing the Type's internal representation, and if so whether the representation is ever subject to any 
future change. If so, in the future, it may unknowingly become very hard to ever make changes to the Type's internal 
representation as, to do so, you would simultaneously be forced to update all of the downstream references to the Type's
internal representation.</p>
<p>Thankfully, Claro actually has mechanisms to hide the internal representation of a Type definition from downstream 
consumers. Learn more in the sections on 
<a href="module_system/module_apis/type_definitions/./initializers_and_unwrappers/initializers_and_unwrappers.generated_docs.html">Unwrappers</a> and 
<a href="module_system/module_apis/type_definitions/./opaque_types/opaque_types.generated_docs.html">Opaque Types</a>.</p>
</div>
<h2 id="exporting-atoms"><a class="header" href="#exporting-atoms">Exporting Atoms</a></h2>
<p>Exporting an Atom is something of a hybrid between exporting a 
<a href="module_system/module_apis/type_definitions/../static_values/static_values.generated_docs.html">static value</a> and a Type definition, as an atom defines a new type 
whose only value is the Atom itself. But again, you may export Atoms from Module APIs exactly as it would be defined 
within a <code>.claro</code> source file.</p>
<p>For example, the <a href="module_system/module_apis/type_definitions/../../../stdlib/strings_module.generated_docs.html">strings module</a> exports the following atom and
several functions that reference it.</p>
<h4 id="fig-2-48"><a class="header" href="#fig-2-48"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># strings.claro_module_api

atom NOT_FOUND
function indexOf(s: string, of: string) -&gt; oneof&lt;int, NOT_FOUND&gt;;
function indexOfFromIndex(s: string, of: string, from: int) -&gt; oneof&lt;int, NOT_FOUND&gt;;
function lastIndexOf(s: string, of: string) -&gt; oneof&lt;int, NOT_FOUND&gt;;
function lastIndexOfFromIndex(s: string, of: string, from: int) -&gt; oneof&lt;int, NOT_FOUND&gt;;

# ...
</code></pre>
<hr />
<h2 id="exporting-aliases"><a class="header" href="#exporting-aliases">Exporting Aliases</a></h2>
<p>While Aliases largely exist to allow you to create your own convenient syntax sugar for complex types, it can sometimes
be useful for a Module to provide a standardized Alias for long or complex types that downstream usages could benefit
from having a shorthand for. Syntax for exporting an Alias in a Module API is exactly the same as the syntax for
declaring an Alias in a <code>.claro</code> source file.</p>
<h4 id="fig-3-37"><a class="header" href="#fig-3-37"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1.claro_module_api

alias ComplexStruct : struct {
  fieldA: tuple&lt;
    struct {
      innerA: int,
      innerB: [[char]]
    },
    int,
    float
  &gt;,
  fieldB: provider&lt;oneof&lt;int, string&gt;&gt;
}

# It'll be much easier for users to be able to refer to this type using the exported
# alias rather than the type itself.
provider getRandomComplexStruct() -&gt; ComplexStruct;
</code></pre>
<hr />
<h2 id="modules-exporting-only-typesaliases-dont-require-any-claro-source-files"><a class="header" href="#modules-exporting-only-typesaliases-dont-require-any-claro-source-files">Modules Exporting <strong>Only</strong> Types/Aliases Don't Require any <code>.claro</code> Source Files</a></h2>
<p>In general, if your Module <strong>exclusively</strong> exports Type or Alias definitions, you actually do not need to provide any
<code>.claro</code> srcs to the defining <code>claro_module(...)</code> target, as the definitions themselves fully specify the Module in 
their own right.</p>
<h4 id="fig-4-20"><a class="header" href="#fig-4-20"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex4.claro_module_api

alias UserLookupError : oneof&lt;USER_NOT_FOUND, USER_DELETED, USER_SUSPENDED&gt;

atom USER_NOT_FOUND
atom USER_DELETED
atom USER_SUSPENDED
</code></pre>
<hr />
<h4 id="fig-5-13"><a class="header" href="#fig-5-13"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">load(&quot;//:rules.bzl&quot;, &quot;claro_module&quot;)

claro_module(
    name = &quot;user_error_types&quot;,
    module_api_file = &quot;ex4.claro_module_api&quot;,
    # You could optionally, explicitly declare an empty list.
    # srcs = [],
)
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><p>[0.004s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="initializers--unwrappers"><a class="header" href="#initializers--unwrappers">Initializers &amp; Unwrappers</a></h1>
<p>Claro's builtin types are already fully capable of expressing <em>any</em> data structure, and so the entire purpose of 
User-Defined Types is to allow user code to overlay <em>new semantic meaning</em> onto types beyond just the raw data values
themselves. Claro supports two simple constructs that allow User-Defined Types to constrain, and reinterpret the raw
data types that they wrap. Note that both of these constructs should likely only be used in limited cases where you have
a very specific reason to be doing so.</p>
<h2 id="initializers"><a class="header" href="#initializers">Initializers</a></h2>
<p>Initializers provide a mechanism for a User-Defined Type to constrain the domain of possible values that a type may
represent beyond what the raw data types imply on their own.</p>
<p>To demonstrate the problem being addressed, take for example the type declaration below:</p>
<h4 id="fig-1-60"><a class="header" href="#fig-1-60"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-no-init.claro_module_api
newtype OddInt : int
</code></pre>
<hr />
<p>There's nothing about the type definition alone that <em>actually</em> imposes any sort of constraint that actually guarantees
that the wrapped int is in fact odd. So a consumer could place a dep (<code>Nums</code>) on the Module and directly construct a
completely invalid instance of the <code>OddInt</code> type:</p>
<h4 id="fig-2-49"><a class="header" href="#fig-2-49"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;//:rules.bzl&quot;, &quot;claro_binary&quot;, &quot;claro_module&quot;)

claro_module(
    name = &quot;ex1_no_initializer&quot;,
    module_api_file = &quot;ex1-no-init.claro_module_api&quot;, # `newtype OddInt : int`
)

claro_binary(
    name = &quot;bad_init_example&quot;,
    srcs = &quot;ex1-bad-init.claro&quot;,
    deps = {
        &quot;Nums&quot;: &quot;:ex1_no_initializer&quot;,
    }
)
</code></pre>
<hr />
<h4 id="fig-3-38"><a class="header" href="#fig-3-38"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-bad-init.claro
var invalidOddInt = Nums::OddInt(8);
print(invalidOddInt);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
OddInt(8)
</code></pre>
<hr />
<p>Of course, it'd be very much preferable for it to be impossible to ever construct an instance of a Type that violates
its semantic invariants. You can enforce this in Claro by defining <strong>Initializers</strong> over the Type. Initializers are
simply procedures that become the <strong>only procedures in the entire program that are allowed to directly use the Type's
constructor</strong>. Therefore, if a Type declares an <code>initializers</code> block, the procedures declared within become the <strong>only</strong>
way for anyone to receive an instance of the type.</p>
<h4 id="fig-4-21"><a class="header" href="#fig-4-21"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-with-init.claro_module_api
newtype OddInt : int

atom NOT_ODD
initializers OddInt {
  function getOddInt(x: int) -&gt; oneof&lt;OddInt, std::Error&lt;NOT_ODD&gt;&gt;;
}
</code></pre>
<hr />
<h4 id="fig-5-14"><a class="header" href="#fig-5-14"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;//:rules.bzl&quot;, &quot;claro_binary&quot;, &quot;claro_module&quot;)

claro_module(
    name = &quot;ex1_with_initializer&quot;,
    module_api_file = &quot;ex1-with-init.claro_module_api&quot;,
)

claro_binary(
    name = &quot;rejected_init_example&quot;,
    srcs = &quot;ex1-bad-init.claro&quot;, # Same as before. We'll expect an error.
    deps = {
        &quot;Nums&quot;: &quot;:ex1_with_initializer&quot;, # Now defines an Initializer.
    }
)
</code></pre>
<hr />
<p>Now, the exact same attempt to construct an invalid instance of <code>OddInt</code> is statically rejected at compile-time - and
even better, Claro's able to specifically recommend the fix, calling the <code>Nums::getOddInt(...)</code> function:</p>
<h4 id="fig-6-8"><a class="header" href="#fig-6-8"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-bad-init.claro
var invalidOddInt = Nums::OddInt(8);
print(invalidOddInt);
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">initializers_and_unwrappers_EX6_example.claro:2: Illegal Use of User-Defined Type Constructor Outside of Initializers Block: An initializers block has been defined for the custom type `[module at //mdbook_docs/src/module_system/module_apis/type_definitions/initializers_and_unwrappers:ex1_with_initializer]::OddInt`, so, in order to maintain any semantic constraints that the initializers are intended to impose on the type, you aren't allowed to use the type's default constructor directly.
		Instead, to get an instance of this type, consider calling one of the defined initializers:
			- Nums::getOddInt
var invalidOddInt = Nums::OddInt(8);
                    ^^^^^^^^^^^^^^^
1 Error
</code></pre>
<hr />
<div class="warning">
<p><em>Note: Claro's error messaging is a work in progress - the above error message will be improved.</em></p>
</div>
<p>And now finally, you can use the initializer by simply calling it like any other procedure:</p>
<h4 id="fig-7-4"><a class="header" href="#fig-7-4"><em>Fig 7:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-good-init.claro
var invalidOddInt = Nums::getOddInt(8);
print(invalidOddInt);

var oddInt = Nums::getOddInt(7);
print(oddInt);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Error(NOT_ODD)
OddInt(7)
</code></pre>
<hr />
<p>Now you know for a fact that anywhere where you initialize an instance of an <code>OddInt</code> in the entire program, it will
certainly satisfy its semantic invariants. </p>
<div class="warning">
<p><strong>Warning</strong>: Still, keep in mind that if your type is mutable, declaring Initializers is not, on its own, sufficient to
guarantee that any constraints or invariants are maintained over time. Keep reading to learn about how Unwrappers and
Opaque Types can give you full control over this.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unwrappers"><a class="header" href="#unwrappers">Unwrappers</a></h1>
<p>Initializers are a very useful concept, but on their own they don't allow full control over maintaining a mutable type's
semantic invariants or constraints. For example, consider the following type definition: </p>
<h4 id="fig-1-61"><a class="header" href="#fig-1-61"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># person.claro_module_api
newtype Person : mut struct {name: string, age: int}

atom InvalidAge
initializers Person {
  function getPerson(name: string, age: int) -&gt; oneof&lt;Person, std::Error&lt;InvalidAge&gt;&gt;;
}
</code></pre>
<hr />
<p>If we wanted to impose the semantic constraint on legal values for a <code>Person</code>'s <code>age</code>, defining the initializer alone is
only sufficient to ensure the constraint is enforced for the initial value. But it doesn't help maintain this after init
as users could still freely unwrap and mutate the type directly:</p>
<h4 id="fig-2-50"><a class="header" href="#fig-2-50"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># Negative age can be rejected on init...
var invalidAge = Person::getPerson(&quot;Jason&quot;, -1);
print(invalidAge);

var p = Person::getPerson(&quot;Jason&quot;, 29);
# Prove that we didn't get a std::Error&lt;InvalidAge&gt;.
if (p instanceof Person::Person) {
  print(p);

  # But we can violate the semantics of the type by unwrapping and mutating directly.
  unwrap(p).age = -1;
  print(p);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
Error(InvalidAge)
Person(mut {name = Jason, age = 29})
Person(mut {name = Jason, age = -1})
</code></pre>
<hr />
<p>Fortunately, Claro provides a couple different ways to actually control semantic constraints/invariants like this. The
first approach is to define Unwrappers. Analogous to Initializers that constrain the usage of a Type's default
constructor, Unwrappers constrain the usage of the built-in <code>unwrap(...)</code> operation. For example, the above violation of
the intended constraints on a <code>Person</code>'s <code>age</code> can be enforced by adding an Unwrapper procedure that will handle all
allowed updates:</p>
<h4 id="fig-3-39"><a class="header" href="#fig-3-39"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># person.claro_module_api
newtype Person : mut struct {name: string, age: int}

atom InvalidAge
initializers Person {
  function getPerson(name: string, age: int) -&gt; oneof&lt;Person, std::Error&lt;InvalidAge&gt;&gt;;
}
unwrappers Person {
  function setAge(p: Person, newAge: int) -&gt; oneof&lt;std::OK, std::Error&lt;InvalidAge&gt;&gt;;
}
</code></pre>
<hr />
<p>And now, the workaround that previously allowed violating the type's constraints has been patched. Attempts to directly
mutate the value w/o going through approved procedures that handle updates will be rejected at compile-time:</p>
<h4 id="fig-4-22"><a class="header" href="#fig-4-22"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"># Negative age can be rejected on init...
var invalidAge = Person::getPerson(&quot;Jason&quot;, -1);
print(invalidAge);

var p = Person::getPerson(&quot;Jason&quot;, 29);
# Prove that we didn't get a std::Error&lt;InvalidAge&gt;.
if (p instanceof Person::Person) {
  print(p);

  # But we can violate the semantics of the type by unwrapping and mutating directly.
  unwrap(p).age = -1;
  print(p);
}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">unwrappers_EX4_example.claro:11: Illegal Use of User-Defined Type Unwrapper Outside of Unwrappers Block: An unwrappers block has been defined for the custom type `[module at //mdbook_docs/src/module_system/module_apis/type_definitions/initializers_and_unwrappers/unwrappers:person_with_unwrappers]::Person`, so, in order to maintain any semantic constraints that the unwrappers are intended to impose on the type, you aren't allowed to use the type's default `unwrap()` function directly.
		Instead, to unwrap an instance of this type, consider calling one of the defined unwrappers:
			- Person::setAge
  unwrap(p).age = -1;
  ^^^^^^^^^
1 Error
</code></pre>
<hr />
<p>Now, if you actually tried to update the age to something invalid using the official <code>setAge(...)</code> function, the update
will be rejected:</p>
<h4 id="fig-5-15"><a class="header" href="#fig-5-15"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">var p = Person::getPerson(&quot;Jason&quot;, 29);
if (p instanceof Person::Person) {
  print(p);

  # Now the update must be done via the provided `setAge(...)` function
  # which first validates the update, and in this case rejects.
  var updateRes = Person::setAge(p, -1);
  print(updateRes);
  print(p);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>Person(mut {name = Jason, age = 29})
Error(InvalidAge)
Person(mut {name = Jason, age = 29})
</code></pre>
<hr />
<h2 id="recommended-use-of-unwrappers-and-initializers"><a class="header" href="#recommended-use-of-unwrappers-and-initializers">Recommended Use of Unwrappers and Initializers</a></h2>
<div class="warning">
<p>It's worth noting that <code>initializers</code> and <code>unwrappers</code> blocks exist largely to be used <strong>independently</strong>. The above
example is fairly contrived, and would likely be better defined as an 
<a href="module_system/module_apis/type_definitions/initializers_and_unwrappers/unwrappers/../../opaque_types/opaque_types.generated_docs.html">&quot;Opaque Type&quot;</a>. A good rule of thumb is that if you catch yourself
thinking that you need to define both for the same Type, you should likely be defining the Type to be &quot;Opaque&quot; instead.</p>
<p>In particular, <code>initializers</code> can be well-used in isolation for immutable Types where you would like to validate the
values on init, but would like to maintain the ergonomics of allowing users to directly access the internals themselves
(and as the data is immutable, there's no risk in allowing them to do so).
For example, with the immutable type <code>newtype GameLocation : struct {x: int, y: int}</code> you may want to require that <code>x</code>
and <code>y</code> are <em>actually</em> within the game's boundaries, but otherwise you want to allow users of the type to directly
access <code>x</code> and <code>y</code> without having to write/use annoying &quot;getters&quot;.</p>
<p>On the other hand, <code>unwrappers</code> can be well-used in isolation for mutable values that can <em>start</em> with any value, but
for which all subsequent changes must be constrained. For example, with
<code>newtype MonotonicallyIncreasingValue: mut struct {val: long}</code> you may be happy to allow arbitrary <em>starting</em> values,
but after that point you would want to ensure that any updates to its value are in fact increasing its value, perhaps by
simply exposing an Unwrapper like <code>consumer increment(count: MonotonicallyIncreasingValue);</code>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opaque-types"><a class="header" href="#opaque-types">Opaque Types</a></h1>
<p>Programs of any significant size, particularly those developed among potentially large groups of developers, require a
significant level of coordination to ensure the program evolves in a controlled manner throughout entire development 
lifecycle. Claro aspires to provide users with tools to that end. One particular technique that can aid this is hiding
the internal representation of a data structure. There are various reasons why this may be desirable:</p>
<div class="table-wrapper"><table><thead><tr><th>Concern</th><th>Example Undesirable Outcome</th></tr></thead><tbody>
<tr><td>Internal representation is subject to significant future change</td><td>Many downstream usages of the Type's internal representation arise, making future changes to the Type's internal representation unbearably onerous</td></tr>
<tr><td>Internal representation must restrict the legal domain of values</td><td>Users directly manipulating the value can invalidate these necessary constraints and produce invalid data</td></tr>
<tr><td>Internal representation is encoded in some way not explicitly described by the types themselves</td><td>Complex data structures, such as a Heap, may be represented internally as a simple <code>mut [int]</code> but a downstream user mutating this structure is inherently bug-prone</td></tr>
<tr><td>Internal representation contains Type's that give access to sensitive behaviors</td><td>A database connection, for example, may have various open channels to the DB itself, but this doesn't mean it's safe to use this to manually send it arbitrary network reqs</td></tr>
</tbody></table>
</div>
<p>To address all of these, developers typically <strong>hide the internal representation</strong> of such sensitive Types so that
any direct interaction with them must necessarily go through &quot;the front door&quot; of a certain published, verified API. 
Claro honors this as a first class capability, by allowing Types exported by a Module definition to be marked &quot;Opaque&quot;:</p>
<h4 id="fig-1-62"><a class="header" href="#fig-1-62"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1.claro_module_api
opaque newtype Person
</code></pre>
<hr />
<p>Now, consumers of a Module with the above Type definition will not be exposed whatsoever to any internal details of its
internal representation, which may initially look like:</p>
<h4 id="fig-2-51"><a class="header" href="#fig-2-51"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-impl.claro
newtype Person : struct {
  name: string,
  userID: int
}
</code></pre>
<hr />
<p>but then, in the future, it could be updated to something like:</p>
<h4 id="fig-3-40"><a class="header" href="#fig-3-40"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-impl.claro
newtype Person : struct {
  name: string,
  userID: ID::UUID  # UPDATED
}
</code></pre>
<hr />
<p>and you'd have a guarantee that you wouldn't have to make <strong>any</strong> changes outside the defining Module itself because it
was never possible for any downstream consumer to actually depend on the internal representation directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-values"><a class="header" href="#static-values">Static Values</a></h1>
<p>In addition to Type definitions and Procedure signatures, Modules are also able to export static (read: unchanging)
values. This seemingly simple feature actually addresses the core value add of heavyweight &quot;Dependency Injection&quot;
frameworks like Guice, Dagger, or Spring<sup class="footnote-reference"><a href="#1">1</a></sup> while providing the static compile-time validation that you'd expect of a
first-class programming language feature. </p>
<p>The below Module API exports a struct containing a simple server config that's fixed (static) throughout the server's
lifecycle:</p>
<h4 id="fig-1-63"><a class="header" href="#fig-1-63"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1.claro_module_api

# Throughout the server's lifetime this configuration won't change.
static SERVER_CONFIG : ServerConfig;

alias ServerConfig : struct {
  server_name: string,
  port: int,
  logging: struct {
    filename: string
  },
  database: struct {
    host: string,
    port: int,
    database_name: string
  }
}
</code></pre>
<hr />
<p>The value itself will be provided by implementing a <code>provider static_&lt;static value name&gt;() -&gt; &lt;static value type&gt;</code>, for
example, the following provider implementation reads and parses<sup class="footnote-reference"><a href="#2">2</a></sup> the config values from a JSON resource<sup class="footnote-reference"><a href="#3">3</a></sup> file:</p>
<h4 id="fig-2-52"><a class="header" href="#fig-2-52"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-js">{
  &quot;server_name&quot;: &quot;My Server&quot;,
  &quot;port&quot;: 8080,
  &quot;logging&quot;: {
    &quot;filename&quot;: &quot;server.log&quot;
  },
  &quot;database&quot;: {
    &quot;host&quot;: &quot;localhost&quot;,
    &quot;port&quot;: 5432,
    &quot;database_name&quot;: &quot;my_database&quot;
  }
}
</code></pre>
<hr />
<h4 id="fig-3-41"><a class="header" href="#fig-3-41"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-impl.claro
provider static_SERVER_CONFIG() -&gt; ServerConfig {
  resources::ConfigJSON
    |&gt; files::readOrPanic(^)
    |&gt; var parsedConfig: std::ParsedJson&lt;ServerConfig&gt; = fromJson(^);

  var parsedResult = unwrap(parsedConfig).result;
  if (parsedResult instanceof ServerConfig) {
    # Config has correct format and was parsed successfully.
    return parsedResult;
  }
  # ... Invalid Config File Format Handling ...
<span class="boring">  # TODO(steving) In the future Claro should support an explicit `Panic(&quot;Reason&quot;)`.
</span><span class="boring">  # TODO(steving) This server shouldn't even be allowed to actually startup.
</span><span class="boring">  return {
</span><span class="boring">    server_name = &quot;Fake Server&quot;,
</span><span class="boring">    port = -1,
</span><span class="boring">    logging = {
</span><span class="boring">      filename = &quot;server.log&quot;
</span><span class="boring">    },
</span><span class="boring">    database = {
</span><span class="boring">      host = &quot;localhost&quot;,
</span><span class="boring">      port = -1,
</span><span class="boring">      database_name = &quot;Fake Database&quot;
</span><span class="boring">    }
</span><span class="boring">  };
</span>}
</code></pre>
<hr />
<div class="warning"><b>This syntax is very likely to change.</b> Expressing this via a <i>naming convention</i> is
extremely undesirable, so any suggestions for a more appropriate syntax are very welcome.</div>
<p>And now, a downstream dependent of the Module exporting the <code>SERVER_CONFIG</code> static value can just directly use the value
as it was initialized at program startup by the given provider.</p>
<h4 id="fig-4-23"><a class="header" href="#fig-4-23"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro">var config = Config::SERVER_CONFIG;
print(&quot;Server Name: {config.server_name}&quot;);
print(&quot;Port:        {config.port}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Server Name: My Server
Port:        8080
</code></pre>
<hr />
<h2 id="static-values-must-be-deeply-immutable"><a class="header" href="#static-values-must-be-deeply-immutable">Static Values Must be Deeply Immutable</a></h2>
<p>The primary restriction placed on Static Values is that they <strong>must be deeply immutable</strong> to prevent static values from
being used in such a way could lead to data races. Because Static Values can be directly referenced <em>anywhere</em> in your
program, this means they can be referenced directly or transitively by
<a href="module_system/module_apis/static_values/../../../graph_procedures/graph_procedures.generated_docs.html">Graph Procedures</a> or by Lambdas directly scheduled to
execute off the main thread using the StdLib's <a href="module_system/module_apis/static_values/../../../stdlib/futures_module.generated_docs.html">futures module</a>. This
must be prevented in order to keep with Claro's philosophy of making it impossible for two threads to share mutable
state.</p>
<h2 id="initialization-order"><a class="header" href="#initialization-order">Initialization Order</a></h2>
<p>In general, Static Values are initialized on program startup<sup class="footnote-reference"><a href="#4">4</a></sup> before a single line of the &quot;main file&quot; (determined by 
<code>claro_binary(name = ..., main_file = ..., deps = ...)</code>) ever actually ran. To demonstrate this, let's add a 
<code>print(...)</code> statement to both the Static Value's provider, and to the main file that references it:</p>
<h4 id="fig-5-16"><a class="header" href="#fig-5-16"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-impl.claro
provider static_SERVER_CONFIG() -&gt; ServerConfig {
  log(&quot;STATIC VALUE INITIALIZATION&quot;);
  # ...
<span class="boring">  resources::ConfigJSON
</span><span class="boring">    |&gt; files::readOrPanic(^)
</span><span class="boring">    |&gt; var parsedConfig: std::ParsedJson&lt;ServerConfig&gt; = fromJson(^);
</span>
<span class="boring">  var parsedResult = unwrap(parsedConfig).result;
</span><span class="boring">  if (parsedResult instanceof ServerConfig) {
</span><span class="boring">    # Config has correct format and was parsed successfully.
</span><span class="boring">    return parsedResult;
</span><span class="boring">  }
</span><span class="boring">  # ... Invalid Config File Format Handling ...
</span><span class="boring">  # TODO(steving) In the future Claro should support an explicit `Panic(&quot;Reason&quot;)`.
</span><span class="boring">  # TODO(steving) This server shouldn't even be allowed to actually startup.
</span><span class="boring">  return {
</span><span class="boring">    server_name = &quot;Fake Server&quot;,
</span><span class="boring">    port = -1,
</span><span class="boring">    logging = {
</span><span class="boring">      filename = &quot;server.log&quot;
</span><span class="boring">    },
</span><span class="boring">    database = {
</span><span class="boring">      host = &quot;localhost&quot;,
</span><span class="boring">      port = -1,
</span><span class="boring">      database_name = &quot;Fake Database&quot;
</span><span class="boring">    }
</span><span class="boring">  };
</span>}
consumer log(msg: string) {
  print(&quot;LOG: {msg}&quot;);
}
</code></pre>
<hr />
<h4 id="fig-6-9"><a class="header" href="#fig-6-9"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro">Config::log(&quot;START MAIN FILE&quot;);

var config = Config::SERVER_CONFIG;
print(&quot;Server Name: {config.server_name}&quot;);
print(&quot;Port:        {config.port}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
LOG: STATIC VALUE INITIALIZATION
LOG: START MAIN FILE
Server Name: My Server
Port:        8080
</code></pre>
<hr />
<h2 id="lazy-static-values"><a class="header" href="#lazy-static-values">&quot;Lazy&quot; Static Values</a></h2>
<p>It's possible, however, that it might not be desirable for this sort of static initialization to happen eagerly like
this (for example if the value isn't guaranteed to even be used). So, Claro allows static values to optionally be
declared <code>lazy</code>:</p>
<h4 id="fig-7-5"><a class="header" href="#fig-7-5"><em>Fig 7:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring"># ex1.claro_module_api
</span><span class="boring">
</span><span class="boring"># Throughout the server's lifetime this configuration won't change.
</span>lazy static SERVER_CONFIG : ServerConfig;
<span class="boring">
</span><span class="boring">alias ServerConfig : struct {
</span><span class="boring">  server_name: string,
</span><span class="boring">  port: int,
</span><span class="boring">  logging: struct {
</span><span class="boring">    filename: string
</span><span class="boring">  },
</span><span class="boring">  database: struct {
</span><span class="boring">    host: string,
</span><span class="boring">    port: int,
</span><span class="boring">    database_name: string
</span><span class="boring">  }
</span><span class="boring">}
</span></code></pre>
<hr />
<p>which will effectively wrap every reference to the value in logic that will first check if the value still needs to be
initialized and the initialization logic will be performed exactly once the very first time a read of the Lazy Static 
Value is actually executed at runtime:</p>
<h4 id="fig-8-2"><a class="header" href="#fig-8-2"><em>Fig 8:</em></a></h4>
<hr />
<pre><code class="language-claro">Config::log(&quot;START MAIN FILE&quot;);

var config = Config::SERVER_CONFIG;
print(&quot;Server Name: {config.server_name}&quot;);
print(&quot;Port:        {config.port}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>LOG: START MAIN FILE
LOG: STATIC VALUE INITIALIZATION
Server Name: My Server
Port:        8080
</code></pre>
<hr />
<p>In the case of this example, lazy initialization could mean that the file read of the JSON config resource never
actually needs to occur if it would never actually be read. This is a fairly insignificant performance optimization, but
one that will be welcome to any developers that have become accustomed to this sort of capability being provided by more
heavyweight dependency injection frameworks.</p>
<h2 id="static-value-providers-may-depend-on-other-static-values"><a class="header" href="#static-value-providers-may-depend-on-other-static-values">Static Value Providers May Depend on Other Static Values</a></h2>
<p>Finally, it's worth explicitly noting that Static Value providers may depend on other Static Values, with the only
restriction being that circular dependencies between Static Value providers are forbidden. In fact, Claro will reject
them at compile time to ensure that you don't accidentally create an infinite loop during initialization.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Claro doesn't support these DI frameworks' concept of &quot;scopes&quot; explicitly, but Claro's Static Values could be 
conceptually considered to be in the <a href="https://github.com/google/guice/wiki/Scopes#singleton">&quot;Singleton&quot; scope</a> in any
of the mentioned DI frameworks.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Learn more about Claro's support for automatic <a href="module_system/module_apis/static_values/../../../json_parsing/json_parsing.generated_docs.html">JSON Parsing</a>.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Learn more about Claro's support for Resource Files in the StdLib's <a href="module_system/module_apis/static_values/../../../stdlib/files_module.generated_docs.html">files module</a>.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>To be very explicit, technically Static Values are instantiated the first time that the JVM's ClassLoader loads 
the generated Class representing the Module exporting the Static Value. Hence the calls to <code>Config::log(...)</code> to
make the example more compelling.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flags"><a class="header" href="#flags">Flags</a></h1>
<p>An incredibly common pattern in many software projects is parsing command line flags on startup to configure the
behavior of a program. For example in backend web services the same service frequently gets reconfigured via flags to
run in various different environments (e.g. test/dev/prod). However, in spite of the pattern's universality, most
languages seem to ignore the fact and leave Flag parsing as an exercise for the user. This realistically leaves users
either running off to download some 3rd-party library or writing some often poorly maintained boilerplate parsing code
themselves. Claro aims to provide a lightweight Flag parsing mechanism as a first-class language feature so that you can
skip most of the manual toil for such a simple need.</p>
<p>Claro's Flags are a special case of <a href="module_system/module_apis/flags/../static_values/static_values.generated_docs.html">Static Values</a> that can be
defined and exported by a Module API<sup class="footnote-reference"><a href="#1">1</a></sup>: </p>
<h4 id="fig-1-64"><a class="header" href="#fig-1-64"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1.claro_module_api

# Set this flag on the command line.
flag env: string;
</code></pre>
<hr />
<p>Then, just like any other Static Value, it can be referenced directly by anyone with a dependency on the defining Module
as in the example below:</p>
<h4 id="fig-2-53"><a class="header" href="#fig-2-53"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-python">load(&quot;//@claro-lang:rules.bzl&quot;, &quot;claro_module&quot;, &quot;claro_binary&quot;)

# This module is the one defining the `env` Flag.
claro_module(
    name = &quot;config&quot;,
    module_api_file = &quot;ex1.claro_module_api&quot;,
    # Notice no srcs are specified as Flags do not require a provider like other Static Values do.
)

claro_binary(
    name = &quot;demo&quot;,
    main_file = &quot;ex1-test.claro&quot;,
    deps = {&quot;Config&quot;: &quot;:config&quot;},
)
</code></pre>
<hr />
<h4 id="fig-3-42"><a class="header" href="#fig-3-42"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-test.claro
Config::env |&gt; print(&quot;env: \&quot;{^}\&quot;&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>env: &quot;&quot;
</code></pre>
<hr />
<p>Flags are different than general Static Values simply in the way their values are instantiated. Rather than implementing
a provider that will be automatically run to instantiate the value, Flags are actually automatically parsed from the
command line args passed to the program at runtime. <strong>In the example above, the Flag wasn't explicitly set when the
program was run, so the value was defaulted to the empty string</strong>.</p>
<h2 id="setting-a-flag-value-on-the-command-line"><a class="header" href="#setting-a-flag-value-on-the-command-line">Setting a Flag Value on the Command Line</a></h2>
<p>As there are multiple ways to run Claro programs during development, you'll need to know how to actually set Flag values
using each approach.</p>
<h3 id="passing-flags-to-programs-executed-via-bazel-run-"><a class="header" href="#passing-flags-to-programs-executed-via-bazel-run-">Passing Flags to Programs Executed via <code>bazel run ...</code></a></h3>
<p>Of course, as you've seen in the 
<a href="module_system/module_apis/flags/../../../getting_started/first_program/first_program.generated_docs.html#now-execute-your-program">Getting Started Guide</a>
the easiest way to run a Claro program during development is using the <code>bazel run ...</code> command. But because Bazel 
<em>itself</em> accepts command line Flags, you'll need to explicitly indicate <em>which</em> command line args should be consumed by
Bazel and which should be passed along to the Claro program. You'll do this by simply using a standalone <code>--</code>. Bazel
consumes every arg to the left, and anything following gets passed along to the program you're trying to run.</p>
<p><em>Note: The below recording was made with <a href="https://asciinema.org/" target="_blank">asciinema</a> - try pausing
and copying any text.</em></p>
<script async id="asciicast-639326" src="https://asciinema.org/a/639326.js" data-preload="true" data-autoplay="false"></script>
<h3 id="passing-flags-to-deploy-jar"><a class="header" href="#passing-flags-to-deploy-jar">Passing Flags to Deploy Jar</a></h3>
<p>Instead, you can build your program as an executable &quot;Deploy Jar&quot; and execute the Jar using the <code>java</code> command, passing
command line Flags as you would to any other command:</p>
<p><em>Note: The below recording was made with <a href="https://asciinema.org/" target="_blank">asciinema</a> - try pausing
and copying any text.</em></p>
<script async id="asciicast-639444" src="https://asciinema.org/a/639444.js" data-preload="true" data-autoplay="false"></script>
<h2 id="deriving-static-values-from-flags"><a class="header" href="#deriving-static-values-from-flags">Deriving Static Values From Flags</a></h2>
<p>Now, the power of Flags is often exposed when used to determine the initialization of Static Values. For example,
expanding upon the simple <code>env</code> example above, we could export another Static Value, and determine its value based on
whatever value was assigned to the <code>env</code> Flag on the command line.</p>
<h4 id="fig-4-24"><a class="header" href="#fig-4-24"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"># Set this flag on the command line.
flag env: string;

static SUBJECT: string;
</code></pre>
<hr />
<h4 id="fig-5-17"><a class="header" href="#fig-5-17"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro">provider static_SUBJECT() -&gt; string {
  # `env` here is referring to the flag defined in this module's API.
  match (env) {
    case &quot;dev&quot; -&gt; return &quot;DEVS&quot;;
    case &quot;prod&quot; -&gt; return &quot;Users&quot;;
    # If the flag wasn't set, it will default to the empty string.
    case &quot;&quot; -&gt; return &quot;is anyone out there?&quot;;
    case _ -&gt; return env;
  }
}
</code></pre>
<hr />
<p>And now, a test program could reference the Static Value, and the program's output will be dependent on the Flag value
passed on the command line at runtime:</p>
<h4 id="fig-6-10"><a class="header" href="#fig-6-10"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-test2.claro
Config::SUBJECT |&gt; print(&quot;Hello, {^}!&quot;);
</code></pre>
<hr />
<p><em>Note: The below recording was made with <a href="https://asciinema.org/" target="_blank">asciinema</a> - try pausing
and copying any text.</em></p>
<script async id="asciicast-639488" src="https://asciinema.org/a/639488.js" data-preload="true" data-autoplay="false"></script>
<h2 id="supported-flag-types"><a class="header" href="#supported-flag-types">Supported Flag Types</a></h2>
<p>Claro has to manually emit logic to parse command line args, and as such there's currently only support for parsing the
following basic types that are most likely to be found in command line args: </p>
<ul>
<li><code>boolean</code></li>
<li><code>string</code></li>
<li><code>int</code></li>
<li><code>[string]</code></li>
</ul>
<p>Claro will statically reject any Flags of unsupported types. For example, Claro won't automatically parse arbitrary
structs from the command line. (Although it's likely that in the future Claro will standardize its string encoding of
all types and provide some extended support for automatically decoding them from strings).</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Command line Flag parsing in most other languages can only be done by explicitly handling the command line args
list in the program's &quot;main method&quot; (or equivalent). But in Claro, Flags can be arbitrarily defined by <em>any Module</em> in
the entire program. The only thing to keep in mind is that the very nature of Flags being given on the command line 
means that their names <em>must</em> be globally unique. So, if you plan to include Flags in a Module that you're publishing
for a wide audience, make sure that you use somehow try to ensure that your Flag names can at least be <em>reasonably</em>
expected to be globally unique. One suggestion would be to prefix all Flag names with the published name of your Bazel
module that's been pushed to the 
<a href="module_system/module_apis/flags/../../../getting_started/understanding_starter_project/understanding_starter_project.generated_docs.html#modulename--example-claro-module">Bazel Central Registry</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-services"><a class="header" href="#http-services">HTTP Services</a></h1>
<p>As Claro provides simple HTTP support out of the box, you can export HTTP Service definitions from Module APIs. For
example, the following Buggy Buggies game<sup class="footnote-reference"><a href="#1">1</a></sup> can be controlled by sending HTTP GET requests to the endpoints defined
below:</p>
<img src="module_system/module_apis/http_services/../../../images/BuggyBuggiesAPI.png" width="560" height="440" />
<p>So, we can encode this api as an HTTP Service that can be called programmatically by Claro programs by exporting the
following from a Module API:</p>
<h4 id="fig-1-65"><a class="header" href="#fig-1-65"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1.claro_module_api

# This encodes the public API of the Buggy-Buggies HTTP service.
# Claro will generate a non-blocking RPC client for you via the following:
#   `var myClient: HttpClient&lt;BuggyBuggies&gt; = http::getHttpClient(&quot;https://buggy-buggies.gigalixirapp.com&quot;);`
HttpService BuggyBuggies {
  hostGame: &quot;/api/host/{handle}&quot;,
  friendsJoin: &quot;/api/game/{gameId}/join/{handle}&quot;,
  move: &quot;/api/game/{gameId}/player/{secret}/move/{direction}&quot;,
  worldInfo: &quot;/api/game/{gameId}/player/{secret}/info&quot;,
  reset: &quot;/api/game/{gameId}/player/{secret}/reset&quot;
}

# Now there's a single static definition of which client will be used for sending reqs to the Buggy Buggies server.
static BUGGY_BUGGIES_CLIENT: HttpClient&lt;BuggyBuggies&gt;;
</code></pre>
<hr />
<p>In this case the static HTTP client being exported by this Module will allow messages to be sent to the local port that
the Buggy Buggies game is running on:</p>
<h4 id="fig-2-54"><a class="header" href="#fig-2-54"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1-impl.claro

provider static_BUGGY_BUGGIES_CLIENT() -&gt; HttpClient&lt;BuggyBuggies&gt; {
  # This client will send reqs to localhost but could use a public endpoint.
  return http::getHttpClient(&quot;http://localhost:4000&quot;);
}
</code></pre>
<hr />
<p>Now, a dependent can easily make calls to the various HTTP endpoints exposed by the service and from the dependent's
perspective it appears just like any other procedure call returning a <code>future&lt;...&gt;</code>.</p>
<h4 id="fig-3-43"><a class="header" href="#fig-3-43"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var hostGameRes: oneof&lt;string, std::Error&lt;string&gt;&gt;
  &lt;-| BuggyBuggies::hostGame(BuggyBuggies::BUGGY_BUGGIES_CLIENT, &quot;jason&quot;);

print(&quot;Host Game Response:\n{hostGameRes}&quot;);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Host Game JSON Response:
{&quot;reason&quot;:null,&quot;success&quot;:true,&quot;result&quot;:{&quot;watch&quot;:&quot;http://localhost:4000/game/04cfad01&quot;,&quot;secret&quot;:&quot;7f3b8ae5&quot;,&quot;game_id&quot;:&quot;04cfad01&quot;,&quot;example&quot;:&quot;curl -X GET http://localhost:4000/api/game/04cfad01/player/7f3b8ae5/move/N&quot;}}
</code></pre>
<hr />
<p>Now, you can imagine how a more complex Claro program could use the HTTP client to this service to make a bot that
automatically plays the game collecting as much gold as possible.</p>
<p><img src="module_system/module_apis/http_services/../../../images/BuggyBuggiesDemo.gif" alt="Buggy Buggies Demo" /></p>
<p>Check out the 
<a href="https://github.com/JasonSteving99/claro-lang/tree/033326c49ee5e53066e47ad8ea0e922ebd41956a/examples/claro_programs/demo_server/buggy_buggies" target="_blank">full-fledged implementation</a>
of the Claro program controlling the buggy in the above gif.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Buggy Buggies was built by <a href="https://github.com/jzwood/buggy-buggies">Jake Wood</a>, thank you for sharing this!</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>Claro's deep integration with Bazel allows it to isolate all dependency-related concerns to the Build system rather than
cluttering the core language itself with such concerns. Claro's leveraging of Bazel's builtin visibility enforcement
features is a powerful example of this. Whereas most programming languages tend to only expose very coarse-grained
visibility controls (e.g. public/private), Bazel provides Claro programs with access to a wide range of extremely
fine-grained visibility controls.</p>
<p>You can read more in detail about 
<a href="https://bazel.build/concepts/visibility" target="_blank">Visibility in Bazel's docs</a>, or you can get the
important overview below. </p>
<div class="warning">
<p>If you're using GitHub to host your codebase, Bazel's Visibility enforcement becomes <em>even more powerful</em> when used in
combination with 
<a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners" target="_blank"><code>CODEOWNERS</code></a>
which gives you a mechanism to ensure that Visibility declarations are actually enforceable and can't simply be changed
by someone without first taking into account <em>why</em> the visibility was constrained to a certain level in the first place.</p>
</div>
<h2 id="private-visibility"><a class="header" href="#private-visibility">Private Visibility</a></h2>
<p>All targets are &quot;private&quot; by default. So, if you don't want to allow any other targets defined outside the current BUILD
file to take a dependency on a given target, you can simply omit a <code>visibility = ...</code> declaration:</p>
<h4 id="fig-1-66"><a class="header" href="#fig-1-66"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-python"><span class="boring">load(&quot;//@claro-lang:rules.bzl&quot;, &quot;claro_module&quot;)
</span><span class="boring">
</span>claro_module(
    name = &quot;example&quot;,
    # ...
<span class="boring">    module_api_file = &quot;example.claro_module_api&quot;,
</span><span class="boring">    srcs = [&quot;example.claro&quot;],
</span>    # Visibility defaults to &quot;private&quot;.
    # Alternatively you could explicitly declare the target &quot;private&quot; using:
    #   visibility = [&quot;//visibility:private&quot;],
)
</code></pre>
<hr />
<div class="warning">
<p><strong>Note</strong>: All targets defined in the same <code>BUILD</code> file are implicitly Visible to each other - meaning that they can
place a dependency on one another freely no matter what <code>visiblity = ...</code> declaration is listed in each target's
declaration.</p>
</div>
<h2 id="target-visibility"><a class="header" href="#target-visibility">Target Visibility</a></h2>
<p>In many cases, you'll be designing Modules to only be consumed by a very specific set of dependents. In this case, you
can <strong>explicitly name the specific targets</strong> that should be allowed to place a dependency on your target:</p>
<h4 id="fig-2-55"><a class="header" href="#fig-2-55"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-python"><span class="boring">load(&quot;//@claro-lang:rules.bzl&quot;, &quot;claro_module&quot;)
</span><span class="boring">
</span>claro_module(
    name = &quot;example&quot;,
    # ...
<span class="boring">    module_api_file = &quot;example.claro_module_api&quot;,
</span><span class="boring">    srcs = [&quot;example.claro&quot;],
</span>    # Now, visibility is granted to the specifically mentioned target.
    visibility = [&quot;//some/other/specific:target&quot;],
)
</code></pre>
<hr />
<p><strong>This is by far the recommended approach. All other more permissive Visibility declarations detailed below should be
approached with caution.</strong></p>
<h2 id="package-visibility"><a class="header" href="#package-visibility">Package Visibility</a></h2>
<p>Depending on how your codebase gets organized, you'll likely run into the situation where a certain Module can be
generally useful for many Modules in a package. Rather than needing to list each target individually, you can whitelist
the entire package to have Visibility on a certain module.</p>
<h4 id="fig-3-44"><a class="header" href="#fig-3-44"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-python"><span class="boring">load(&quot;//@claro-lang:rules.bzl&quot;, &quot;claro_module&quot;)
</span><span class="boring">
</span>claro_module(
    name = &quot;example&quot;,
    # ...
<span class="boring">    module_api_file = &quot;example.claro_module_api&quot;,
</span><span class="boring">    srcs = [&quot;example.claro&quot;],
</span>    # Now, visibility is granted to every target in the `//some/other` directory (package).
    visibility = [&quot;//some/other:__pkg__&quot;],
)
</code></pre>
<hr />
<h2 id="subpackages-visibility"><a class="header" href="#subpackages-visibility">Subpackages Visibility</a></h2>
<p>Somewhat more rarely, you may also end up with a codebase where a particular Module is useful for many Modules in both a
package and all subpackages beneath it. Rather than needing to explicitly list each package, you can make the target 
Visible to all other targets at or &quot;below&quot; a certain package. </p>
<div class="warning">
This should be used sparingly when you have confidence that the design constraints of your codebase will be maintained
over time. Remember that the proliferation of many dependencies on a particular Module put that Module at risk at
becoming extremely difficult to change in the future.
</div>
<h4 id="fig-4-25"><a class="header" href="#fig-4-25"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-python"><span class="boring">load(&quot;//@claro-lang:rules.bzl&quot;, &quot;claro_module&quot;)
</span><span class="boring">
</span>claro_module(
    name = &quot;example&quot;,
    # ...
<span class="boring">    module_api_file = &quot;example.claro_module_api&quot;,
</span><span class="boring">    srcs = [&quot;example.claro&quot;],
</span>    # Now, visibility is granted to every target at or below the `//some/other` directory (package).
    visibility = [&quot;//some/other:__subpackages__&quot;],
)
</code></pre>
<hr />
<h2 id="public-visibility-discouraged"><a class="header" href="#public-visibility-discouraged">Public Visibility (Discouraged)</a></h2>
<div class="warning">
<p>While it's possible to make a certain target visible to <strong>every</strong> other target in the entire project, <strong>this is
discouraged</strong>. You will find that public Visibility can lead to a proliferation of dependencies that can sometimes make 
the long-term maintenance of the overall project that much more difficult. The more dependencies that a particular
Module has, the more difficult it gets to make any changes to that Module's public API. Feel free to use this feature, 
but please do it consciously, don't just get in a habit of doing this by default for convenience.</p>
</div>
<h4 id="fig-5-18"><a class="header" href="#fig-5-18"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-python"><span class="boring">load(&quot;//@claro-lang:rules.bzl&quot;, &quot;claro_module&quot;)
</span><span class="boring">
</span>claro_module(
    name = &quot;example&quot;,
    # ...
<span class="boring">    module_api_file = &quot;example.claro_module_api&quot;,
</span><span class="boring">    srcs = [&quot;example.claro&quot;],
</span>    # Now, visibility is granted to every target globally.
    visibility = [&quot;//visibility:public&quot;],
)
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="swapping-dependencies"><a class="header" href="#swapping-dependencies">Swapping Dependencies</a></h1>
<p>Claro's Module system was very carefully designed to guarantee that it's <strong>statically impossible for two separate
modules to be
<a href="https://www.wikiwand.com/en/Coupling_(computer_programming)#introduction" target="_blank">&quot;tightly coupled&quot;</a></strong>.
In this section we'll dive into exactly what that means.</p>
<p>As you've already seen in previous sections, Claro Modules explicitly declare a public API that indicates the full set 
of procedures/values/Types that the Module's consumers will gain access to. Of course, some form of this is present in
every language. The unique distinction is that Claro Module dependencies can be directly swapped out to any other Module
with an appropriate API <strong>without changing a single line of code in any <code>.claro</code> source files</strong>. </p>
<p>For example, the below API...</p>
<h4 id="fig-1-67"><a class="header" href="#fig-1-67"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># get_message.claro_module_api
provider getMessage() -&gt; string;
</code></pre>
<hr />
<p>...could be implemented by multiple Modules...</p>
<h4 id="fig-2-56"><a class="header" href="#fig-2-56"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_binary&quot;, &quot;claro_module&quot;)

claro_module(
    name = &quot;hello_world&quot;,
    module_api_file = &quot;get_message.claro_module_api&quot;,
    srcs = [&quot;hello_world.claro&quot;],
)
claro_module(
    name = &quot;look_ma&quot;,
    module_api_file = &quot;get_message.claro_module_api&quot;,
    srcs = [&quot;look_ma.claro&quot;],
)
# ...
</code></pre>
<hr />
<p>...and then the <strong>exact same <code>.claro</code> source code</strong>...</p>
<h4 id="fig-3-45"><a class="header" href="#fig-3-45"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># example.claro
print(Msg::getMessage());
</code></pre>
<hr />
<p>...could be compiled against either Module...</p>
<h4 id="fig-4-26"><a class="header" href="#fig-4-26"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
claro_binary(
    name = &quot;test&quot;,
    main_file = &quot;example.claro&quot;,
    deps = {
        &quot;Msg&quot;: &quot;:hello_world&quot;,
    }
)
</code></pre>
<hr />
<h4 id="fig-5-19"><a class="header" href="#fig-5-19"><em>Fig 5:</em></a></h4>
<hr />
<pre><code>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)
Hello, World!
</code></pre>
<hr />
<p>...and the behavior would depend on which dependency was chosen...</p>
<h4 id="fig-6-11"><a class="header" href="#fig-6-11"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
claro_binary(
    name = &quot;test&quot;,
    main_file = &quot;example.claro&quot;,
    deps = {
        &quot;Msg&quot;: &quot;:look_ma&quot;,  # Swapped for `:hello_world`.
    }
)
</code></pre>
<hr />
<h4 id="fig-7-6"><a class="header" href="#fig-7-6"><em>Fig 7:</em></a></h4>
<hr />
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)
----------------------
| Look ma, no hands! |
----------------------
</code></pre>
<hr />
<h2 id="dep-validity-is-based-on-usage"><a class="header" href="#dep-validity-is-based-on-usage">Dep Validity is Based on Usage</a></h2>
<p>The other subtle point that's likely easy to miss if it's not pointed out explicitly is that the validity of a Module
dependency is completely dependent upon the <em>usage</em> of the dependency. In less opaque terms, this just means that a
Module dependency is valid if the Module's API actually exports everything that is <em>used</em> by the consuming code. The
consuming code doesn't make any constraints on <em>anything other than what it actually uses</em>. So, a dependency can be
swapped for another that actually exports a <em>completely different</em> API, so long as it <strong><em>at least</em></strong> exports everything
that the consuming code <em>actually used</em> from the original Module's API. </p>
<p>For example, if a third Module actually implemented a totally different API such as:</p>
<h4 id="fig-8-3"><a class="header" href="#fig-8-3"><em>Fig 8:</em></a></h4>
<hr />
<pre><code class="language-claro"># extra_exports.claro_module_api
provider getMessage() -&gt; string;

provider getMessageFromDB() -&gt; future&lt;string&gt;;

opaque newtype SecretMessage

static SOME_OTHER_MESSAGE : SecretMessage;
</code></pre>
<hr />
<p>the dependency would <em>still</em> be valid because <code>example.claro</code> only actually <em>uses</em> the <code>getMessage(...)</code> procedure that
is exported by both <code>:look_ma</code> and <code>:hello_world</code>. </p>
<p>This single design decision actually enables a huge amount of Build time configurability options. If you'd like to see
more about how you can take advantage of this, read about how you can swap dependencies programmatically using 
<a href="module_system/swapping_deps/../../metaprogramming/swapping_deps/swapping_deps.generated_docs.html">Build flags</a>. And if you're interested in becoming
a power-user, this feature can be leveraged in some very powerful ways via
<a href="module_system/swapping_deps/../../metaprogramming/metaprogramming.generated_docs.html">Build Time Metaprogramming</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>There is one remaining significant factor that a programming language should provide builtin mechanisms for in order to
enable programmers to develop very highly performant code that can take full advantage of the available CPU hardware:
concurrency.</p>
<p>Sometimes you have already squeezed every last drop of performance out of your algorithmic designs, or you are
constrained by waiting for slow operations to complete (DB requests, networked API calls, file I/O) before your program
may even make progress through its workload. In these situations, often the <em>only</em> way possible to get more work done is
to do more than one thing at the same time.</p>
<p>In order to achieve this, Claro asks you to first think about the dependencies between the various steps in your desired
workflow. These dependencies come in the form of data, so you should be asking yourself, &quot;At any given step in my
workflow, what data do I need to be available in order to make the decisions I'll need to make or to take the actions
needed?&quot;. When you start to reason in this way, you will likely come across opportunities where certain components of
your workflow are completely independent, in the sense that they do not rely at all upon the same data in order to do
their work. Examples of this are easy to see in web service request handling (each reg can typically be handled
independently of any others), or if you look a bit closer it can also be seen in MapReduce style batch processing (the
large input is partitioned for the workers to map independently of other partitions. There will be many more examples,
but the key takeaway is that if these work items can be partitioned to be completely independent like this, then they
should be run at exactly the same time rather than sequentially. In a single-machine context, you achieve this by using
multiple threads to execute your program, or portions of your program, concurrently.</p>
<p>Unfortunately, using threads is known to have inherent dangers. Mistakes with threaded programs have been known to
cause &quot;deadlocking&quot; or other issues where a program becomes completely stock and is unable to make forward progress.
Alternatively, you may run into &quot;data races&quot; where multiple threads attempt to read/write the same shared data
simultaneously, each not knowing that another thread may be impacting or be impacted by the state change - this leads to
consistency problems where threads end up operating on stale, corrupted, or inconsistent data. These have tended to be
reasons for people to fully avoid working with multithreaded code at all - but that caution is just leaving performance
on the table. Thankfully, Claro addresses these issues and provides convenient, fearless concurrency! </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-procedures"><a class="header" href="#graph-procedures">Graph Procedures</a></h1>
<p>A <strong>Graph Procedure</strong> is much like a regular Procedure, with the only difference coming in how you structure code in
the body. As its mame implies, the body of a Graph Procedure will be structured as a graph of operations. Specifically
it is a DAG (directed-acyclic-graph) where each node in the DAG represents some isolated unit of work which may depend
on data produced by one or more other nodes and will produce its own resulting data. This structure is inherently
parallelizable as Claro can analyze the provided DAG to schedule nodes to run as soon as possible once all of the data
depended on by that node is ready. If any two nodes happen to have all of their dependent data ready at the same time,
then Claro may schedule those nodes to run concurrently.</p>
<p>In fact, not only does Claro enable concurrency, it actually is able to create the optimal schedule to run your nodes.
You don't need to think about scheduling at all, simply encode the data relationships between your operations, and Claro
does the rest.</p>
<p>All of this is achieved by scheduling nodes to run cooperatively on a threadpool currently configured to have a single
thread per CPU core (as of this writing, this default is the only option, but it will become configurable in the
future (i.e. Google Java services default to 50 request threads)). This allows you to trivially achieve significantly
better utilization of your available hardware resources than single threaded code, and much more safely and more easily
than can generally be achieved with a handcrafted threaded program.</p>
<p>The example below shows syntax vs DAG visualization:</p>
<h4 id="fig-1-68"><a class="header" href="#fig-1-68"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">graph function getWatchlist(userId: UserId) -&gt; future&lt;Watchlist&gt; {
    root recWatchlist &lt;- mergeTopTen(@movies, @shows);
    node movies &lt;- getTopMovies(@profile);
    node shows &lt;- getTopShows(@profile);
    node profile &lt;- getUserFromDB(userId);
}
</code></pre>
<hr />
<p>As you can see clearly in the diagram below, <code>profile</code> must run first but <code>movies</code> and <code>shows</code> may be computed
concurrently:</p>
<pre class="mermaid">
    graph TD
    profile(profile) --> movies
    profile --> shows
    movies(movies) --> recWatchList
    shows(shows) --> recWatchList
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-procedure-composition"><a class="header" href="#graph-procedure-composition">Graph Procedure Composition</a></h1>
<p>Great! Now Graph Procedures have given us free concurrency just by structuring our code declaratively rather than
imperatively. But as we'd realistically only want to put a few nodes in a single Graph Procedure from a code maintenance
and readability point of view, how do we write DAGS that are larger than just a few nodes? Composition! By this I mean
simply calling another Graph Procedure from within the current one.</p>
<p>For Example:</p>
<h4 id="fig-1-69"><a class="header" href="#fig-1-69"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">graph function bar(argB: int, argC: C) -&gt; future&lt;BarRes&gt; {
    root barRes &lt;- doBar(@barA);
    node barA &lt;- doBarA(@barB, @barC);
    node barB &lt;- doBarB(argB);
    node barC &lt;- doBarC(argC);
}
</code></pre>
<hr />
<pre class="mermaid">
    graph TD
    barC(barC) --> barA
    barB(barB) --> barA
    barA(barA) --> barRes
</pre>
<h4 id="fig-2-57"><a class="header" href="#fig-2-57"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">graph function foo(argA: A) -&gt; future&lt;FooRes&gt; {
    root fooRes &lt;- doFoo(@fooA, @fooB);
    node fooA &lt;- doFooA(@fooC);
    node fooB &lt;- bar(10, @fooC); # &lt;-- Graph Composition via Call to `bar`.
    node fooC &lt;- doFooC(argA);
}
</code></pre>
<hr />
<pre class="mermaid">
    graph TD
    fooC --> fooA
    fooC --> fooB
    fooB --> fooRes
    fooA --> fooRes
</pre>
<p>Because <code>foo(...)</code> includes a call to <code>bar(...)</code> as a subgraph, you can imagine that node <code>fooB</code> in graph <code>foo</code> actually
composes around the entire <code>bar</code> graph.</p>
<pre class="mermaid">
graph TD
    fooC --> fooA
    fooC --> barC
    barRes --> fooRes
    subgraph fooB
        barC --> barA
        barB --> barA
        barA --> barRes
    end
    fooA --> fooRes
</pre>
<p>This composition is extremely simple to understand in this way. The entire subgraph is started after all data
dependencies of the node wrapping it are ready.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-graph-procedures"><a class="header" href="#calling-graph-procedures">Calling Graph Procedures</a></h1>
<p>As you've already seen, if you call a Graph Procedure from within another Graph (composition) then Claro will
automatically handle the scheduling for you so that downstream nodes receive the value when it's ready. If you tried
calling a Graph Procedure from the top-level of a file, or from a non-Graph Procedure, then you'll see you receive a
value wrapped in a <code>future&lt;...&gt;</code>. This is because, as Claro follows the Async pattern for concurrent execution, some
nodes in the Graph Procedure may not be done running yet meaning that the overall Graph result may not be ready either.</p>
<p>For example, the <code>getWatchlist</code> Graph Procedure defined <a href="graph_procedures/calling_graph_procedures/../graph_procedures.generated_docs.html#fig-1">earlier</a> could be 
called as if it were a typical procedure call:</p>
<h4 id="fig-1-70"><a class="header" href="#fig-1-70"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">var someUserId: UserId = &quot;Jake&quot;;
</span>var graphRes: future&lt;Watchlist&gt; = getWatchlist(someUserId);
</code></pre>
<hr />
<p>There's not much you can do with a <code>future&lt;...&gt;</code> as it's really just a handle representing work whose result you'd like
to be able to access when it's ready. In this situation (outside a Graph), as a <code>future&lt;...&gt;</code> represents some
computation that may not be done yet, the <strong>only</strong> way to get the actual result is to block the current thread until the
other threads running the graph backing the <code>future&lt;...&gt;</code> have finished. To do so, use the &quot;blocking unwrap&quot; op <code>&lt;-|</code>:</p>
<h4 id="fig-2-58"><a class="header" href="#fig-2-58"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">var someUserId: UserId = &quot;Jake&quot;;
</span>var graphRes: Watchlist &lt;-| getWatchlist(someUserId);
print(graphRes);
</code></pre>
<p><em>Output:</em></p>
<pre><code>Watchlist([{name = Arrival}, {name = Doctor Who, episodeCount = 1000}])
</code></pre>
<hr />
<h2 id="graphs-execute-off-the-main-thread"><a class="header" href="#graphs-execute-off-the-main-thread">Graphs Execute off the &quot;Main&quot; Thread</a></h2>
<p>The number one thing to keep in mind is that between calling a Graph and blocking on its result, any operations between
<em>may</em> be running concurrently with the graph backing the <code>future&lt;...&gt;</code> (you don't know when the graph actually finishes
except that it will certainly have finished after the <code>&lt;-|</code> operation).</p>
<h4 id="fig-3-46"><a class="header" href="#fig-3-46"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">var graphFuture: future&lt;Foo&gt; = fooGraph(...);

# These two instructions are likely running concurrently with respect to
# `graphFuture`, as `graphFuture` likely hasn't finished yet, but they are
# definitely serialized with respect to each other.
doSomething(...);
doAnotherThing(...);

# Blocking the current thread to &quot;unwrap&quot; the `future&lt;Foo&gt;` into a raw `Foo`
# value we can operate on.
var graphRes: Foo &lt;-| graphFuture;
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-conditional-subgraph-execution"><a class="header" href="#advanced-conditional-subgraph-execution">(Advanced) Conditional Subgraph Execution</a></h1>
<p>There will be times when you actually only want to execute some <em>portion</em> of the graph upon satisfying some condition.
In this case, you may inject the node to a procedure expecting a <code>provider&lt;future&lt;...&gt;&gt;</code> so that you may conditionally
trigger execution yourself after checking the condition:</p>
<h4 id="fig-1-71"><a class="header" href="#fig-1-71"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">graph function getHomepage(userId : UserId) -&gt; future&lt;Homepage&gt; {
    root homepage &lt;- renderPage(@basePage, @maybeUpgradeBanner);
    node basePage &lt;- getBasePageFromDB();
    node maybeUpgradeBanner
        &lt;- getOptionalUpgradeBannerFromDB(
               @userIsPremium,
               @upgradeBanner  # &lt;-- &quot;Lazy Subgraph&quot; injection requested.
           );
    node userIsPremium &lt;- checkPremiumFromDB(userId);
    node upgradeBanner &lt;- getUpgradeBannerFromDB(@specialOffers);
    node specialOffers &lt;- getSpecialOffers();
}

function getOptionalUpgradeBannerFromDB(
    alreadyPremium: boolean,
    getUpgradeBannerFromDBProvider: provider&lt;future&lt;Html&gt;&gt;
) -&gt; future&lt;Html&gt; {
    if (alreadyPremium) {
        return futures::immediateFuture(getBasicBanner());
    }
    # Actually invoke the lazy subgraph here since the user isn't premium.
    return getUpgradeBannerFromDBProvider();
}

function getUpgradeBannerFromDB(specialOffers: [Offer]) -&gt; future&lt;Html&gt; {
  # ...
<span class="boring">  # Just an example - real implementation would send DB query.
</span><span class="boring">  _ = specialOffers;
</span><span class="boring">  return futures::immediateFuture(Html(&quot;&lt;div&gt;some html&lt;/div&gt;&quot;));
</span>}

provider getSpecialOffers() -&gt; future&lt;[Offer]&gt; {
  # ...
<span class="boring">  # Just an example - real implementation would send an RPC to some downstream service.
</span><span class="boring">  var res: [Offer] = [];
</span><span class="boring">  return futures::immediateFuture(res);
</span>}

# ...
</code></pre>
<hr />
<p><strong>Read closely above</strong>. The <code>getOptionalUpgradeBannerFromDB()</code> function above expects an arg of type 
<code>provider&lt;future&lt;Html&gt;&gt;</code> which is injected as a lazy subgraph rooted at node <code>upgradeBanner</code>. In this way, two of the
nodes within the overall <code>getHomepage()</code> graph will only run conditionally upon determining that the user is not already
a &quot;premium&quot; member.</p>
<pre class="mermaid">
    graph TD
    basePage --> homePage
    maybeUpgradeBanner --> homePage
    userIsPremium --> maybeUpgradeBanner
    upgradeBanner -.-> maybeUpgradeBanner
    specialOffers -.-> upgradeBanner
    subgraph Conditional Subgraph
        upgradeBanner
        specialOffers
    end 
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fearless-concurrency-1"><a class="header" href="#fearless-concurrency-1">Fearless Concurrency</a></h1>
<p>Developed by a Xoogler taking inspiration from years of hands-on development experience with Google-internal backend web
frameworks, Claro moves well beyond async/await. Claroâ€™s declarative, DAG-based structured concurrency model provides an
easy-to-use abstraction to statically guarantee that programs are:</p>
<ul>
<li>Non-blocking</li>
<li>Data-race free</li>
<li>Deadlock free</li>
<li>Optimally scheduled</li>
<li>Scalable by default</li>
</ul>
<p>The following sections will introduce you to the language features that enable Claro's safe concurrency guarantees.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guaranteed-data-race-free-concurrency"><a class="header" href="#guaranteed-data-race-free-concurrency">Guaranteed Data-Race-Free Concurrency</a></h1>
<p>One of Claro's most powerful advantages is that it is able to statically analyze your concurrent code to ensure that
it is impossible to run into a data-race at runtime.</p>
<p>A data race occurs when two or more threads in a single process access the same memory location concurrently, and at 
least one of the accesses is for writing, and the threads are not using any exclusive locks to control their accesses
to that memory.</p>
<p>While there <em>are</em> situations where a race condition may be desirable, <em><strong>they are accidental bugs far more often than 
not</strong></em>. So, Claro has been carefully designed to statically prevent you from writing any program with such a data race.
There are a few primary mechanisms in the language that, together, ensure that data races are impossible to encode. At 
their core, these restrictions boil down to preventing any two threads from sharing references to the same mutable data.</p>
<div class="warning">
<h2 id="thread-local-data-can-be-mutated-at-will"><a class="header" href="#thread-local-data-can-be-mutated-at-will">Thread-Local Data Can be Mutated at Will</a></h2>
<p>Claro requires the use of immutable data when passing data between threads. By enforcing this constraint globally, Claro
programs in turn receive a <strong>static guarantee that all non-Graph procedure interactions with mutable data are happening
over mutable data that is local to the current thread only</strong> and therefore doesn't require any synchronization
whatsoever.</p>
<p>So, while you'll read about restrictions on Graph Procedures below, keep in mind that the internal implementations of
any given node (e.g. the implementation of a procedure called by a node) may create whatever mutable data it wants, and
mutate it freely, including by passing the data around to other procedures that do the mutation.</p>
</div>
<h2 id="all-graph-procedure-args-must-be-deeply-immutable"><a class="header" href="#all-graph-procedure-args-must-be-deeply-immutable">All Graph Procedure Args Must be Deeply-Immutable</a></h2>
<p>Claro's Graph Procedures are an inherently concurrent control flow structure, with nodes executing concurrently by
definition. Importantly, Graphs are executed on multiple threads using a threadpool, and Claro takes responsibility for
this execution being thread safe. As nodes may be executing simultaneously, it would be fundamentally unsafe for any two
nodes to share a reference to the same mutable data as nothing would prevent one of the threads from mutating the data 
while another thread is reading from it.</p>
<p>Claro's approach to addressing this is to track mutability in the type system, and to make use of that information to
ensure that no two threads ever share mutable state by statically requiring that all Graph procedure arguments and node 
outputs are deeply immutable.</p>
<h4 id="fig-1-72"><a class="header" href="#fig-1-72"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">graph function someGraph(mutArg: mut [int]) -&gt; future&lt;SomeRes&gt; {
    root res   &lt;- computeRes(@nodeB, @nodeC);
    node nodeB &lt;- doNodeBThing(mutArg);
    node nodeC &lt;- doNodeCThing(mutArg);
}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">guaranteed_data_race_free_EX1_example.claro:1: Illegal Mutable Graph Procedure Arg: As Graph Procedures are multi-threaded by nature, all args must be deeply-immutable in order to guarantee that Graph Procedures are data-race free by construction.
	Found the mutable type:
		mut [int]
	To correct this, consider converting the arg's type to its deeply-immutable variant:
		[int]
graph function someGraph(mutArg: mut [int]) -&gt; future&lt;SomeRes&gt; {
                         ^^^^^^
guaranteed_data_race_free_EX1_example.claro:3: Invalid type:
	Found:
		mut [int]
	Expected:
		int
    node nodeB &lt;- doNodeBThing(mutArg);
                               ^^^^^^
guaranteed_data_race_free_EX1_example.claro:4: Invalid type:
	Found:
		mut [int]
	Expected:
		int
    node nodeC &lt;- doNodeCThing(mutArg);
                               ^^^^^^
3 Errors
</code></pre>
<hr />
<pre class="mermaid">
    graph TD
    nodeB --> res
    nodeC --> res
</pre>
<p>Here, Claro has correctly identified that <code>nodeB</code> and <code>nodeC</code> would be susceptible to creating a data race, and so a 
compilation error is raised. Additionally, even if there were only a single graph node actually using <code>mutArg</code>, it would
still be fundamentally unsafe. Remember that every single node in a graph runs on the Graph Executor, which is backed by
a threadpool meaning that passing any arguments to a graph procedure is inherently an act that hands data to another 
thread. Claro's philosophy of thread safety is to statically prevent sharing mutable state across threads, so this will 
not be allowed.</p>
<h2 id="all-graph-procedure-node-outputs-must-be-deeply-immutable"><a class="header" href="#all-graph-procedure-node-outputs-must-be-deeply-immutable">All Graph Procedure Node Outputs Must be Deeply-Immutable</a></h2>
<p>You'll also be prevented from introducing a data race by having a graph node pass mutable data to other downstream 
nodes:</p>
<h4 id="fig-2-59"><a class="header" href="#fig-2-59"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">graph provider someGraph() -&gt; future&lt;SomeRes&gt; {
    root res   &lt;- computeRes(@nodeB, @nodeC);
    node nodeB &lt;- doNodeBThing(@nodeA);
    node nodeC &lt;- doNodeCThing(@nodeA);
    node nodeA &lt;- getMutableThing();
}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">guaranteed_data_race_free_EX2_example.claro:5: Illegal Mutable Graph Node Result: As Graph Procedures are multi-threaded by nature, all node expression types must be deeply-immutable in order to guarantee that Graph Procedures are data-race free by construction.
	Found the result of node `nodeA` to have the mutable type:
		mut [int]
	To correct this, consider converting to its deeply-immutable variant:
		[int]
    node nodeA &lt;- getMutableThing();
                  ^^^^^^^^^^^^^^^^^
1 Error
</code></pre>
<hr />
<pre class="mermaid">
    graph TD
    nodeA --> nodeB
    nodeA --> nodeC
    nodeB --> res
    nodeC --> res
</pre>
<p>Again, Claro has correctly identified that <code>nodeB</code> and <code>nodeC</code> would be susceptible to creating a data race, and so a 
compilation error is raised.</p>
<h2 id="lambdas-cannot-capture-mutable-data"><a class="header" href="#lambdas-cannot-capture-mutable-data">Lambdas Cannot Capture Mutable Data</a></h2>
<p>The final restriction that enables &quot;Fearless Concurrency&quot; in Claro programs is the constraint restricting Lambdas from
&quot;closing over&quot;/capturing any mutable value. If Lambdas could capture mutable state data, then passing a Lambda into a
Graph could (very indirectly) circumvent Claro's above restriction on sharing references to mutable data across multiple
threads.</p>
<p>Read more in-depth about this restriction in the 
<a href="guaranteed_data_race_free/../lambdas_and_first_class_procedures/lambda_closures/lambda_closures.generated_docs.html">&quot;Lambdas are Restricted Closures&quot;</a>
section.</p>
<h2 id="thread-safe-mutable-data-structures-blessed-by-the-stdlib"><a class="header" href="#thread-safe-mutable-data-structures-blessed-by-the-stdlib">Thread Safe Mutable Data Structures &quot;Blessed&quot; By the StdLib</a></h2>
<p>Claro aims to be a very pragmatic language, and so chooses not to complicate its type system with something like Rust's
(notoriously complex) borrow checker to prevent shared ownership of unsynchronized, mutable data. Instead, Claro opts to
take an approach of statically forbidding the arbitrary sharing of mutable state between threads, but then returning the
ability to do mutation via a curated set of &quot;blessed&quot; mutable data structures that have been manually validated to be
Thread Safe in all contexts.</p>
<p>For example, take the case of a multithreaded web server where it's very common to employ a request cache to improve 
throughput by reusing responses from downstream services for some period of time. This request cache is an inherently
mutable structure (it needs to be updated when a new request needs to be cached, or when reloading an existing cache
entry upon expiration). A mutable request cache is obviously of utmost importance for Claro's practical usefulness as a
language for writing real world web services, so the stdlib exposes Ben Manes' famously high-performance, thread safe 
<a href="https://github.com/ben-manes/caffeine">Caffeine caching library</a> as the StdLib's 
<a href="https://github.com/JasonSteving99/claro-lang/tree/main/stdlib/cache"><code>cache</code> module</a>.</p>
<div class="warning">
<h2 id="important-this-is-restricted-to-the-stdlib"><a class="header" href="#important-this-is-restricted-to-the-stdlib"><strong>Important</strong>: This is Restricted to the StdLib</a></h2>
<p>Claro accomplishes this using &quot;Opaque&quot; Types and a compiler intrinsic (trick) to effectively lie about the type's 
mutability to avoid the restrictions on types marked <code>mut</code>. In particular, this type is <a href="https://github.com/JasonSteving99/claro-lang/blob/c3c06329e43c053449b0f43301440c22355b0d93/stdlib/cache/cache.claro_module_api#L2">exported from the 
<code>cache.claro_module_api</code> file</a>
as follows:</p>
<h4 id="fig-3-47"><a class="header" href="#fig-3-47"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># Note the lack of a `mut` annotation.
opaque newtype Cache&lt;K, V&gt;
</code></pre>
<hr />
<p>And is internally defined as wrapping the Java <code>AsyncLoadingCache</code> type from the Caffeine caching library:</p>
<h4 id="fig-4-27"><a class="header" href="#fig-4-27"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"># This `$java_type` feature is only accessible to the StdLib.
newtype Cache&lt;K, V&gt;: $java_type&lt;K, V&gt;(&quot;com.github.benmanes.caffeine.cache.AsyncLoadingCache&lt;%s, %s&gt;&quot;)
</code></pre>
<hr />
<p>Thanks to being defined as an Opaque Type, it's safe for this type to be passed anywhere, even shared between threads,
as users' only mechanism to interact with values of this type is via the &quot;front door&quot; of the procedures exported from
<a href="https://github.com/JasonSteving99/claro-lang/blob/c3c06329e43c053449b0f43301440c22355b0d93/stdlib/cache/cache.claro_module_api"><code>cache.claro_module_api</code></a>
which define a Thread Safe API.</p>
<p><strong>It's not possible for user code to actually make this same &quot;lie&quot; about a type's mutability. This feature is explicitly 
restricted to the internal StdLib modules to ensure that Claro's &quot;Fearless Concurrency&quot; guarantees aren't broken by
users either publishing buggy or intentionally malicious modules.</strong> At the moment (and into the foreseeable future), 
Claro places a <strong>much higher</strong> value on being able to make safety guarantees across the entire language ecosystem than 
on any individual's ability to define their own custom mutable data structures that can be shared across threads. </p>
<p>There are currently no plans to <strong>ever</strong> allow any mutable, user-defined type defined outside the StdLib to be shared 
across threads. Instead, <strong>Claro intends to actively welcome external contributions of high value, general purpose,
demonstrably Thread Safe, mutable data structures to be made available via the StdLib</strong>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guaranteed-deadlock-free-concurrency"><a class="header" href="#guaranteed-deadlock-free-concurrency">Guaranteed Deadlock-Free Concurrency</a></h1>
<p>One of Claro's most powerful advantages is that it is able to statically analyze your concurrent code to determine that
it is impossible to run into a deadlock at runtime.</p>
<p>A deadlock is a situation where a thread blocks its execution waiting for another thread to complete or for some other
action to complete before it can continue, but the other thread or action never completes thereby leaving the
waiting thread permanently blocked. Threads are not free, and effectively losing access to a deadlocked thread has
costlier implications than just losing that unit of work completing. Each thread costs about 1MB of RAM and in a server
application deployed with a fixed number of threads, losing even one can lead to cascading failures such as thread
starvation (having no more threads in a healthy state available do meaningful work) or simply falling behind on incoming
request handling, leading to a server decreasing its effective throughput, causing other servers to pick up the load (
making them more likely to fail in turn) or just straight up dropping user requests returning errors to them and
degrading product experience.</p>
<p>To mitigate these risks at scale, high-throughput, low-latency services turn to the <strong>async</strong> concurrency pattern to
handle all operations in a non-blocking way. <strong>Claro's Graph Procedures implement the async pattern for you for free,
while statically validating that your concurrent code is entirely non-blocking</strong>. It does so by modeling every Graph
node as an async operation that will not even be started until <em>after</em> all of its data dependencies are resolved. Once a
node is ready for execution it will be scheduled on a threadpool with as many threads as available CPU cores (will be
configurable in the future).</p>
<p>In this way, calling a Graph Procedure is actually an extremely lightweight operation from the perspective of the
calling thread. The calling thread simply</p>
<ol>
<li>traverses the Graph (without executing any nodes)</li>
<li>composes a <code>future&lt;...&gt;</code> representing a handle to the work to be done by the Graph</li>
<li>submits the Graph to the Graph Executor to schedule on its threadpool when threads become available</li>
</ol>
<p>After these steps the calling thread is completely freed to move on, knowing that the work represented by the Graph
Procedure's returned <code>future&lt;...&gt;</code> will be handled by other threads. As a result, in a web server, after calling a
request handling Graph the service thread is free to just immediately move on to accepting new requests. The service
thread never needs to block to wait for request handling business logic to complete. Now, a server built using this
approach will no longer be bound by the number of incoming requests as it will be able to continuously schedule incoming
requests to be processed when Graph Executor threads become available. Of course, the server may still fail due to heavy
load, though this will end up coming from OOMs (out-of-memory errors) as the result of storing all of the queued
requests. Even so, as a general rule, this will happen much later than if you were to execute request handling logic
using thread blocking operations, and it will almost always degrade more gracefully when it does eventually reach its
limit.</p>
<p>The only concession that you, as a programmer, have to make is simply defining all of your concurrent logic inside a
Graph Procedure. Claro will then manage all of the scheduling for you, while enforcing that you never block one of the
Graph Executor threads (you may not use the <code>&lt;-|</code> operator in any code transitively reachable from your Graph, or else
you'll receive a compiler error). To provide a single, well-lit path for safely designing scalable services in Claro,
the only available mechanism to access threads are Graph Procedures.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocking-procedures"><a class="header" href="#blocking-procedures">Blocking Procedures</a></h1>
<p>Whereas other languages with some form of builtin concurrency mechanism may tend to make it harder to write async code
than blocking code, Claro is very intentional about inverting that balance. Make the good things easy and the bad things
hard. So, you may write blocking code in Claro, but as it's really only intended to be used in limited contexts, Claro
forces your hand. Any procedure that makes use of the <code>&lt;-|</code> operator either directly or indirectly, must be explicitly
annotated to be <code>blocking</code>:</p>
<h4 id="fig-1-73"><a class="header" href="#fig-1-73"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">blocking function doBlocking(x: int) -&gt; Bar&lt;Foo&gt; {
  # ...do stuff...
  var unwrappedGraphRes: Foo &lt;-| fooGraph(x);  # &lt;-- Blocking unwrap.
  # ...do stuff using `unwrappedGraphRes`...
  return # ...
<span class="boring">    Bar(unwrappedGraphRes);
</span>}
</code></pre>
<hr />
<h2 id="graph-procedures-may-not-call-any-blocking-procedures-directly-or-indirectly"><a class="header" href="#graph-procedures-may-not-call-any-blocking-procedures-directly-or-indirectly">Graph Procedures May not Call any Blocking Procedures (Directly or Indirectly)</a></h2>
<p>To prevent deadlocking, procedures annotated <code>blocking</code> may not be called from a Graph: </p>
<h4 id="fig-2-60"><a class="header" href="#fig-2-60"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">graph function attemptToDeferToBlockingFn(x: int) -&gt; future&lt;Bar&lt;Foo&gt;&gt; {
  root noopRes &lt;- @defer;
  node defer   &lt;- doBlocking(x);  # &lt;-- Illegal call to blocking procedure in Graph.
}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">Graph Function attemptToDeferToBlockingFn function&lt;int -&gt; future&lt;Bar&lt;Foo&gt;&gt;&gt; has illegal transitive dep on the following blocking procedures [doBlocking blocking function&lt;int -&gt; Bar&lt;Foo&gt;&gt;]. Blocking is forbidden within a Graph Function in order to avoid deadlocking.
1 Error
</code></pre>
<hr />
<p>Therefore, you can be confident that the threading implementation of any logic defined within a Graph Procedure will 
certainly not suffer from liveliness issues in the form of deadlocks (of course, you may still write code with bugs such
as infinite loops that may lead to a &quot;livelock&quot;).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="re-what-color-is-your-function"><a class="header" href="#re-what-color-is-your-function">Re: &quot;What Color is Your Function?&quot;</a></h1>
<p>(<em>For context, the blog post
<a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">&quot;What Color is Your Function?&quot;</a> by Bob
Nystrom is highly recommended reading.</em>)</p>
<p>Unfortunately, introducing the <code>blocking</code> procedure type variant has the effect of &quot;coloring&quot; all functions that
transitively reach a <code>blocking</code> procedure. This ends up being a problem for any code that provides some generic
functionality over first-class procedure arguments that we would ideally like to be able to reuse and call from any
context, whether blocking or not.</p>
<p>Take, for example, Functional Programming's common <code>filter</code> function with the following signature:</p>
<h4 id="fig-1-74"><a class="header" href="#fig-1-74"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">function filter&lt;T&gt;(l: [T], pred: function&lt;T -&gt; boolean&gt;) -&gt; [T];
</code></pre>
<hr />
<p>As currently defined, the <code>filter</code> function with the above signature could only be used over non-<code>blocking</code> pred
function args. You'd need to write a duplicate function explicitly accepting a <code>blocking</code> pred function in its signature
if you wanted to filter lists using a pred function that makes use of blocking operations:</p>
<h4 id="fig-2-61"><a class="header" href="#fig-2-61"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">blocking function filterBlocking&lt;T&gt;(l: [T], pred: blocking function&lt;T -&gt; boolean&gt;) -&gt; [T];
</code></pre>
<hr />
<p>This duplication would be pervasive throughout functional-style code, and would discourage using functional-style at
all. Both of which are very undesirable outcomes. So, Claro handles this using one more form of generics inspired
by <a href="https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html">Rust's Keyword Generics Initiative</a>,
&quot;Blocking Generics&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-blocking-generics"><a class="header" href="#advanced-blocking-generics">(Advanced) Blocking Generics</a></h1>
<p>You're able to define a procedure whose &quot;blocking&quot;-ness is generically determined by the type of the first-class
procedure arg that the function is called with. Taking inspiration
from <a href="https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html">Rust's Keyword Generics Initiative</a>, a
Claro procedure may be declared &quot;Blocking-Generic&quot; with the following syntax:</p>
<h4 id="fig-1-75"><a class="header" href="#fig-1-75"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># Explicitly annotate which arg(s) are blocking-generic.
blocking:pred function filter&lt;T&gt;(
    l: [T],
    pred: blocking? function&lt;T -&gt; boolean&gt;  # &lt;-- Accepting a blocking-generic function arg.
) -&gt; [T] {
  return [x | x in l where pred(x)];
}
</code></pre>
<hr />
<p>Now, with only a single implementation of your <code>filter</code> function, calls may be statically determined to be either a
blocking or non-blocking call depending on the type of the passed <code>pred</code> function arg. So now, from within a Graph, you
may call this &quot;blocking-generic&quot; function as long as you pass in a non-blocking <code>pred</code> function.</p>
<h4 id="fig-2-62"><a class="header" href="#fig-2-62"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">graph function deferToBlockingGenericFn(l: [int]) -&gt; future&lt;[int]&gt; {
  root noopRes &lt;- @defer;
  # Legal call to non-blocking procedure in Graph.
  node defer   &lt;- filter(l, (x: int) -&gt; boolean { return x &gt; 0; });
}

var res &lt;-| deferToBlockingGenericFn([-1, 5, 3, 0, 2]);
print(res);
</code></pre>
<p><em>Output:</em></p>
<pre><code>[5, 3, 2]
</code></pre>
<hr />
<p>And of course, Claro will statically forbid calls to blocking-generic procedures when a blocking procedure is passed in:</p>
<h4 id="fig-3-48"><a class="header" href="#fig-3-48"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">graph function deferToBlockingGenericFn(l: [int]) -&gt; future&lt;[int]&gt; {
  root noopRes &lt;- @defer;
  # Illegal call to blocking procedure in Graph.
  node defer   &lt;- filter(l, doBlocking);
}

blocking function doBlocking(x: int) -&gt; boolean {
<span class="boring">  var unwrappedGraphRes &lt;-| futures::immediateFuture(x);  # &lt;-- Blocking unwrap.
</span><span class="boring"> return unwrappedGraphRes &gt; 0;
</span>}
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">Graph Function deferToBlockingGenericFn function&lt;[int] -&gt; future&lt;[int]&gt;&gt; has illegal transitive dep on the following blocking procedures []. Blocking is forbidden within a Graph Function in order to avoid deadlocking.
1 Error
</code></pre>
<hr />
<p><em>Note: Claro's error messaging is a work in progress - the above error message will be improved.</em></p>
<h3 id="note-on-the-blockingargname-and-blocking-syntax"><a class="header" href="#note-on-the-blockingargname-and-blocking-syntax">Note on the <code>blocking:argName</code> and <code>blocking?</code> Syntax</a></h3>
<p>Claro localizes Generics only to procedure signatures. This is done with the intention of making Generics more easily
understandable, such that Generics itself may be conceptualized simply as a form of &quot;templating&quot; (regardless of whether
this is how the compiler is <em>actually</em> implementing the feature).</p>
<p>As a result, these type modifier syntaxes are restricted to being used within top-level procedure definition signatures
only. In particular, you may not define a variable of a blocking-generic procedure type:</p>
<h4 id="fig-4-28"><a class="header" href="#fig-4-28"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"># Illegal use of `blocking:...`, and `blocking?` outside of top-level Procedure definition.
var myBlockingGenericFn:
    blocking:arg1 function&lt;|[int], blocking? function&lt;int -&gt; boolean&gt;| -&gt; [int]&gt;;
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">blocking_generics_EX4_main.claro:3: Unexpected token &lt;:&gt;
    blocking:arg1 function&lt;|[int], blocking? function&lt;int -&gt; boolean&gt;| -&gt; [int]&gt;;
            ^
Can't recover from previous error(s)
2 Errors
</code></pre>
<hr />
<p><em>Note: Claro's error messaging is a work in progress - the above error message will be improved.</em></p>
<h3 id="lambdas-cannot-use-any-form-of-generics"><a class="header" href="#lambdas-cannot-use-any-form-of-generics">Lambdas Cannot Use Any Form of Generics</a></h3>
<p>This has the implication that lambdas may not make use of blocking generics. But this is in line with Claro's single-use
intention for lambdas, encouraging the definition of lambdas that will only be used in a single limited scope. For any
cases that actually need to make use of blocking-generics, you are by definition defining a procedure that should have
more than one use case, and you should define a top-level procedure instead.</p>
<h3 id="first-class-references-to-blocking-generic-top-level-procedures"><a class="header" href="#first-class-references-to-blocking-generic-top-level-procedures">First-Class References to Blocking-Generic Top-Level Procedures</a></h3>
<p>You can, however, still make first-class references to top-level blocking-generic procedures in order to pass them
around as data. The only restriction, is that you must statically declare which blocking variant the reference will take
on:</p>
<h4 id="fig-5-20"><a class="header" href="#fig-5-20"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro"># A blocking function var, to which you may *only* pass blocking functions.
var myBlockingFn: blocking function&lt;|[int], blocking function&lt;int -&gt; boolean&gt;| -&gt; [int]&gt;
    = filter;

# A non-blocking function var, to which you may *only* pass non-blocking functions.
var myNonBlockingFn: function&lt;|[int], function&lt;int -&gt; boolean&gt;| -&gt; [int]&gt;
    = filter;
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-http-servers"><a class="header" href="#basic-http-servers">Basic HTTP Servers</a></h1>
<p>Claro has been carefully designed to be uniquely well-suited for building highly efficient, scalable web servers.
Claro's <a href="http_servers/../fearless_concurrency/fearless_concurrency.html">&quot;Fearless Concurrency&quot;</a> guarantees are explicitly an effort to
make it significantly challenging to make a buggy, slow web server - and instead, Claro's novel concurrency model will
lead to performant and easy-to-maintain web servers naturally falling out of even naive usages of the language.</p>
<p>To actually demonstrate this explicitly, Claro provides very basic support for building HTTP servers that can be used in
the absence of any sort of 3rd party framework to jump you right into your first web server in Claro. This feature is
largely intended as a demonstration of Claro's current capabilities, and to point towards Claro's future direction. This
is by no means a complete web server framework.</p>
<p>Following this guide will lead you through the steps to setting up your very first web server in Claro.</p>
<h2 id="http-service-definition"><a class="header" href="#http-service-definition">HTTP Service Definition</a></h2>
<p>First, you'll need to define the endpoints that your HTTP service will handle. To do this, you'll use Claro's built-in
<code>HttpService</code> definition syntax, e.g.:</p>
<h4 id="fig-1-76"><a class="header" href="#fig-1-76"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro">HttpService Greeter {
  genericGreeting: &quot;/genericGreeting&quot;,
  greeting: &quot;/greeting/{name}&quot;
}
</code></pre>
<hr />
<p>The above defines a very simple service with two basic endpoints.</p>
<h2 id="auto-generated-httpserver"><a class="header" href="#auto-generated-httpserver">Auto-Generated HttpServer</a></h2>
<p>Claro will automatically generate a pre-configured, non-blocking web server implementation for your <code>HttpService</code>
definition by using the builtin magic function <code>http::getBasicHttpServerForPort()</code>. This function is implemented as a
compiler intrinsic that will infer the server to automatically generate based on the type asserted on the call. So, we
can get Claro to generate a web server for the example <code>Greeter</code> service as in the example below.</p>
<div class="warning">
Note that no Endpoint Handlers have been implemented yet so we should actually expect the below to fail to compile and
prompt us to implement them! Doing things in this order allows us to allow Claro to prompt us with the signatures that
we need to implement, which is just a convenience.
</div>
<h4 id="fig-2-63"><a class="header" href="#fig-2-63"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">HttpService Greeter {
  genericGreeting: &quot;/genericGreeting&quot;,
  greeting: &quot;/greeting/{name}&quot;
}

# endpoint_handlers Greeter { }

var greeterServer: HttpServer&lt;Greeter&gt; = http::getBasicHttpServerForPort(8080);
_ = greeterServer; # Not starting the server yet.
</code></pre>
<p><em>Compilation Errors:</em></p>
<pre><code class="language-compilation-errs">http_servers_EX2_example.claro:8: Invalid HttpServer Generation Requested for HttpService Missing Endpoint Handlers Definition: In order to automatically generate an HttpServer for the given HttpService an `endpoint_handlers` block such as the following must be defined:
	endpoint_handlers Greeter {
		graph provider genericGreeting() -&gt; future&lt;HttpResponse&gt; {
			...
		}
		graph function greeting(pathArg0: string) -&gt; future&lt;HttpResponse&gt; {
			...
		}
	}
var greeterServer: HttpServer&lt;Greeter&gt; = http::getBasicHttpServerForPort(8080);
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1 Error
</code></pre>
<hr />
<h2 id="implementing-endpoint-handlers"><a class="header" href="#implementing-endpoint-handlers">Implementing Endpoint Handlers</a></h2>
<p>A service definition on its own doesn't actually provide much utility without endpoint handlers implemented to actually
serve up the responses to incoming requests. As we see from the compilation error above, we must define endpoint
handlers for the above HttpService by defining an <code>endpoint_handlers</code> block with a Graph Procedure implementation
corresponding to each endpoint in the HttpService definition. </p>
<p>Note that in the HTTP service definition above, the <code>greeting</code> endpoint includes <code>{name}</code> in the route - this is a &quot;path 
parameter&quot; that will automatically be parsed from incoming requests and passed along as input to the associated endpoint
handler. So, note that the signature of the <code>greeting</code> endpoint handler includes a <code>string</code> arg that will represent the
value of the <code>{name}</code> path parameter for each request to that endpoint. </p>
<h4 id="fig-3-49"><a class="header" href="#fig-3-49"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">HttpService Greeter {
  genericGreeting: &quot;/genericGreeting&quot;,
  greeting: &quot;/greeting/{name}&quot;
}

endpoint_handlers Greeter {
  graph provider genericGreeting() -&gt; future&lt;HttpResponse&gt; {
    root httpRes &lt;- http::getOk200HttpResponseForJson(@json);
    node json    &lt;- EndpointHandlerImpls::GENERIC_GREETING;
  }
  graph function greeting(name: string) -&gt; future&lt;HttpResponse&gt; {
    root httpRes &lt;- http::getOk200HttpResponseForJson(@json);
    node json    &lt;- EndpointHandlerImpls::getGreetingForName(name);
  }
}

var greeterServer: HttpServer&lt;Greeter&gt; = http::getBasicHttpServerForPort(8080);
_ = greeterServer; # Not starting the server yet.
</code></pre>
<hr />
<p>As you can see, the core implementation logic was factored out into another Module <code>EndpointHandlerImpls</code>. These impls
can do anything, including making arbitrary downstream network requests, as long as they are non-blocking. In this case,
they'll simply return some simple greeting.</p>
<div class="warning">
Note: the requirement that each endpoint handler implementation be a Graph Procedure is to ensure that the resulting
web service is statically guaranteed to be non-blocking <b>and</b> to ensure that each request is handled <b>off the
request thread</b> so that long-running computations don't interfere with the service's ability to receive and schedule 
incoming requests. This ties together all of Claro's design decisions to make building fundamentally concurrent web
services a trivial task.
</div>
<h2 id="starting-an-httpserver"><a class="header" href="#starting-an-httpserver">Starting an <code>HttpServer</code></a></h2>
<p>That's it! Now we can actually <em>start</em> the <code>Greeter</code> server that we just implemented. This is as simple as calling the
builtin <code>http::startServerAndAwaitShutdown()</code> consumer. This call effectively drops into an infinite loop, so depending
on how you start it, when you're done and want to bring the service down, you'll have to send a termination signal to
the server process e.g. using ctrl-C.</p>
<h4 id="fig-4-29"><a class="header" href="#fig-4-29"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring">HttpService Greeter {
</span><span class="boring">  genericGreeting: &quot;/genericGreeting&quot;,
</span><span class="boring">  greeting: &quot;/greeting/{name}&quot;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">endpoint_handlers Greeter {
</span><span class="boring">  graph provider genericGreeting() -&gt; future&lt;HttpResponse&gt; {
</span><span class="boring">    root httpRes &lt;- http::getOk200HttpResponseForJson(@json);
</span><span class="boring">    node json    &lt;- EndpointHandlerImpls::GENERIC_GREETING;
</span><span class="boring">  }
</span><span class="boring">  graph function greeting(name: string) -&gt; future&lt;HttpResponse&gt; {
</span><span class="boring">    root httpRes &lt;- http::getOk200HttpResponseForJson(@json);
</span><span class="boring">    node json    &lt;- EndpointHandlerImpls::getGreetingForName(name);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">var greeterServer: HttpServer&lt;Greeter&gt; = http::getBasicHttpServerForPort(8080);
</span><span class="boring">_ = greeterServer; # Not starting the server yet.
</span># Finally start the service
http::startServerAndAwaitShutdown(greeterServer);
</code></pre>
<hr />
<p>The below recording is a demonstration this server in action. It first starts up the server (launching the process in
the background), and then sends a couple requests to each endpoint using <code>curl</code> to demonstrate the server in action, and
then finally kills the server.</p>
<p><em>Note: The below recording was made with <a href="https://asciinema.org/" target="_blank">asciinema</a> - try pausing
and copying any text.</em></p>
<script async id="asciicast-640744" src="https://asciinema.org/a/640744.js" data-preload="true" data-autoplay="false"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-parsing"><a class="header" href="#json-parsing">JSON Parsing</a></h1>
<p>Claro strives to make development easier in many ways, and as being able to write programs that interact with the 
network is an important goal, Claro has some initial support for automatically generating efficient JSON parsers for
relatively arbitrary formats. If you know the schema of the JSON data that you'll be interacting with, and can describe
it as some Claro struct, then in general you can automatically parse JSON data from a string directly into the Claro
type. </p>
<p>Claro's JSON parsing is implemented by <strong>generating a custom parser for the target data format at compile time</strong>. So, in
addition to ergonomic improvements, this approach offers potential performance benefits over a general-purpose JSON
parser.</p>
<p>For example, the following JSON string could be included in a 
<a href="json_parsing/../resource_files/resource_files.generated_docs.html">Resource File</a>:</p>
<h4 id="fig-1-77"><a class="header" href="#fig-1-77"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-json">{
  &quot;server_name&quot;: &quot;My Server&quot;,
  &quot;port&quot;: 8080,
  &quot;logging&quot;: {
    &quot;filename&quot;: &quot;server.log&quot;
  },
  &quot;database&quot;: {
    &quot;host&quot;: &quot;localhost&quot;,
    &quot;port&quot;: 5432,
    &quot;database_name&quot;: &quot;my_database&quot;
  }
}
</code></pre>
<hr />
<p>We can represent that JSON format as the following Claro data structure:</p>
<h4 id="fig-2-64"><a class="header" href="#fig-2-64"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro">alias ServerConfig : struct {
  server_name: string,
  port: int,
  logging: struct {
    filename: string
  },
  database: struct {
    host: string,
    port: int,
    database_name: string
  }
}
</code></pre>
<hr />
<p>And now, the JSON string can be parsed by a simple call to the <code>fromJson(...)</code> builtin function:</p>
<h4 id="fig-3-50"><a class="header" href="#fig-3-50"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro">
resources::ServerConfigJSON
  |&gt; files::readOrPanic(^)
  |&gt; var parsedConfig: std::ParsedJson&lt;ServerConfig&gt; = fromJson(^);

var parsedResult = unwrap(parsedConfig).result;
if (parsedResult instanceof ServerConfig) {
  print(&quot;Config has correct format and was parsed successfully!&quot;);
  print(strings::repeated(&quot;-&quot;, 50));
  print(&quot;Server Name: {parsedResult.server_name}&quot;);
  print(&quot;Port:        {parsedResult.port}&quot;);
} else {
  print(&quot;JSON parsing failed!&quot;);
  print(parsedResult);
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>Config has correct format and was parsed successfully!
--------------------------------------------------
Server Name: My Server
Port:        8080
</code></pre>
<hr />
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<div class="warning">
<p>To be clear, Claro's JSON parsing support is currently fairly constrained and doesn't yet support the full range of
possible JSON formats. You'll be warned at compile-time if the format you're attempting to auto-parse is supported or
not. More work will be needed to complete the implementation. <strong>If you're interested in contributing to this please
reach out!</strong></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="build-time-metaprogramming"><a class="header" href="#build-time-metaprogramming">Build Time Metaprogramming</a></h1>
<p>Claro takes the stance that relatively sophisticated Build-time logic can be a great enabler of significant flexibility.
In particular, even very simple Build-time code generation can be used to achieve extremely convenient code reuse
without forcing the core Claro programming language itself to become more and more complex over time to directly
represent more and more complex design patterns.</p>
<p>This section seeks to demonstrate how Bazel's configuration language (that you'll already be using to declare
<code>claro_module(...)</code> and <code>claro_binary(...)</code> targets in <code>BUILD</code> files) can be used to write logic that will
programmatically determine at Build-time the program structure that will be converted to an executable at Compile-time. </p>
<h2 id="build-vs-compile-phases"><a class="header" href="#build-vs-compile-phases">Build vs Compile Phases</a></h2>
<p>The first distinction to make here is a subtle difference between &quot;Build&quot; and &quot;Compile&quot; time in the Claro ecosystem.
All statically compiled languages have a &quot;Compile&quot; phase where the final program's source code is evaluated by the
language's compiler and eventually converted into an actual executable, and this is no different in Claro. The unique
aspect of Claro is that it's been intentionally designed with a tight integration with its Build system 
<a href="https://bazel.build/" target="_blank">Bazel</a> in mind, and so your program's source files are first processed
by Bazel, potentially executing arbitrary Build-time logic of your choosing <em>before any source code is ever passed to
the Claro compiler itself</em>.</p>
<p>As we'll go into more detail on in this section, Bazel enables you to write all sorts of arbitrary file-manipulations or
script executions during this Build phase. This enables you to do any manner of source code transformations or even code
generation from statically validated sources of truth. And, thanks to Bazel's correctness guarantees, you're able to
string together arbitrary graphs of Build logic that will be reliably reproduced on each Build (with each step 
benefiting from Bazel's caching support for incremental Builds). Only after all Build steps have completed successfully
does the Build phase end and the Compile phase begin with the final dependency graph of <code>claro_binary(...)</code> and
<code>claro_module(...)</code> targets evaluated by the Claro compiler.</p>
<p><strong>Continue on to the next sections where we'll go into more details to demonstrate some ways you can leverage Build-time
metaprogramming to gain more dynamic control over the Claro programs you create.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-code-templates"><a class="header" href="#source-code-templates">Source Code Templates</a></h1>
<p>The first, extremely simple Build-time Metaprogramming example that we'll look at is one way to create and use source
code templates at Build time.</p>
<p>As a contrived example, imagine that you're writing an
<a href="metaprogramming/templating/../../http_servers/http_servers.generated_docs.html">HTTP Service's</a> homepage
<a href="metaprogramming/templating/../../http_servers/http_servers.generated_docs.html#implementing-endpoint-handlers">Endpoint Handler</a> where you want to
just serve some hardcoded static HTML representing our site's trivial homepage. Of course, you may decide to just
directly write out the HTML string inline, but it would probably be more useful to create a separate <code>homepage.html</code>
file so that you can get IDE support for your HTML. You could of course depend on <code>homepage.html</code> as a Resource file to
read at runtime, but we could also opt to directly embed the file's HTML contents into the source code at Build time so
that we don't have to spend any time reading the file while the program is running.</p>
<p>To do this, we could make our source file a template with a format string <code>{{HOMEPAGE_HTML}}</code> to be replaced:</p>
<h4 id="fig-1-78"><a class="header" href="#fig-1-78"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1.claro.tmpl
provider homepageHtml() -&gt; string {
  return &quot;{{HOMEPAGE_HTML}}&quot;;
}
</code></pre>
<hr />
<h2 id="expand_template-macro"><a class="header" href="#expand_template-macro"><code>expand_template(...)</code> Macro</a></h2>
<p>Bazel provides ample tooling for you to write this functionality entirely from scratch, but to make it easier to get up
and running, Claro provides an <code>expand_template(...)</code> Bazel macro out of the box. The <code>BUILD</code> file below expands the
template by converting the given <code>homepage.html</code> file to a single line with all <code>&quot;</code> escaped and inserting it into the
<code>ex1.claro.tmpl</code>:</p>
<h4 id="fig-2-65"><a class="header" href="#fig-2-65"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;@claro-lang//stdlib/utils/expand_template:expand_template.bzl&quot;, &quot;expand_template&quot;)

expand_template(
    name = &quot;ex1&quot;,
    template = &quot;ex1.claro.tmpl&quot;,
    out = &quot;ex1.claro&quot;,
    substitutions = {
        # Replace {{HOMEPAGE_HTML}} with the contents of the html file generated below.
        &quot;HOMEPAGE_HTML&quot;: &quot;homepage_single_line.html&quot;,
    },
)

# Learn more about genrule at: https://bazel.build/reference/be/general#genrule
genrule(
    name = &quot;homepage_single_line&quot;,
    srcs = [&quot;homepage.html&quot;],
    outs = [&quot;homepage_single_line.html&quot;],
    # Bash script to remove all newlines and escape double-quotes.
    cmd = &quot;cat $(SRCS) | tr '\\n' ' ' | sed 's/\&quot;/\\\\\&quot;/g' &gt; $(OUTS)&quot;,
)
</code></pre>
<hr />
<p>And now you end up with a valid Claro source file: </p>
<h4 id="fig-3-51"><a class="header" href="#fig-3-51"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># ex1.claro
provider homepageHtml() -&gt; string {
  return &quot;&lt;!DOCTYPE html&gt; &lt;html lang=\&quot;en\&quot;&gt; &lt;head&gt;     &lt;meta charset=\&quot;UTF-8\&quot;&gt;     &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot;&gt;     &lt;title&gt;My Website&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to my website!&lt;/h1&gt; &lt;p&gt;This is a very basic homepage.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;&quot;;
}
</code></pre>
<hr />
<h2 id="aside-claros-entire-docs-site-is-generated-at-build-time-using-this-templating-approach"><a class="header" href="#aside-claros-entire-docs-site-is-generated-at-build-time-using-this-templating-approach">(Aside) Claro's Entire Docs Site is Generated at Build Time Using This Templating Approach!</a></h2>
<p>Bazel's support for this Build time execution is an extremely powerful tool that can be used for all sorts of things
where you'd like to derive some files (program source code or otherwise) from some other file(s) representing canonical
source(s) of truth. </p>
<p>In fact, <strong>this docs site</strong> was dynamically generated at Build time by first executing each and every sample Claro code
snippet and templating the snippet's output into the markdown file that eventually gets converted to HTML. To make this
example more explicit, this site's <a href="metaprogramming/templating/../../chapter_1/hello_world.generated_docs.html">Hello, World!</a> page was generated
from literally the below template:</p>
<h4 id="fig-4-30"><a class="header" href="#fig-4-30"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-md"># Hello, World!

{{EX1}}

As you can already see from the most minimal program possible, Claro programs eliminate unnecessary boilerplate. Every
Claro program is simply a sequence of statements that are executed from top-to-bottom as if it were a &quot;script&quot;. You
don't need to specify a &quot;main&quot; method&quot; as in other languages like Java, instead, much like Python, you simply specify a
starting file which will execute top-down at program start.
</code></pre>
<hr />
<p>And the corresponding BUILD file contains the following <code>doc_with_validated_examples(...)</code> declaration which is built
on top of the <code>expand_template(...)</code> macro described above:</p>
<h4 id="fig-5-21"><a class="header" href="#fig-5-21"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;//mdbook_docs:docs_with_validated_examples.bzl&quot;, &quot;doc_with_validated_examples&quot;)

doc_with_validated_examples(
    name = &quot;hello_world&quot;,
    doc_template = &quot;hello_world.tmpl.md&quot;,
    examples = [&quot;hello_world.claro&quot;],
)
</code></pre>
<hr />
<p>Which generates this final output markdown:</p>
<h4 id="fig-6-12"><a class="header" href="#fig-6-12"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-md hljs">[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)
# Hello, World!

#### _Fig 1:_
---
```claro
print("Hello, world!");
```
_Output:_
```
Hello, world!
```
---


As you can already see from the most minimal program possible, Claro programs eliminate unnecessary boilerplate. Every
Claro program is simply a sequence of statements that are executed from top-to-bottom as if it were a "script". You
don't need to specify a "main" method" as in other languages like Java, instead, much like Python, you simply specify a
starting file which will execute top-down at program start.

</code></pre>
<hr />
<p>This is a powerful example of Build-time Metaprogramming being put to good use. This approach is not just convenient,
but provides some legitimate guarantees that wherever this approach was used, if the site deploys, then the sample code
on the site is guaranteed to <em>actually</em> be valid because otherwise Bazel would have failed the build! You can imagine
how useful this is for an actively in-development language where things are subject to potentially change at any time.</p>
<p>Feel free to dig into the source code of Claro's docs site
<a href="https://github.com/JasonSteving99/claro-lang/tree/main/mdbook_docs" target="_blank">here</a> if you want to get
more into the weeds on this example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literal-code-reuse"><a class="header" href="#literal-code-reuse">(Literal) Code Reuse</a></h1>
<div class="warning">
<p>Claro enables you to <strong><em>literally reuse source code</em></strong> throughout your program rather than offering a list of complex
type system features that <strong><em>indirectly enable code reuse</em></strong> like other languages do (e.g. via inheritance in OO
languages, or liberal use of higher order functions in FP languages).</p>
<p>It will take a bit of conceptual groundwork (unlearning long-held assumptions) to understand Claro's approach here, but
in exchange, you'll be given some powerful new ways to think about &quot;<em>what</em>&quot; a Claro program is. </p>
</div>
<p>Rather than trying to impose specific <em>code organization</em> design patterns on you (e.g. Java trying to force use of
inheritance) Claro instead aims to be flexible enough to allow you full control of using <em>and encoding</em> your own
organizational design patterns (potentially including inheritance if you felt so inclined).</p>
<p>Probably the most fundamental idea that you'll need to internalize to fully understand Claro's larger design in a deep
way is the relationship that a file containing Claro source code actually has with the final resulting program. This is
a subtle point. It's very possible to write a good amount of Claro code without noticing anything unusual in this
regard. </p>
<p>Rather than going into an overly detailed explanation, read on to the following sections for some detailed 
examples of various different ways you can dynamically construct Claro programs at Build time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reusing-module-apis"><a class="header" href="#reusing-module-apis">Reusing Module APIs</a></h1>
<div class="warning">
<p>This is a long section, but it's foundational to a deep understanding of the full expressive power you have available to
you at Build time. You're encouraged to read through this in full! But remember, while you may sometimes end up 
consuming Modules that were <em>defined</em> using these advanced features, <strong>you'll never be <em>forced</em> to directly use any
Build time metaprogramming feature yourself</strong>. These will always be conveniences for more advanced users.</p>
</div>
<h2 id="multiple-implementations-of-a-module-api"><a class="header" href="#multiple-implementations-of-a-module-api">Multiple Implementations of a Module API</a></h2>
<p>The most basic, and also most important form of reuse in Claro codebases will be in the form of multiple Modules sharing
a common API. This doesn't require any special syntax or setup whatsoever, once you've defined a valid
<code>.claro_module_api</code> file any number of Modules may implement that API. Each <code>claro_module(...)</code> definition simply needs
to declare its <code>module_api_file = ...</code> to reference the same exact <code>.claro_module_api</code> file.</p>
<p>For example, the following API:</p>
<h4 id="fig-1-79"><a class="header" href="#fig-1-79"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># animal.claro_module_api
opaque newtype InternalState

newtype State : struct {
  name: string,
  internal: InternalState
}

implement AnimalSounds::AnimalSounds&lt;State&gt;;
</code></pre>
<hr />
<p>Can be implemented multiple times, by more than one Module:</p>
<h4 id="fig-2-66"><a class="header" href="#fig-2-66"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-claro"># BUILD
load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_module&quot;, &quot;claro_binary&quot;)

claro_module(
    name = &quot;dog&quot;,
    module_api_file = &quot;animal.claro_module_api&quot;,
    srcs = [&quot;dog.claro&quot;],
    deps = {&quot;AnimalSounds&quot;: &quot;:animal_sounds&quot;},
    # `AnimalSounds` is referenced in this Module's API so must be exported.
    exports = [&quot;AnimalSounds&quot;],
)
claro_module(
    name = &quot;cat&quot;,
    module_api_file = &quot;animal.claro_module_api&quot;,
    srcs = [&quot;cat.claro&quot;],
    deps = {&quot;AnimalSounds&quot;: &quot;:animal_sounds&quot;},
    # `AnimalSounds` is referenced in this Module's API so must be exported.
    exports = [&quot;AnimalSounds&quot;],
)
# ...
</code></pre>
<hr />
<p><strong>In general, the Build targets declared above will be totally sufficient!</strong></p>
<h2 id="going-deeper"><a class="header" href="#going-deeper">Going Deeper</a></h2>
<p>The API definition above declares that any Module implementing the API will export a type that includes a name field,
but may configure its own internal state as it wishes. To make this example more compelling, if you read the API
closely, however, you may notice that as presently defined there would be no way for any dependent Module to actually
interact with this API as defined, because there's no way to instantiate the <code>opaque newtype InternalState</code><sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>So, to actually make this API useful, implementing Modules would need to somehow explicitly export some Procedure that
gives dependents the ability to instantiate the <code>InternalState</code>. You'll notice that care has been taken to make sure
that Claro's API syntax is flexible enough to allow for multiple APIs to be conceptually (or in this case, literally)
concatenated to create one larger API for a Module to implement. So that's exactly what we'll do here, with each module
exporting an additional procedure from its API to act as a &quot;constructor&quot; for its <code>opaque</code> type.</p>
<h4 id="fig-3-52"><a class="header" href="#fig-3-52"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># dog_cons.claro_module_api
function create(name: string, isHappy: boolean) -&gt; State;
</code></pre>
<hr />
<h4 id="fig-4-31"><a class="header" href="#fig-4-31"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-claro"># cat_cons.claro_module_api
function create(name: string, favoriteInsult: string) -&gt; State;
</code></pre>
<hr />
<h4 id="fig-5-22"><a class="header" href="#fig-5-22"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro"># BUILD
load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_module&quot;, &quot;claro_binary&quot;)
    [&quot;BUILD&quot;, &quot;animal.claro_module_api&quot;, &quot;cat_cons.claro_module_api&quot;, &quot;dog_cons.claro_module_api&quot;],
)

genrule(
    name = &quot;dog_api&quot;,
    srcs = [&quot;animal.claro_module_api&quot;, &quot;dog_cons.claro_module_api&quot;],
    outs = [&quot;dog.claro_module_api&quot;],
    cmd = &quot;cat $(SRCS) &gt; $(OUTS)&quot;
)
claro_module(
    name = &quot;dog&quot;,
    module_api_file = &quot;:dog_api&quot;, # Updated to use the API with a constructor.
    srcs = [&quot;dog.claro&quot;],
    deps = {&quot;AnimalSounds&quot;: &quot;:animal_sounds&quot;},
    # `AnimalSounds` is referenced in this Module's API so must be exported.
    exports = [&quot;AnimalSounds&quot;],
)

genrule(
    name = &quot;cat_api&quot;,
    srcs = [&quot;animal.claro_module_api&quot;, &quot;cat_cons.claro_module_api&quot;],
    outs = [&quot;cat.claro_module_api&quot;],
    cmd = &quot;cat $(SRCS) &gt; $(OUTS)&quot;
)
claro_module(
    name = &quot;cat&quot;,
    module_api_file = &quot;:cat_api&quot;, # Updated to use the API with a constructor.
    srcs = [&quot;cat.claro&quot;],
    deps = {&quot;AnimalSounds&quot;: &quot;:animal_sounds&quot;},
    # `AnimalSounds` is referenced in this Module's API so must be exported.
    exports = [&quot;AnimalSounds&quot;],
)
# ...
</code></pre>
<hr />
<div class="warning">
<p>In the future <code>claro_module(...)</code> will accept a list of <code>.claro_module_api</code> files instead of a single file to make this
pattern easier to access without having to manually drop down to a <code>genrule(...)</code> to concatenate API files.</p>
</div>
<p>And now, importantly, multiple Modules implementing the same API can coexist in the same Claro program with no conflict!</p>
<h4 id="fig-6-13"><a class="header" href="#fig-6-13"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_module&quot;, &quot;claro_binary&quot;)

# ...

claro_binary(
    name = &quot;animals_example&quot;,
    main_file = &quot;animals_example.claro&quot;,
    deps = {
        &quot;AnimalSounds&quot;: &quot;:animal_sounds&quot;,
        &quot;Cat&quot;: &quot;:cat&quot;,
        &quot;Dog&quot;: &quot;:dog&quot;,
    },
)
</code></pre>
<hr />
<h4 id="fig-7-7"><a class="header" href="#fig-7-7"><em>Fig 7:</em></a></h4>
<hr />
<pre><code class="language-claro"># animals_example.claro
var animals: [oneof&lt;Cat::State, Dog::State&gt;] = [
    Dog::create(&quot;Milo&quot;, true),
    Dog::create(&quot;Fido&quot;, false),
    Cat::create(&quot;Garfield&quot;, &quot;This is worse than Monday morning.&quot;)
  ];

for (animal in animals) {
  print(AnimalSounds::AnimalSounds::makeNoise(animal));
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>Woof!
Grrrr...
This is worse than Monday morning.
</code></pre>
<hr />
<div class="warning">
<p><em>Read more about <a href="metaprogramming/code_reuse/reusing_module_apis/../../../generics/contracts/dynamic_dispatch/dynamic_dispatch.generated_docs.html">Dynamic Dispatch</a> if
you're confused how the above Contract Procedure call works.</em></p>
</div>
<h2 id="expressing-the-above-build-targets-more-concisely"><a class="header" href="#expressing-the-above-build-targets-more-concisely">Expressing the Above Build Targets More Concisely</a></h2>
<p>Now, you'd be right to think that the above Build target declarations are extremely verbose. And potentially worse, they
also contain much undesirable duplication that would have to kept in sync manually over time. Thankfully, Bazel provides
<strong><em>many</em></strong> ways to address both of these issues. </p>
<p>Remember that Bazel's <code>BUILD</code> files are written using Starlark, a subset of Python, so we have a significant amount of
flexibility available to us when declaring Build targets! We'll walk through a few different options for defining these
targets much more concisely.</p>
<h3 id="using-list-comprehension-to-define-multiple-similar-targets-at-once"><a class="header" href="#using-list-comprehension-to-define-multiple-similar-targets-at-once">Using List Comprehension to Define Multiple Similar Targets at Once</a></h3>
<p>The very first thing we'll notice is that the vast majority of these targets are duplicated. So, as programmers, our
first thought should be to ask how we can factor out the common logic, to avoid repeating ourselves. The below rewritten
<code>BUILD</code> file does a much better job of making the similarities between the <code>Cat</code> and <code>Dog</code> modules explicit, and also
prevents them from drifting apart accidentally over time.</p>
<h4 id="fig-8-4"><a class="header" href="#fig-8-4"><em>Fig 8:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_module&quot;, &quot;claro_binary&quot;)

[ # This list-comprehension should feel very reminiscent of Claro's own comprehensions.
    [ # Generate multiple targets at once by declaring them in a list or some other collection.
        genrule(
            name = &quot;{0}_api&quot;.format(name),
            srcs = [&quot;animal.claro_module_api&quot;, &quot;{0}_cons.claro_module_api&quot;.format(name)],
            outs = [&quot;{0}.claro_module_api&quot;.format(name)],
            cmd = &quot;cat $(SRCS) &gt; $(OUTS)&quot;
        ),
        claro_module(
            name = name,
            module_api_file = &quot;:{0}_api&quot;.format(name),
            srcs = srcs,
            deps = {&quot;AnimalSounds&quot;: &quot;:animal_sounds&quot;},
            # `AnimalSounds` is referenced in this Module's API so must be exported.
            exports = [&quot;AnimalSounds&quot;],
        )
    ]
    for name, srcs in {&quot;dog&quot;: [&quot;dog.claro&quot;], &quot;cat&quot;: [&quot;cat.claro&quot;]}.items()
]
</code></pre>
<hr />
<h3 id="declaring-a-macro-in-a-bzl-file-to-make-this-factored-out-build-logic-portable"><a class="header" href="#declaring-a-macro-in-a-bzl-file-to-make-this-factored-out-build-logic-portable">Declaring a Macro in a <code>.bzl</code> File to Make This Factored Out Build Logic Portable</a></h3>
<p>Now let's say that you wanted to declare another &quot;Animal&quot; in a totally separate package in your project. You could
easily copy-paste the Build targets found in the previous <code>BUILD</code> file... but of course, this would invalidate our goal
of avoiding duplication. So instead, as programmers our spider-senses should be tingling that we should factor this
common logic not just into the loop (list comprehension), but into a full-blown function that can be reused and called
from anywhere in our project. Bazel thankfully gives us access to defining so-called
<a href="https://bazel.build/rules/macro-tutorial" target="_blank">&quot;Macros&quot;</a> that fill exactly this purpose<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<p>The Build targets in the prior examples could be factored out into a Macro definition in a <code>.bzl</code> (Bazel extension file)
like so:</p>
<h4 id="fig-9-1"><a class="header" href="#fig-9-1"><em>Fig 9:</em></a></h4>
<hr />
<pre><code class="language-python"># animals.bzl
load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_module&quot;)

def Animal(name, srcs):
    native.genrule( # In .bzl files you'll need to prefix builtin rules with `native.`
        name = &quot;{0}_api&quot;.format(name),
        srcs = [&quot;animal.claro_module_api&quot;, &quot;{0}_cons.claro_module_api&quot;.format(name)],
        outs = [&quot;{0}.claro_module_api&quot;.format(name)],
        cmd = &quot;cat $(SRCS) &gt; $(OUTS)&quot;
    )
    claro_module(
        name = name,
        module_api_file = &quot;:{0}_api&quot;.format(name),
        srcs = srcs,
        deps = {&quot;AnimalSounds&quot;: &quot;:animal_sounds&quot;},
        # This Module is referenced in this Module's API so must be exported.
        exports = [&quot;AnimalSounds&quot;],
    )
</code></pre>
<hr />
<p>And then, the macro can be used from <code>BUILD</code> files like so<sup class="footnote-reference"><a href="#3">3</a></sup>:</p>
<h4 id="fig-10-1"><a class="header" href="#fig-10-1"><em>Fig 10:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;:animals.bzl&quot;, &quot;Animal&quot;)

Animal(name = &quot;dog&quot;, srcs = [&quot;dog.claro&quot;])
Animal(name = &quot;cat&quot;, srcs = [&quot;cat.claro&quot;])
</code></pre>
<hr />
<p>It couldn't possibly get much more concise than this! If you find yourself in a situation where you'll be defining lots
of very similar Modules, it's highly recommended that you at least consider whether an approach similar to this one will
work for you.</p>
<h2 id="swapping-dependencies-at-build-time-based-on-build-flags"><a class="header" href="#swapping-dependencies-at-build-time-based-on-build-flags">Swapping Dependencies at Build Time Based on Build Flags</a></h2>
<p>TODO(steving) I think that I probably want to move this to be its own top-level section.</p>
<p>TODO(steving) Fill out this section describing how this is effectively Dependency Injection handled at Build time rather
than depending on heavyweight DI frameworks.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>For more context, read about <a href="metaprogramming/code_reuse/reusing_module_apis/../../../module_system/module_apis/type_definitions/opaque_types/opaque_types.generated_docs.html">Opaque Types</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>It's highly recommended to start with Macros, but if you find that a Macro is getting a lot of use (for example if
you're publishing it for external consumption) you may find it beneficial to convert your Macro into a Bazel 
<a href="https://bazel.build/extending/rules" target="_blank">Rule</a>. Bazel Rules have much nicer <i>usage</i>
ergonomics as they enable Bazel to enforce certain higher level constraints such as requiring that certain parameters
only accept files with a certain suffix. However, Bazel Rules are <b>much</b> more complicated to define than Macros so
this should really be left to very advanced Bazel users.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>In practice, if you want a Bazel Macro to be reusable outside the Build package in which its <code>.bzl</code> file is 
defined, you'll need to use fully qualified target labels. E.g. <code>//full/path/to:target</code> rather than <code>:target</code>, as the
latter is a &quot;relative&quot; label whose meaning is dependent on the Build package the Macro is <i>used</i> in, which is
usually not what you want.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reusing-source-code"><a class="header" href="#reusing-source-code">Reusing Source Code</a></h1>
<p>Continuing to consider the &quot;Animals&quot; example from the 
<a href="metaprogramming/code_reuse/reusing_source_code/../reusing_module_apis/reusing_module_apis.generated_docs.html">previous section</a>, let's consider a simple refactoring.</p>
<p>As a reminder, previously, calls to <code>AnimalSounds::makeNoise(...)</code> produced very simple output:</p>
<h4 id="fig-1-80"><a class="header" href="#fig-1-80"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"># animals_example.claro
var animals: [oneof&lt;Cat::State, Dog::State&gt;] = [
    Dog::create(&quot;Milo&quot;, true),
    Dog::create(&quot;Fido&quot;, false),
    Cat::create(&quot;Garfield&quot;, &quot;This is worse than Monday morning.&quot;)
  ];

for (animal in animals) {
  print(AnimalSounds::AnimalSounds::makeNoise(animal));
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>Woof!
Grrrr...
This is worse than Monday morning.
</code></pre>
<hr />
<p>As currently defined...</p>
<h4 id="fig-2-67"><a class="header" href="#fig-2-67"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;:animals.bzl&quot;, &quot;Animal&quot;)

Animal(name = &quot;dog&quot;, srcs = [&quot;dog.claro&quot;])
Animal(name = &quot;cat&quot;, srcs = [&quot;cat.claro&quot;])
</code></pre>
<hr />
<p>...if we wanted to include the animals' names in the printed lines. We'd have to go and manually update each 
Module's implementation, making changes to both <code>dog.claro</code> and <code>cat.claro</code> (and importantly, to any other animals we'd
want to share this updated behavior):</p>
<h4 id="fig-3-53"><a class="header" href="#fig-3-53"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># cat.claro
newtype InternalState : struct { favoriteInsult: string }

implement AnimalSounds::AnimalSounds&lt;State&gt; {
  function makeNoise(cat: State) -&gt; string {
    # Cats are mean, they're going to say mean things no matter what.
    var noise = unwrap(unwrap(cat).internal).favoriteInsult;
    return &quot;{noise} - says {unwrap(cat).name}&quot;; # Analogous code repeated in dog.claro.
  }
}
<span class="boring">
</span><span class="boring">function create(name: string, favoriteInsult: string) -&gt; State {
</span><span class="boring">  return State({
</span><span class="boring">    name = name,
</span><span class="boring">    internal = InternalState({favoriteInsult = favoriteInsult})
</span><span class="boring">  });
</span><span class="boring">}
</span></code></pre>
<hr />
<p>And now, after making the changes, rerunning will give us the updated output we were looking for:</p>
<h4 id="fig-4-32"><a class="header" href="#fig-4-32"><em>Fig 4:</em></a></h4>
<hr />
<pre><code>Woof! - says Milo
Grrrr... - says Fido
This is worse than Monday morning. - says Garfield
</code></pre>
<hr />
<p>Repetition may be ok in some situations, but in many others, it would represent a risk of potential maintenance costs.</p>
<p>Of course, you could always factor out the common logic into a new Module that can be depended on and called explicitly
by each animal implementation (and in fact, <strong>this is absolutely the recommended approach in most situations</strong>). But,
since we're interested in digging into possible Build time metaprogramming capabilities in this section, by way of
example, we'll walk through <em><strong>some other ways</strong></em> you could go about <em><strong>sharing</strong></em> this base implementation across
Modules that potentially wouldn't have been immediately obvious, coming from other languages.</p>
<h2 id="claro_module-accepts-multiple-srcs"><a class="header" href="#claro_module-accepts-multiple-srcs"><code>claro_module(...)</code> Accepts Multiple Srcs</a></h2>
<p>The first thing to understand is that a Module's implementation <em><strong>can be spread across multiple source files</strong></em>. This
means that different <code>.claro</code> files can satisfy different portions of a Module's API. And, more importantly for our
current purposes, this means that instead of creating a whole new Module to contain the common logic factored out of
<code>dog.claro</code> and <code>cat.claro</code>, we could instead define a single new file containing that factored out logic...</p>
<h4 id="fig-5-23"><a class="header" href="#fig-5-23"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-claro"># get_message_with_name.claro
function getMessageWithName(message: string, state: State) -&gt; string {
  var name = unwrap(state).name; # All animal States have a top-level `name` field.
  return &quot;{message} - says {name}&quot;;
}
</code></pre>
<hr />
<p>...include it in the <code>srcs</code> of <strong><em>BOTH</em></strong> Module declarations...</p>
<h4 id="fig-6-14"><a class="header" href="#fig-6-14"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;:animals.bzl&quot;, &quot;Animal&quot;)

# An example of **LITERALLY** reusing code.
Animal(name = &quot;dog&quot;, srcs = [&quot;dog.claro&quot;, &quot;get_message_with_name.claro&quot;])
Animal(name = &quot;cat&quot;, srcs = [&quot;cat.claro&quot;, &quot;get_message_with_name.claro&quot;])
</code></pre>
<hr />
<p>...and then directly call the factored out function in <em>each</em> Module's implementation!</p>
<h4 id="fig-7-8"><a class="header" href="#fig-7-8"><em>Fig 7:</em></a></h4>
<hr />
<pre><code class="language-claro"># cat.claro
<span class="boring">newtype InternalState : struct { favoriteInsult: string }
</span><span class="boring">
</span>implement AnimalSounds::AnimalSounds&lt;State&gt; {
  function makeNoise(cat: State) -&gt; string {
    var noise = unwrap(unwrap(cat).internal).favoriteInsult;
    return getMessageWithName(noise, cat); # Analogous code repeated in dog.claro.
  }
}
<span class="boring">
</span><span class="boring">function create(name: string, favoriteInsult: string) -&gt; State {
</span><span class="boring">  return State({
</span><span class="boring">    name = name,
</span><span class="boring">    internal = InternalState({favoriteInsult = favoriteInsult})
</span><span class="boring">  });
</span><span class="boring">}
</span></code></pre>
<hr />
<p>This is an example of <strong><em>LITERAL</em></strong> code reuse - something that's generally not actually possible in other languages.
In fact, you could take this a step further by factoring out this shared src file directly into the <code>Animal(...)</code> 
<a href="metaprogramming/code_reuse/reusing_source_code/../reusing_module_apis/reusing_module_apis.generated_docs.html#declaring-a-macro-in-a-bzl-file-to-make-this-factored-out-build-logic-portable">Macro implementation</a>
to <em>automatically</em> make the <code>getMessageWithName(...)</code> function available to <strong>all</strong> <code>Animal(...)</code> declarations.</p>
<div class="warning">
<p>The key to this all working is that when the reused function references the <code>State</code> Type, it refers to either 
<code>Dog::State</code> or <code>Cat::State</code> depending on the context in which it's compiled. And the only field accessed via
<code>unwrap(state).name</code> is valid for both types. In a sense, this form of Build time metaprogramming has given this 
strongly, statically typed programming language the ability to drop down into dynamic &quot;duck typing&quot; features when it's
convenient to us. This utterly blurs the lines between the two typing paradigms while still maintaining all of the
static type validations because all of this is happening at Build time, with Compile time's type-checking validations
still to follow!</p>
</div>
<h2 id="inheritance---inverting-the-prior-example"><a class="header" href="#inheritance---inverting-the-prior-example">&quot;Inheritance&quot; - Inverting the Prior Example</a></h2>
<p>The prior example is a demonstration of the &quot;composition&quot; model where, in order to share code, you <strong><em>explicitly</em></strong> 
compose new code around the shared code by <strong><em>manually</em></strong> calling into the shared code. </p>
<p>But, of course, while composition is generally recommended over the inverted &quot;inheritance&quot; model, many people prefer the
convenience that inheritance-based designs offer. Specifically, as you saw in the prior example, composition is more
verbose, as you have to <strong><em>explicitly</em></strong> opt in to code sharing, whereas inheritance makes this <strong><em>implicit</em></strong>.</p>
<p>Now, instead of each Module implementing the <code>AnimalSounds</code> Contract manually, a single default implementation could be
written...</p>
<h4 id="fig-8-5"><a class="header" href="#fig-8-5"><em>Fig 8:</em></a></h4>
<hr />
<pre><code class="language-claro"># default_animal_sounds_impl.claro
implement AnimalSounds::AnimalSounds&lt;State&gt; {
  function makeNoise(state: State) -&gt; string {
    return &quot;{makeNoiseImpl(state)} - says {unwrap(state).name}&quot;;
  }
}
</code></pre>
<hr />
<p>...and then each Animal Module simply needs to define the expected internal implementation function <code>makeNoiseImpl(...)</code>
to provide its custom logic...</p>
<h4 id="fig-9-2"><a class="header" href="#fig-9-2"><em>Fig 9:</em></a></h4>
<hr />
<pre><code class="language-claro"># cat.claro
<span class="boring">newtype InternalState : struct { favoriteInsult: string }
</span><span class="boring">
</span>function makeNoiseImpl(cat: State) -&gt; string {
  # No more code duplication.
  return unwrap(unwrap(cat).internal).favoriteInsult;
}
<span class="boring">
</span><span class="boring">function create(name: string, favoriteInsult: string) -&gt; State {
</span><span class="boring">  return State({
</span><span class="boring">    name = name,
</span><span class="boring">    internal = InternalState({favoriteInsult = favoriteInsult})
</span><span class="boring">  });
</span><span class="boring">}
</span></code></pre>
<hr />
<p>...and again, the &quot;inherited&quot; code can be included in the <code>srcs</code> of <strong><em>BOTH</em></strong> Module declarations...</p>
<h4 id="fig-10-2"><a class="header" href="#fig-10-2"><em>Fig 10:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;:animals.bzl&quot;, &quot;Animal&quot;)

# An example of **LITERALLY** reusing code.
Animal(name = &quot;dog&quot;, srcs = [&quot;dog.claro&quot;, &quot;default_animal_sounds_impl.claro&quot;])
Animal(name = &quot;cat&quot;, srcs = [&quot;cat.claro&quot;, &quot;default_animal_sounds_impl.claro&quot;])
</code></pre>
<hr />
<div class="warning">
<p>Modern software engineering best practices have been progressing towards the consensus view that you should 
<a href="https://www.wikiwand.com/en/Composition_over_inheritance#Benefits" target="_blank">prefer composition over inheritance</a>.
But, even though this <em>preference</em> is generally shared by Claro's author, it shouldn't necessarily indicate that
inheritance is impossible to achieve. While Claro won't ever add first-class support for inheritance to the language,
Claro explicitly leaves these sorts of design decisions to you and provides Build time metaprogramming support to allow
the community to encode these sorts of organizational design patterns themselves to be available for whoever decides
they have a good reason for it. You shouldn't need to be hostage to the language designer's agreement or prioritization
to be able to extend the code organization patterns that can be expressed in the language.</p>
</div>
<h2 id="further-flexibility"><a class="header" href="#further-flexibility">Further Flexibility</a></h2>
<p>If you've made it this far, well done! You may never need to use these &quot;power user&quot; features, but you should now have
the core conceptual background that you'll need to use Bazel to encode your own relatively sophisticated custom 
organizational design patterns in your Claro programs using Build time metaprogramming! </p>
<p>Of course, there's always another step deeper into such waters. By continuing on to the next section, we'll continue to
develop the Animals example <em>even further</em>. In particular, we'll demonstrate one such sophisticated design pattern
called &quot;Abstract Modules&quot; that fully generalizes <em>all</em> of the functionality described in the past two sections, and
goes <em>even further</em> to provide significant configurability controls on top of what you've seen in the example 
<code>Animal(...)</code> macro so far.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-modules"><a class="header" href="#abstract-modules">Abstract Modules</a></h1>
<p>In the past couple sections we've worked through examples of some fairly complex Build time metaprogramming to generate
Modules that share some common behaviors between them. Having those low-level Build tools in your back pocket is
something that may very well come in handy during your Claro development journey. However, in general, it's worth
acknowledging that there's some inherent complexity in the prior approaches. It's my hope that the community will
standardize around some well-defined set of Build design patterns that are encoded into well-known, standardized
interfaces (Bazel Macros/Rules) to abstract away the low-level complexity underneath.</p>
<p>In this section, I'll try to demonstrate what such a standardized encoding might look like for the design pattern
demonstrated in the prior sections.</p>
<h2 id="limitations-of-the-approach-in-the-prior-sections"><a class="header" href="#limitations-of-the-approach-in-the-prior-sections">Limitations of the Approach in the Prior Sections</a></h2>
<p>The <code>Animal(...)</code> Macro defined in the previous sections was extremely rigid. It encoded exactly one specific code 
structure. It was arguably a very useful structure, but if we wanted to create an <code>Animal(...)</code> that deviated even
slightly from the expected structure, you'd either have to go and refactor the Macro definition itself and all usages to
add support for new behaviors, or you'd just have to fall back to manually defining a Module, losing all Build level
code sharing that you were trying to achieve with the standardized <code>Animal(...)</code> Macro.</p>
<p>All that said, the biggest limitation of the approach in the prior sections is that <strong><em>it was bespoke</em></strong>. While all the
customizability that Build time metaprogramming gives you blows the design space wide open, it also makes it that much
harder for anyone unfamiliar with the domain to follow what's going on.</p>
<h2 id="abstracting-away-the-abstract-module-pattern-itself"><a class="header" href="#abstracting-away-the-abstract-module-pattern-itself">Abstracting Away the &quot;Abstract Module&quot; Pattern Itself</a></h2>
<p>Arguably, the <code>Animal(...)</code> macro from the previous sections could be described as an encoding of an &quot;Abstract Module&quot;
(in a sense vaguely similar to Java's &quot;Abstract Classes&quot; - minus the object-orientation). &quot;Abstract&quot; in the sense that
some portions of all &quot;Animal&quot; Modules are known before even knowing the &quot;concrete Animal&quot; Modules that you'll
specifically build later on. But there's nothing about this concept itself that's unique to &quot;Animals&quot;. All sorts of
categories of similar Modules can be imagined, and they could potentially <em>all</em> benefit from a similar &quot;Abstract&quot; base
encoding that later gets specialized for each concrete Module.</p>
<p>Largely as a <em>draft</em> demonstration of what a standardized encoding of this &quot;Abstract Module&quot; design pattern <em>could</em> look
like, Claro provides a <code>claro_abstract_module(...)</code> Bazel Macro. Now, the 
<a href="metaprogramming/code_reuse/abstract_modules/../reusing_module_apis/reusing_module_apis.generated_docs.html#declaring-a-macro-in-a-bzl-file-to-make-this-factored-out-build-logic-portable"><code>Animal(...)</code> Macro</a> 
can be auto-generated in a few lines by simply calling the <code>claro_abstract_module(...)</code> Macro.</p>
<h4 id="fig-1-81"><a class="header" href="#fig-1-81"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-python"># animal.bzl
load(
    &quot;@claro-lang//stdlib/utils/abstract_modules:abstract_module.bzl&quot;,
    &quot;claro_abstract_module&quot;,
)

Animal = \
    claro_abstract_module(
        name = &quot;Animal&quot;,
        module_api_file = &quot;animal.claro_module_api&quot;,
        overridable_srcs = {
            &quot;AnimalSoundsImpl&quot;: &quot;:default_animal_sounds_impl.claro&quot;,
            &quot;InternalStateAndConstructor&quot;: &quot;:default_internal_state.claro&quot;,
            &quot;MakeNoiseImpl&quot;: &quot;:default_make_noise_impl.claro&quot;,
        },
        default_deps = {
            &quot;AnimalSounds&quot;: &quot;:animal_sounds&quot;,
        },
        default_exports = [&quot;AnimalSounds&quot;],
    )
</code></pre>
<hr />
<h2 id="override-flexibility"><a class="header" href="#override-flexibility">Override Flexibility</a></h2>
<p>On top of being a standardized encoding of this design pattern, &quot;Abstract Modules&quot; provide an additional mechanism for
various components of the Module to be override-able. In the <code>Animal = claro_abstract_module(...)</code> declaration above,
the <code>overridable_srcs = {...}</code> arg lists a few different <em>named</em> components that have default implementations provided
as <code>.claro</code> source files that can be optionally overridden by any concrete <code>Animal(...)</code> usages. For the sake of
demonstration, the &quot;Abstract Animal Module&quot; has been decomposed into a relatively fine granularity, allowing significant
customization to downstream users of the Macro.</p>
<p>So now the <code>Animal(...)</code> macro can be used very similarly as in the previous sections, but with some slightly different
arguments:</p>
<h4 id="fig-2-68"><a class="header" href="#fig-2-68"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;:animal.bzl&quot;, &quot;Animal&quot;)

[
    Animal(
        name = animal,
        api_extensions = [&quot;:{0}_cons.claro_module_api&quot;.format(animal)],
        override = {
            &quot;InternalStateAndConstructor&quot;: &quot;:{0}_state_and_cons.claro&quot;.format(animal),
            &quot;MakeNoiseImpl&quot;: &quot;:{0}_noise.claro&quot;.format(animal),
        },
    )
    for animal in [&quot;dog&quot;, &quot;cat&quot;]
]

# ...
</code></pre>
<hr />
<p>The first notable detail is that the idea of extending Module APIs is now encoded directly into the &quot;Abstract Module&quot;
Macros returned by <code>claro_abstract_module(...)</code> in the form of the <code>api_extensions = [...]</code> parameter. So now, we didn't
need to manually concatenate api files using a Bazel <code>genrule(...)</code> as we 
<a href="metaprogramming/code_reuse/abstract_modules/../reusing_module_apis/reusing_module_apis.generated_docs.html#fig-9">did in the prior sections</a>. Then, notice that
the concrete <code>cat</code> and <code>dog</code> Animal Modules now implicitly inherit the default <code>AnimalSoundsImpl</code> implementation, while
explicitly overriding <code>InternalStateAndConstructor</code> and <code>MakeNoiseImpl</code> with custom implementations. Now, these Module
definitions can be used exactly the same as they were when defined using the approach(es) from the prior sections.</p>
<p>As one final motivating example, to demonstrate something that this <em>new</em> <code>Animal(...)</code> implementation can do that the
prior implementation(s) couldn't, we can also define a new Animal Module that overrides the default <code>AnimalSounds</code>
Contract implementation, by overriding <code>AnimalSoundsImpl</code>:</p>
<h4 id="fig-3-54"><a class="header" href="#fig-3-54"><em>Fig 3:</em></a></h4>
<hr />
<pre><code class="language-claro"># platypus_animal_sounds_impl.claro
implement AnimalSounds::AnimalSounds&lt;State&gt; {
  function makeNoise(state: State) -&gt; string {
    var name = unwrap(state).name;
    if (unwrap(unwrap(state).internal).isWearingFedora) { # https://youtu.be/KFssdwb7dF8?si=Omgf1-D3qIBY6jO9
      var codename = name[0];
      return &quot;!!!!!!!!!! REDACTED TOP SECRET MESSAGE !!!!!!!!!! - Agent {codename}&quot;;
    }
    return &quot;Chirp Chirp - says {name}&quot;;
  }
}
</code></pre>
<hr />
<h4 id="fig-4-33"><a class="header" href="#fig-4-33"><em>Fig 4:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;:animal.bzl&quot;, &quot;Animal&quot;)

# ...

Animal(
    name = &quot;platypus&quot;,
    api_extensions = [&quot;:platypus_cons.claro_module_api&quot;],
    override = {
        &quot;AnimalSoundsImpl&quot;: &quot;:platypus_animal_sounds_impl.claro&quot;,
        &quot;InternalStateAndConstructor&quot;: &quot;:platypus_state_and_cons.claro&quot;,
    },
)
</code></pre>
<hr />
<p>And now, our demo program can start use the <code>platypus</code> Module just as it was using the <code>dog</code> and <code>cat</code> Modules 
previously:</p>
<h4 id="fig-5-24"><a class="header" href="#fig-5-24"><em>Fig 5:</em></a></h4>
<hr />
<pre><code class="language-python"># BUILD
load(&quot;@claro-lang//:rules.bzl&quot;, &quot;claro_module&quot;, &quot;claro_binary&quot;)

# ...

claro_binary(
    name = &quot;animals_example&quot;,
    main_file = &quot;animals_example.claro&quot;,
    deps = {
        &quot;AnimalSounds&quot;: &quot;:animal_sounds&quot;,
        &quot;Cat&quot;: &quot;:cat&quot;,
        &quot;Dog&quot;: &quot;:dog&quot;,
        &quot;Platypus&quot;: &quot;:platypus&quot;,
    },
)
</code></pre>
<hr />
<h4 id="fig-6-15"><a class="header" href="#fig-6-15"><em>Fig 6:</em></a></h4>
<hr />
<pre><code class="language-claro"># animals_example.claro
var animals: [oneof&lt;Cat::State, Dog::State, Platypus::State&gt;] = [
    Dog::create(&quot;Milo&quot;, true),
    Dog::create(&quot;Fido&quot;, false),
    Cat::create(&quot;Garfield&quot;, &quot;This is worse than Monday morning.&quot;),
    Platypus::create(&quot;Perry&quot;, false),
    Platypus::create(&quot;Perry&quot;, true)
  ];

for (animal in animals) {
  print(AnimalSounds::AnimalSounds::makeNoise(animal));
}
</code></pre>
<p><em>Output:</em></p>
<pre><code>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/6 because it is locked by another process (errno = 11)
Woof! - says Milo
Grrrr... - says Fido
This is worse than Monday morning. - says Garfield
Chirp Chirp - says Perry
!!!!!!!!!! REDACTED TOP SECRET MESSAGE !!!!!!!!!! - Agent P
</code></pre>
<hr />
<h2 id="additional-knobs--implementation-details"><a class="header" href="#additional-knobs--implementation-details">Additional Knobs &amp; Implementation Details</a></h2>
<p>The point of this section is really to <em>demonstrate</em> some possibilities available to all Claro users interested in
writing Bazel Macros to encode relatively complex design patterns. And, I think we can agree that being able to 
hand-roll the very concept of <em>inheritance</em> without having to make a single change to the Claro compiler itself is a
rather powerful capability!</p>
<p>But to say it once more, this is all meant as a demonstration, rather than encouragement of specific usage of this
<code>claro_abstract_module(...)</code> Macro. So, we won't dive any further into the implementation details of how this prototype
works, and we won't even go into the full range of capabilities that this prototype currently supports. However, if
you're sufficiently interested that you really wanted to know more, feel free to check out 
<a href="https://github.com/JasonSteving99/claro-lang/blob/main/stdlib/utils/abstract_modules/abstract_module_internal.bzl" target="_blank">the implementation</a>
yourself! You'll probably learn a lot about Bazel in the process of reading through it, so it could be enlightening.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-modules"><a class="header" href="#default-modules">Default Modules</a></h1>
<p>Claro aims to provide an expansive standard library of modules that all Claro programs have an implicit dependency on at
all times. Any of these default StdLib modules can be accessed directly with calls like:</p>
<h4 id="fig-1-82"><a class="header" href="#fig-1-82"><em>Fig 1:</em></a></h4>
<hr />
<pre><code class="language-claro"><span class="boring"> var l: mut [int] = mut [];
</span>lists::add(l, 1);
lists::add(l, 2);
<span class="boring"> print(l);
</span></code></pre>
<p><em>Output:</em></p>
<pre><code>mut [1, 2]
</code></pre>
<hr />
<p>and you <strong>never need to manually place an explicit dependency</strong> at the BUILD level like you normally would for any other
module outside the StdLib:</p>
<h4 id="fig-2-69"><a class="header" href="#fig-2-69"><em>Fig 2:</em></a></h4>
<hr />
<pre><code class="language-python">claro_binary(
    name = &quot;some_binary&quot;,
    main_file = &quot;some_file.claro&quot;,
    deps = {
        # Deps on modules outside the StdLib require an explicit Build dep.
        &quot;SomeDep&quot;: &quot;//path/to/some/dep:module&quot;,
    },
)
</code></pre>
<hr />
<div class="warning">
<h2 id="the-stdlib-is-a-wip---recommendations-are-welcome"><a class="header" href="#the-stdlib-is-a-wip---recommendations-are-welcome">The StdLib is a WIP - Recommendations are Welcome!</a></h2>
<p>Of course, as Claro's still at a very early stage, a certain level of incompleteness has to be expected. Please don't
hesitate to <strong>reach out with suggestions</strong> in ways that the current standard library could be improved or expanded!</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booleans"><a class="header" href="#booleans">booleans</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
function parseBoolean(s: string) -&gt; boolean;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deque"><a class="header" href="#deque">deque</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro"># This module simply exposes the functionality from java.util.ArrayDeque&lt;E&gt; to Claro programs. See:
#   - https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html

# Deque = &quot;Double-ended queue&quot;.
opaque newtype mut Deque&lt;E&gt;

atom NO_SUCH_ELEMENT
atom DEQUE_UNCHANGED

provider create&lt;T&gt;() -&gt; Deque&lt;T&gt;;
function of&lt;T&gt;(elems: [T]) -&gt; Deque&lt;T&gt;;
function withCapacity&lt;T&gt;(initialCapacity: int) -&gt; Deque&lt;T&gt;;

consumer addAllToFront&lt;T&gt;(deque: Deque&lt;T&gt;, elems: [T]);

consumer addFirst&lt;T&gt;(deque: Deque&lt;T&gt;, t: T);
consumer addLast&lt;T&gt;(deque: Deque&lt;T&gt;, t: T);

consumer clear&lt;T&gt;(deque: Deque&lt;T&gt;);

# TODO(steving) Claro's intended to have support for the builtin `copy()` function. For $java_type's however this can't
# TODO(steving)   be automatically generated, so I need some mechanism for $java_type's to provide a function for that
# TODO(steving)   copying implementation.
function clone&lt;T&gt;(deque: Deque&lt;T&gt;) -&gt; Deque&lt;T&gt;;

function contains&lt;T&gt;(deque: Deque&lt;T&gt;, t: T) -&gt; boolean;
function containsAll&lt;T&gt;(deque: Deque&lt;T&gt;, elems: [T]) -&gt; boolean;

consumer forEach&lt;T&gt;(deque: Deque&lt;T&gt;, action: consumer&lt;T&gt;);

function isEmpty&lt;T&gt;(deque: Deque&lt;T&gt;) -&gt; boolean;

function peekFirst&lt;T&gt;(deque: Deque&lt;T&gt;) -&gt; oneof&lt;T, NO_SUCH_ELEMENT&gt;;
function peekLast&lt;T&gt;(deque: Deque&lt;T&gt;) -&gt; oneof&lt;T, NO_SUCH_ELEMENT&gt;;

function pollFirst&lt;T&gt;(deque: Deque&lt;T&gt;) -&gt; oneof&lt;T, NO_SUCH_ELEMENT&gt;;
function pollLast&lt;T&gt;(deque: Deque&lt;T&gt;) -&gt; oneof&lt;T, NO_SUCH_ELEMENT&gt;;

function removeAll&lt;T&gt;(deque: Deque&lt;T&gt;, elems: [T]) -&gt; oneof&lt;std::OK, NO_SUCH_ELEMENT&gt;;
function removeElement&lt;T&gt;(deque: Deque&lt;T&gt;, t: T) -&gt; oneof&lt;std::OK, NO_SUCH_ELEMENT&gt;;
function removeFirst&lt;T&gt;(deque: Deque&lt;T&gt;) -&gt; oneof&lt;T, NO_SUCH_ELEMENT&gt;;
function removeFirstOccurrence&lt;T&gt;(deque: Deque&lt;T&gt;, t: T) -&gt; oneof&lt;std::OK, NO_SUCH_ELEMENT&gt;;
function removeIf&lt;T&gt;(deque: Deque&lt;T&gt;, predicate: function&lt;T -&gt; boolean&gt;) -&gt; oneof&lt;std::OK, DEQUE_UNCHANGED&gt;;
function removeLast&lt;T&gt;(deque: Deque&lt;T&gt;) -&gt; oneof&lt;T, NO_SUCH_ELEMENT&gt;;
function removeLastOccurrence&lt;T&gt;(deque: Deque&lt;T&gt;, t: T) -&gt; oneof&lt;std::OK, NO_SUCH_ELEMENT&gt;;

function retainAll&lt;T&gt;(deque: Deque&lt;T&gt;, elems: [T]) -&gt; oneof&lt;std::OK, DEQUE_UNCHANGED&gt;;

function size&lt;T&gt;(deque: Deque&lt;T&gt;) -&gt; int;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="doubles"><a class="header" href="#doubles">doubles</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
newtype InvalidNumberFormat : struct { msg: string }

static MAX_VALUE: double;
static MIN_VALUE: double;

function parseDouble(s: string) -&gt; oneof&lt;double, std::Error&lt;InvalidNumberFormat&gt;&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="files"><a class="header" href="#files">files</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
# Opaque type whose internal representation is not exposed to consumers. This cannot be unwrapped OR initialized by any
# code outside of this module's srcs.
opaque newtype Resource
newtype IOError : string

# Now some claro file could read a resource declared in its build target as:
#   claro_module(
#     name = &quot;foo&quot;,
#     module_api_file = &quot;foo.claro_module_api&quot;,
#     srcs = [&quot;foo.claro&quot;],
#     resources = {&quot;MyFile&quot;: &quot;myfile.txt&quot;},
#   }
# Inside `foo.claro`:
#   var fileContents: string = files::readOrPanic(resources::MyFile);
function read(resource: Resource) -&gt; oneof&lt;string, std::Error&lt;IOError&gt;&gt;;
function readOrPanic(resource: Resource) -&gt; string;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floats"><a class="header" href="#floats">floats</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
newtype InvalidNumberFormat : struct { msg: string }

static MAX_VALUE: float;
static MIN_VALUE: float;

function parseFloat(s: string) -&gt; oneof&lt;float, std::Error&lt;InvalidNumberFormat&gt;&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="futures"><a class="header" href="#futures">futures</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
# Creates a `future` which has its value set immediately upon construction. The getters just return the value. This
# `future` can't be canceled or timed out and `futures::isDone(futures::immediateFuture(...))` always returns true.
function immediateFuture&lt;T&gt;(t: T) -&gt; future&lt;T&gt;;

# Creates a `future` which is cancelled immediately upon construction, so that `futures::isCancelled` always returns `true`.
provider immediateCancelledFuture&lt;T&gt;() -&gt; future&lt;T&gt;;

# Executes the given tasks, returning a list of Futures holding their status and results when all complete.
function invokeAll&lt;T&gt;(tasks: [provider&lt;T&gt;]) -&gt; [future&lt;T&gt;];

# Attempts to cancel execution of this task. This attempt will fail if the task has already completed, has already been
# cancelled, or could not be cancelled for some other reason. If successful, and this task has not started when cancel
# is called, this task should never run. If the task has already started, then the mayInterruptIfRunning parameter
# determines whether the thread executing this task should be interrupted in an attempt to stop the task.
#
# After this method returns, subsequent calls to `futures::isDone` will always return true. Subsequent calls to
# isCancelled() will always return true if this method returned true.
#
# Returns: `false` if the task could not be cancelled, typically because it has already completed normally; `true` otherwise.
function cancel&lt;T&gt;(f: future&lt;T&gt;, mayInterrupt: boolean) -&gt; boolean;

# Returns `true` if this task was cancelled before it completed normally, else `false`.
function isCancelled&lt;T&gt;(f: future&lt;T&gt;) -&gt; boolean;

# Returns `true` if this task completed. Completion may be due to normal termination, a Panic, or cancellation -- in all
# of these cases, this method will return `true`.
function isDone&lt;T&gt;(f: future&lt;T&gt;) -&gt; boolean;

# Creates a new `future` whose value is a list containing the values of all its input `future`s, if all succeed. The
# list of results is in the same order as the input list.
#
# Canceling this returned `future` will attempt to cancel all the component `future`s, and if any of the provided
# `future`s fails or is canceled, this one is, too.
function allAsList&lt;T&gt;(futures: [future&lt;T&gt;]) -&gt; future&lt;[T]&gt;;

# Creates a `future` that runs the given provider when the futures complete whether or not they're successful.
# Canceling this future will attempt to cancel all the component futures.
function whenAllComplete&lt;T, V&gt;(futures: [future&lt;T&gt;], action: provider&lt;V&gt;) -&gt; future&lt;V&gt;;
function whenAllCompleteAsync&lt;T, V&gt;(futures: [future&lt;T&gt;], action: provider&lt;future&lt;V&gt;&gt;) -&gt; future&lt;V&gt;;

# Creates a `future` that runs the given provider requiring that all passed in futures are successful. If any input
# fails, the returned future fails immediately. Canceling this future will attempt to cancel all the component futures.
function whenAllSucceed&lt;T, V&gt;(futures: [future&lt;T&gt;], action: provider&lt;V&gt;) -&gt; future&lt;V&gt;;
function whenAllSucceedAsync&lt;T, V&gt;(futures: [future&lt;T&gt;], action: provider&lt;future&lt;V&gt;&gt;) -&gt; future&lt;V&gt;;

# Creates a new `future` whose value is a list containing the values of all its successful input futures. The list of
# results is in the same order as the input list, and if any of the provided futures Panics or is canceled, its
# corresponding position will contain `futures::DID_NOT_SUCCEED`. Canceling this future will attempt to cancel all the
# component futures.
function successfulAsList&lt;T&gt;(futures: [future&lt;T&gt;]) -&gt; future&lt;[T]&gt;;

# Returns a list of delegate futures that correspond to the futures received in the order that they complete. Delegate
# futures return the same value as the corresponding input future returns.
#
# &quot;In the order that they complete&quot; means, for practical purposes, about what you would expect, but there are some
# subtleties. First, we do guarantee that, if the output future at index n is done, the output future at index n-1 is
# also done. (But as usual with futures, some listeners for future n may complete before some for future n-1.) However,
# it is possible, if one input completes with result X and another later with result Y, for Y to come before X in the
# output future list. (Such races are impossible to solve without global synchronization of all future completions. And
# they should have little practical impact.)
#
# Cancelling a delegate future propagates to input futures once all the delegates complete, either from cancellation or
# because an input future has completed. If N futures are passed in, and M delegates are cancelled, the remaining M
# input futures will be cancelled once N - M of the input futures complete. If all the delegates are cancelled, all the
# input futures will be too.
function inCompletionOrder&lt;T&gt;(futures: [future&lt;T&gt;]) -&gt; [future&lt;T&gt;];

# Schedules action on given delay on the default single-threaded scheduled executor service (separate from the default
# multi-threaded graph executor service). Actions scheduled via this function will be executed in FIFO order.
function schedule&lt;T&gt;(action: provider&lt;T&gt;, delay: duration::Duration) -&gt; future&lt;T&gt;;
function scheduleAsync&lt;T&gt;(action: provider&lt;future&lt;T&gt;&gt;, delay: duration::Duration) -&gt; future&lt;T&gt;;

# Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with
# the given period; that is executions will commence after initialDelay then initialDelay+period, then
# initialDelay + 2 * period, and so on.
# TODO(steving) Claro really should probably have another procedure type ala &quot;runnable&quot; or &quot;action&quot; or something rather
# TODO(steving)   than this somewhat nonsensical consumer&lt;std::Nothing&gt;.
function scheduleAtFixedRate(
  action: consumer&lt;std::Nothing&gt;, initialDelay: duration::Duration, period: duration::Duration) -&gt; future&lt;std::Nothing&gt;;

# Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with
# the given delay between the termination of one execution and the commencement of the next.
function scheduleWithFixedDelay(
  action: consumer&lt;std::Nothing&gt;, initialDelay: duration::Duration, delay: duration::Duration) -&gt; future&lt;std::Nothing&gt;;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[0.001s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="fp"><a class="header" href="#fp">fp</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
function map&lt;A, B&gt;(l: [A], fn: function&lt;A -&gt; B&gt;) -&gt; [B];
function filter&lt;A&gt;(l: [A], pred: function&lt;A -&gt; boolean&gt;) -&gt; [A];
function reduce&lt;A, B&gt;(l: [A], fn: function&lt;|B, A| -&gt; B&gt;, accum: B) -&gt; B;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ints"><a class="header" href="#ints">ints</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">static MAX_VALUE: int;
static MIN_VALUE: int;

newtype InvalidNumberFormat : struct { msg: string }

function parseInt(s: string) -&gt; oneof&lt;int, std::Error&lt;InvalidNumberFormat&gt;&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lists-1"><a class="header" href="#lists-1">lists</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro"># This module simply provides access to the functionality described in:
#   - https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html
# The signatures found here in this module are not a 1:1 match with the signatures in their Java equivalents, however,
# as all error cases have been intentionally modelled as proper return values wrapped in std::Error&lt;...&gt;. In this way,
# interacting with any procedures defined in this module will be inherently safe.

# TODO(steving) Claro needs some sort of Collection&lt;T&gt; contract or something so that duplicated procedures aren't needed
# TODO(steving)     for mut/immut cases.

# TODO(steving) If at all possible, ClaroList.java should be refactored so that it *contains* a List rather than extends
# TODO(steving)     ArrayList directly so that functionality directly from Guava's Lists class can be directly added to
# TODO(steving)     this module w/o losing the performance wins of their &quot;views&quot;.
# TODO(steving)   - https://guava.dev/releases/23.0/api/docs/com/google/common/collect/Lists.html

newtype IndexOutOfBounds : struct {index: int, size: int}
newtype IndicesOutOfOrder : struct {invalidLowerBound: int, invalidUpperBound: int}
newtype InvalidCapacity : int
newtype ElementNotFound&lt;T&gt; : T

# Appends the specified element to the end of this list.
consumer add&lt;T&gt;(l: mut [T], toAdd: T);

# Appends all of the elements in the second list to the end of the first list, in the order they appear in the second.
# The behavior of this call is undefined if both args reference the same non-empty list.
#
# Returns: `true` if this list changed as a result of the call, else `false`.
function addAll&lt;T&gt;(l: mut [T], toAdd: [T]) -&gt; boolean;
function addAllFromMut&lt;T&gt;(l: mut [T], toAdd: mut [T]) -&gt; boolean;

# Removes all of the elements from this list. The list will be empty after this call returns.
consumer clear&lt;T&gt;(l: mut [T]);

# Returns: true if this list contains the specified element, else `false`.
function contains&lt;T&gt;(l: [T], elem: T) -&gt; boolean;
function containsInMut&lt;T&gt;(l: mut [T], elem: T) -&gt; boolean;

# Returns: true if this list contains all of the elements of the specified collection, else `false`.
function containsAll&lt;T&gt;(l: [T], elems: [T]) -&gt; boolean;
function containsAllFromMut&lt;T&gt;(l: [T], elems: mut [T]) -&gt; boolean;
function containsAllInMut&lt;T&gt;(l: mut [T], elems: [T]) -&gt; boolean;
function containsAllInMutFromMut&lt;T&gt;(l: mut [T], elems: mut [T]) -&gt; boolean;

# Increases the capacity of this list instance, if necessary, to ensure that it can hold at least the number of elements
# specified by the minimum capacity argument.
consumer ensureCapacity&lt;T&gt;(l: mut [T], minCapacity: int);

# Performs the given action for each element.
consumer forEach&lt;T&gt;(l: [T], action: consumer&lt;T&gt;);
consumer forEachInMut&lt;T&gt;(l: mut [T], action: consumer&lt;T&gt;);

# Returns the element at the specified position in this list. This is a bounds-checked alternative to directly accessing
# via the unsafe `[]` which may result in a runtime Panic.
function getAt&lt;T&gt;(l: [T], index: int) -&gt; oneof&lt;T, std::Error&lt;IndexOutOfBounds&gt;&gt;;
function getAtInMut&lt;T&gt;(l: mut [T], index: int) -&gt; oneof&lt;T, std::Error&lt;IndexOutOfBounds&gt;&gt;;

# Returns: the index of the first occurrence of the specified element in this list, or -1 if this list does not contain
#          the element.
function indexOf&lt;T&gt;(l: [T], t: T) -&gt; oneof&lt;int, std::Error&lt;ElementNotFound&lt;T&gt;&gt;&gt;;
function indexOfInMut&lt;T&gt;(l: mut [T], t: T) -&gt; oneof&lt;int, std::Error&lt;ElementNotFound&lt;T&gt;&gt;&gt;;

# Inserts all of the elements in the second list into the first list, starting at the specified position. Shifts the
# element currently at that position (if any) and any subsequent elements to the right (increases their indices). The
# new elements will appear in the first list in the order that they occur in the second list.
#
# Returns: `true` if this list changed as a result of the call, else `false`.
function insertAllAt&lt;T&gt;(l: mut [T], index: int, elems: [T]) -&gt; oneof&lt;boolean, std::Error&lt;IndexOutOfBounds&gt;&gt;;
function insertAllAtFromMut&lt;T&gt;(l: mut [T], index: int, elems: mut [T]) -&gt; oneof&lt;boolean, std::Error&lt;IndexOutOfBounds&gt;&gt;;

# Inserts the specified element at the specified position in this list. Shifts the element currently at that position
# (if any) and any subsequent elements to the right (adds one to their indices).
function insertAt&lt;T&gt;(l: mut [T], index: int, t: T) -&gt; oneof&lt;std::OK, std::Error&lt;IndexOutOfBounds&gt;&gt;;

# Returns: `true` if this list contains no elements, else `false`.
function isEmpty&lt;T&gt;(l: [T]) -&gt; boolean;
function isEmptyInMut&lt;T&gt;(l: mut [T]) -&gt; boolean;

# Returns: the index of the last occurrence of the specified element in this list, or -1 if this list does not contain
#          the element.
function lastIndexOf&lt;T&gt;(l: [T], t: T) -&gt; oneof&lt;int, std::Error&lt;ElementNotFound&lt;T&gt;&gt;&gt;;
function lastIndexOfInMut&lt;T&gt;(l: mut [T], t: T) -&gt; oneof&lt;int, std::Error&lt;ElementNotFound&lt;T&gt;&gt;&gt;;

# Removes from this list all of its elements that are contained in the specified collection.
#
# Returns: `true` if this list changed as a result of the call, else `false`.
function removeAll&lt;T&gt;(l: mut [T], toRemove: [T]) -&gt; boolean;
function removeAllFromMut&lt;T&gt;(l: mut [T], toRemove: mut [T]) -&gt; boolean;

# TODO(steving) Drop `remove()` as builtin token from lexer/parser so that this isn't duplicated.
# Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one
# from their indices).
#
# Returns: the element that was removed from the list.
function removeAt&lt;T&gt;(l: mut [T], index: int) -&gt; oneof&lt;T, std::Error&lt;IndexOutOfBounds&gt;&gt;;

# Removes the first occurrence of the specified element from this list, if it is present. If the list does not contain
# the element, it is unchanged.
#
# Returns: `true` if this list contained the specified element, else `false`.
function removeFirst&lt;T&gt;(l: mut [T], t: T) -&gt; boolean;

# Removes all of the elements of this list that satisfy the given predicate.
#
# Returns: `true` if any elements were removed, else `false`.
function removeIf&lt;T&gt;(l: mut [T], pred: function&lt;T -&gt; boolean&gt;) -&gt; boolean;

# Replaces each element of this list with the result of applying the operator to that element.
consumer replaceAll&lt;T&gt;(l: mut [T], operator: function&lt;T -&gt; T&gt;);

# Retains only the elements in the first list that are contained in the second list. In other words, removes from the
# first list all of its elements that are not contained in the second list.
#
# Returns: `true` if this list changed as a result of the call, else `false`.
function retainAll&lt;T&gt;(l: mut [T], toRetain: [T]) -&gt; boolean;
function retainAllFromMut&lt;T&gt;(l: mut [T], toRetain: mut [T]) -&gt; boolean;

# Replaces the element at the specified position in this list with the specified element. This is a bounds-checked
# alternative to directly setting via the unsafe `l[index] = ...` which may result in a runtime Panic.
function setAt&lt;T&gt;(l: mut [T], index: int, t: T) -&gt; oneof&lt;T, std::Error&lt;IndexOutOfBounds&gt;&gt;;

# Sorts this list according to the order induced by the specified comparator.
# For detailed explanation of &quot;comparators&quot;, see: https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html
consumer sort&lt;T&gt;(l: mut [T], comparator: function&lt;|T, T| -&gt; int&gt;);

# Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If
# `fromInclusive` and `toExclusive` are equal, the returned list is empty.)
function subList&lt;T&gt;(l: [T], fromInclusive: int, toExclusive: int)
    -&gt; oneof&lt;[T], std::Error&lt;IndexOutOfBounds&gt;, std::Error&lt;IndicesOutOfOrder&gt;&gt;;
# TODO(steving) If at all possible, ClaroList.java should be refactored so that it *contains* a List rather than extends
# TODO(steving)     ArrayList directly so that subListOfMut() can return a proper &quot;view&quot;.
# TODO(steving)   - https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#addAll-int-java.util.Collection-:~:text=This%20method%20eliminates,from%2C%20to).clear()%3B
function subListOfMut&lt;T&gt;(l: mut [T], fromInclusive: int, toExclusive: int)
    -&gt; oneof&lt;mut [T], std::Error&lt;IndexOutOfBounds&gt;, std::Error&lt;IndicesOutOfOrder&gt;&gt;;

# Trims the capacity of this list instance to be the list's current size. An application can use this operation to
# minimize the storage of a list instance.
consumer trimToSize&lt;T&gt;(l: mut [T]);

# Constructs an empty list with the specified initial capacity.
function withInitialCapacity&lt;T&gt;(capacity: int) -&gt; oneof&lt;mut [T], std::Error&lt;InvalidCapacity&gt;&gt;;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="longs"><a class="header" href="#longs">longs</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
newtype InvalidNumberFormat : struct { msg: string }

static MAX_VALUE: long;
static MIN_VALUE: long;

function parseLong(s: string) -&gt; oneof&lt;long, std::Error&lt;InvalidNumberFormat&gt;&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maps-1"><a class="header" href="#maps-1">maps</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro"># This module simply provides access to the functionality described in:
#   - https://docs.oracle.com/javase/8/docs/api/java/util/Map.html
# The signatures found here in this module are not a 1:1 match with the signatures in their Java equivalents, however,
# as all error cases have been intentionally modelled as proper return values wrapped in std::Error&lt;...&gt;. In this way,
# interacting with any procedures defined in this module will be inherently safe.

# TODO(steving) Claro needs some sort of Map&lt;T&gt; contract or something so that duplicated procedures aren't needed
# TODO(steving)     for mut/immut cases.

# TODO(steving) If at all possible, ClaroMap.java &amp; ClaroSet.java should be refactored to *contains* a collection rather
# TODO(steving)     than extending the Java collections directly so that functionality directly from Guava's Maps
# TODO(steving)     class can be directly added to this module w/o losing the performance wins of their &quot;views&quot;.
# TODO(steving)   - https://guava.dev/releases/22.0/api/docs/com/google/common/collect/Maps.html


# Returns true if this map contains no key-value mappings.
function isEmpty&lt;K,V&gt;(m: {K:V}) -&gt; boolean;
function isEmptyMut&lt;K,V&gt;(m: mut {K:V}) -&gt; boolean;

# Returns true if this map maps one or more keys to the specified value. This operation will require time linear in the map size.
function containsValue&lt;K,V&gt;(m: {K:V}, v: V) -&gt; boolean;
function containsValueInMut&lt;K,V&gt;(m: mut {K:V}, v: V) -&gt; boolean;

# Returns the value to which the specified key is mapped, or `defaultValue` if this map contains no mapping for the key.
function getOrDefault&lt;K,V&gt;(m: {K:V}, k: K, defaultValue: V) -&gt; V;
function getOrDefaultFromMut&lt;K,V&gt;(m: mut {K:V}, k: K, defaultValue: V) -&gt; V;

# Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.
consumer clear&lt;K,V&gt;(m: mut {K:V});

# Returns an immutable set containing the keys of this map.
function keySet&lt;K,V&gt;(m: {K:V}) -&gt; {K};
# Returns an immutable set containing the keys of this map. Changes made to the original map *do not* have any affect on
# the returned set.
function keySetOfMut&lt;K,V&gt;(m: mut {K:V}) -&gt; {K};

# Returns a mutable set containing the keys of this map. Changes made to either collection have no affect on the other.
function mutKeySet&lt;K,V&gt;(m: {K:V}) -&gt; mut {K};
function mutKeySetOfMut&lt;K,V&gt;(m: mut {K:V}) -&gt; mut {K};

# TODO(steving) If at all possible, ClaroSet.java should be refactored so that it *contains* a Set rather than extends
# TODO(steving)     HashSet&lt;T&gt; directly so that maps::mutKeySetOfMut() can return a proper &quot;view&quot;.
# TODO(steving)   - https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#clear--:~:text=Returns%20a%20Set%20view%20of%20the%20keys%20contained%20in%20this%20map.%20The%20set%20is%20backed%20by%20the%20map%2C%20so%20changes%20to%20the%20map%20are%20reflected%20in%20the%20set%2C%20and%20vice%2Dversa.
#function mutKeySetViewOfMut&lt;K,V&gt;(m: mut {K:V}) -&gt; mut {K};

# Returns an immutable set containing the values of this map.
function values&lt;K,V&gt;(m: {K:V}) -&gt; {V};
# Returns an immutable set containing the values of this map. Changes made to the original map *do not* have any affect on
# the returned set.
function valuesOfMut&lt;K,V&gt;(m: mut {K:V}) -&gt; {V};

# Returns a mutable set containing the values of this map. Changes made to either collection have no affect on the other.
function mutValues&lt;K,V&gt;(m: {K:V}) -&gt; mut {V};
function mutValuesOfMut&lt;K,V&gt;(m: mut {K:V}) -&gt; mut {V};

# Returns an immutable set of the mappings contained in this map.
function entrySet&lt;K,V&gt;(m: {K:V}) -&gt; {tuple&lt;K, V&gt;};
# Returns an immutable set of the mappings contained in this map. Changes made to the original map *do not* have any
# affect on the returned set.
function entrySetOfMut&lt;K,V&gt;(m: mut {K:V}) -&gt; {tuple&lt;K, V&gt;};

# Returns a mutable set of the mappings contained in this map.
function mutEntrySet&lt;K,V&gt;(m: {K:V}) -&gt; mut {tuple&lt;K, V&gt;};
# Returns a mutable set of the mappings contained in this map. Changes made to either collection have no affect on the other.
function mutEntrySetOfMut&lt;K,V&gt;(m: mut {K:V}) -&gt; mut {tuple&lt;K, V&gt;};

# Performs the given action for each entry in this map until all entries have been processed.
consumer forEach&lt;K,V&gt;(m: {K:V}, action: consumer&lt;K,V&gt;);
consumer forEachInMut&lt;K,V&gt;(m: mut {K:V}, action: consumer&lt;K,V&gt;);

# Replaces each entry's value with the result of invoking the given function on that entry until all entries have been
# processed.
consumer replaceAll&lt;K,V&gt;(m: mut {K:V}, mapper: function&lt;|K, V| -&gt; V&gt;);

# Associates the specified value with the specified key in this map. If the map previously contained a mapping for the
# key, the old value is replaced by the specified value.
#
# Returns: the previous value associated with key, or `maps::PUT_VALUE_FOR_PREVIOUSLY_ABSENT_KEY` if there was no
#          mapping for key.
atom PUT_VALUE_FOR_PREVIOUSLY_ABSENT_KEY
function put&lt;K,V&gt;(m: mut {K:V}, k: K, v: V) -&gt; oneof&lt;V, PUT_VALUE_FOR_PREVIOUSLY_ABSENT_KEY&gt;;

# Copies all of the mappings from the specified map to this map. The effect of this call is equivalent to that of
# calling `maps::put(m, k, v)` on this map once for each mapping from key k to value v in the specified map.
consumer putAll&lt;K,V&gt;(m: mut {K:V}, from: {K:V});
consumer putAllFromMut&lt;K,V&gt;(m: mut {K:V}, from: mut {K:V});

# If the specified key is not already associated with a value, associates it with the given value and returns
# `maps::PUT_VALUE_FOR_PREVIOUSLY_ABSENT_KEY`, else returns the current value.
function putIfAbsent&lt;K,V&gt;(m: mut {K:V}, k: K, v: V) -&gt; oneof&lt;V, PUT_VALUE_FOR_PREVIOUSLY_ABSENT_KEY&gt;;

# Removes the mapping for a key from this map if it is present.
#
# Returns: the value to which this map previously associated the key, or `maps::KeyNotFound&lt;K&gt;` if the map contained no
#          mapping for the key.
function removeKey&lt;K,V&gt;(m: mut {K:V}, k: K) -&gt; oneof&lt;V, KeyNotFound&lt;K&gt;&gt;;

# Removes the entry for the specified key only if it is currently mapped to the specified value.
function removeEntry&lt;K,V&gt;(m: mut {K:V}, k: K, v: V) -&gt; boolean;

# Replaces the entry for the specified key only if currently mapped to the specified value.
#
# Returns: `true` if the value was replaced, else `false`.
function replaceEntry&lt;K,V&gt;(m: mut {K:V}, k: K, oldValue: V, newValue: V) -&gt; boolean;

# Replaces the entry for the specified key only if it is currently mapped to some value.
#
# Returns: the previous value associated with the specified key, or `std::Error&lt;maps::KeyNotFound&lt;K&gt;&gt;` if there was no
#          mapping for the key.
newtype KeyNotFound&lt;K&gt; : K
function replace&lt;K,V&gt;(m: mut {K:V}, k: K, newValue: V) -&gt; oneof&lt;V, std::Error&lt;KeyNotFound&lt;K&gt;&gt;&gt;;

# If the specified key is not already associated with a value, attempts to compute its value using the given mapping
# function and enters it into this map, unless the function returns `maps::DoNotUpdate&lt;K&gt;` in which case no mapping is
# recorded.
#
# Returns: the current (existing or computed) value associated with the specified key, or propagates any
#          `maps::DoNotUpdate&lt;K&gt;` returned by `mapper`.
newtype DoNotUpdate&lt;K&gt; : K
function computeIfAbsent&lt;K,V&gt;(
  m: mut {K:V},
  k: K,
  mapper: function&lt;K -&gt; oneof&lt;V, std::Error&lt;DoNotUpdate&lt;K&gt;&gt;&gt;&gt;)
    -&gt; oneof&lt;V, std::Error&lt;DoNotUpdate&lt;K&gt;&gt;&gt;;

# If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped
# value. If the function returns `maps::REMOVE_ENTRY`, the mapping is removed.
#
# Returns: the new value associated with the specified key, propagates `maps::REMOVE_ENTRY` if the entry was removed, or
#          `maps::KeyNotFound&lt;K&gt;` if the key was not present in the map.
atom REMOVE_ENTRY
function computeIfPresent&lt;K,V&gt;(
  m: mut {K:V},
  k: K,
  remapper: function&lt;|K, V| -&gt; oneof&lt;V, REMOVE_ENTRY&gt;&gt;)
    -&gt; oneof&lt;V, REMOVE_ENTRY, std::Error&lt;KeyNotFound&lt;K&gt;&gt;&gt;;

# Attempts to compute a mapping for the specified key and its current mapped value (or `maps::KeyNotFound&lt;K&gt;` if there
# is no current mapping). For example, to either create or append a string msg to a value mapping:
#
#  maps::compute(
#     someMap,
#     key,
#     lambda (k, v) -&gt; {
#       if (v instanceof maps::KeyNotFound&lt;K&gt;) {
#         return msg;
#       }
#       return &quot;{v}{msg}&quot;;
#     }
#  );
#  (Method merge() is often simpler to use for such purposes.)
#
# If the function returns `maps::REMOVE_ENTRY`, the mapping is removed (or remains absent if initially absent).
#
# Returns: the new value associated with the specified key, or propagates `maps::REMOVE_ENTRY` if the entry was removed.
function compute&lt;K,V&gt;(
  m: mut {K:V},
  k: K,
  remapper: function&lt;|K, oneof&lt;V, KeyNotFound&lt;K&gt;&gt;| -&gt; oneof&lt;V, REMOVE_ENTRY&gt;&gt;)
    -&gt; oneof&lt;V, REMOVE_ENTRY&gt;;

# If the specified key is not already associated with a value, associates it with the given value. Otherwise, replaces
# the associated value with the results of the given remapping function, or removes if the result is
# `maps::REMOVE_ENTRY`. This method may be of use when combining multiple mapped values for a key. For example, to
# either create or append a String msg to a value mapping:
#
#   maps::merge(someMap, key, msg, lambda (oldVal, newVal) -&gt; {
#     match (newVal) {
#       case _:maps::REMOVE_ENTRY -&gt; return newVal;
#       case _                    -&gt; return &quot;{oldVal}{newVal}&quot;;
#     }
#   });
#
# Returns: the new value associated with the specified key, or propagates `std::REMOVE_ENTRY` if the entry was removed.
function merge&lt;K,V&gt;(
  m: mut {K:V},
  k: K,
  v: oneof&lt;V, REMOVE_ENTRY&gt;,
  remapper: function&lt;|V, oneof&lt;V, REMOVE_ENTRY&gt;| -&gt; oneof&lt;V, REMOVE_ENTRY&gt;&gt;)
    -&gt; oneof&lt;V, REMOVE_ENTRY&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math"><a class="header" href="#math">math</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
function absInt(i: int) -&gt; int;
function absDouble(d: double) -&gt; double;
function absFloat(f: float) -&gt; float;

function ceiling(d: double) -&gt; double;
function ceilingFloat(f: float) -&gt; float;

function floor(d: double) -&gt; double;
function floorFloat(f: float) -&gt; float;

function maxInt(a: int, b: int) -&gt; int;
function maxDouble(a: double, b: double) -&gt; double;
function maxFloat(a: float, b: float) -&gt; float;

function minInt(a: int, b: int) -&gt; int;
function minDouble(a: double, b: double) -&gt; double;
function minFloat(a: float, b: float) -&gt; float;

function roundDownToInt(d: double) -&gt; int;
function roundUpToInt(d: double) -&gt; int;
function roundFloatDownToInt(f: float) -&gt; int;
function roundFloatUpToInt(f: float) -&gt; int;

function sqrt(d: double) -&gt; double;
function sqrtFloat(f: float) -&gt; float;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="priority_queue"><a class="header" href="#priority_queue">priority_queue</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
opaque newtype mut PriorityQueue&lt;E&gt;

atom NO_SUCH_ELEMENT

provider create&lt;T&gt;() -&gt; PriorityQueue&lt;T&gt;;
function of&lt;T&gt;(elems: [T]) -&gt; PriorityQueue&lt;T&gt;;
function withInitialCapacity&lt;T&gt;(initialCapacity: int) -&gt; PriorityQueue&lt;T&gt;;

function peek&lt;T&gt;(pq: PriorityQueue&lt;T&gt;) -&gt; oneof&lt;T, NO_SUCH_ELEMENT&gt;;
function poll&lt;T&gt;(pq: PriorityQueue&lt;T&gt;) -&gt; oneof&lt;T, NO_SUCH_ELEMENT&gt;;
consumer add&lt;T&gt;(pq: PriorityQueue&lt;T&gt;, t: T);

function removeElement&lt;T&gt;(pq: PriorityQueue&lt;T&gt;, t: T) -&gt; boolean;

function size&lt;T&gt;(pq: PriorityQueue&lt;T&gt;) -&gt; int;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="random"><a class="header" href="#random">random</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
opaque newtype RandomNumberGenerator

# See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#random--
provider doubleInUnitInterval() -&gt; double;

provider create() -&gt; RandomNumberGenerator;
# TODO(steving) Update this to take a `long` once supported.
function forSeed(seed: int) -&gt; RandomNumberGenerator;

function nextBoolean(rng: RandomNumberGenerator) -&gt; boolean;
function nextDouble(rng: RandomNumberGenerator) -&gt; double;
function nextFloat(rng: RandomNumberGenerator) -&gt; float;
function nextInt(rng: RandomNumberGenerator) -&gt; int;
function nextNonNegativeBoundedInt(rng: RandomNumberGenerator, exclusiveUpperBound: int) -&gt; int;


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scanner"><a class="header" href="#scanner">scanner</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
# Not thread safe.
opaque newtype mut Scanner

atom NO_MORE_TOKENS
atom PATTERN_NOT_FOUND
atom ILLEGAL_NEGATIVE_HORIZON
atom INPUT_MISMATCH

provider forStdIn() -&gt; Scanner;
function forString(toScan: string) -&gt; Scanner;

function useDelimiter(sc: Scanner, pattern: string) -&gt; Scanner;
function reset(sc: Scanner) -&gt; Scanner;

blocking function findInLine(sc: Scanner, pattern: string) -&gt; oneof&lt;string, PATTERN_NOT_FOUND&gt;;
blocking function findWithinHorizon(sc: Scanner, pattern: string, horizon: int)
    -&gt; oneof&lt;string, PATTERN_NOT_FOUND, ILLEGAL_NEGATIVE_HORIZON&gt;;

blocking function hasNextToken(sc: Scanner) -&gt; boolean;
blocking function hasNextPattern(sc: Scanner, pattern: string) -&gt; boolean;
blocking function hasNextBoolean(sc: Scanner) -&gt; boolean;
blocking function hasNextFloat(sc: Scanner) -&gt; boolean;
blocking function hasNextInt(sc: Scanner) -&gt; boolean;
blocking function hasNextLine(sc: Scanner) -&gt; boolean;

blocking function nextToken(sc: Scanner) -&gt; oneof&lt;string, NO_MORE_TOKENS&gt;;
blocking function nextMatch(sc: Scanner, pattern: string) -&gt; oneof&lt;string, NO_MORE_TOKENS&gt;;
blocking function nextBoolean(sc: Scanner) -&gt; oneof&lt;boolean, INPUT_MISMATCH, NO_MORE_TOKENS&gt;;
blocking function nextFloat(sc: Scanner) -&gt; oneof&lt;float, INPUT_MISMATCH, NO_MORE_TOKENS&gt;;
blocking function nextInt(sc: Scanner) -&gt; oneof&lt;int, INPUT_MISMATCH, NO_MORE_TOKENS&gt;;
blocking function nextLine(sc: Scanner) -&gt; oneof&lt;string, INPUT_MISMATCH, NO_MORE_TOKENS&gt;;

blocking function skipPattern(sc: Scanner, pattern: string)
    -&gt; struct { scanner: Scanner, res: oneof&lt;std::OK, PATTERN_NOT_FOUND&gt; };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sets-1"><a class="header" href="#sets-1">sets</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro"># This module simply provides access to the functionality described in:
#   - https://docs.oracle.com/javase/8/docs/api/java/util/Set.html

# TODO(steving) Claro needs some sort of Collection&lt;T&gt; contract so that these procedures can avoid duplication for the
# TODO(steving)     various combinations of mutability annotations.

# TODO(steving) If at all possible, ClaroSet.java should be refactored so that it *contains* a Set rather than extends
# TODO(steving)     HashSet directly so that functionality directly from Guava's Sets class can be directly added to
# TODO(steving)     this module w/o losing the performance wins of their &quot;views&quot;.
# TODO(steving)   - https://guava.dev/releases/23.0/api/docs/com/google/common/collect/Sets.html


provider emptySet&lt;T&gt;() -&gt; {T};
provider emptyMutSet&lt;T&gt;() -&gt; mut {T};

# Adds the specified element to this set if it is not already present. If this set already contains the element, the
# call leaves the set unchanged and returns false. This ensures that sets never contain duplicate elements.
#
# Returns: true if this set did not already contain the specified element.
function add&lt;T&gt;(s: mut {T}, t: T) -&gt; boolean;

# Adds all of the elements in the specified collection to this set if they're not already present.
#
# Returns: true if the set changed as a result of the call.
function addAllFromList&lt;T&gt;(s: mut {T}, toAdd: [T]) -&gt; boolean;
function addAllFromMutList&lt;T&gt;(s: mut {T}, toAdd: mut [T]) -&gt; boolean;
# Adds all of the elements in the second set to the first set if they're not already present. This operation effectively
# modifies the first set so that its value is the union of the two sets.
#
# Returns: true if the first set changed as a result of the call.
function addAllFromSet&lt;T&gt;(s: mut {T}, toAdd: {T}) -&gt; boolean;
function addAllFromMutSet&lt;T&gt;(s: mut {T}, toAdd: mut {T}) -&gt; boolean;

# Removes all of the elements from this set. The set will be empty after this call returns.
consumer clear&lt;T&gt;(s: mut {T});

# Returns true if this set contains all of the elements of the specified collection.
function containsAll&lt;T&gt;(s: {T}, elems: [T]) -&gt; boolean;
function containsAllFromMut&lt;T&gt;(s: {T}, elems: mut [T]) -&gt; boolean;
function containsAllInMut&lt;T&gt;(s: mut {T}, elems: [T]) -&gt; boolean;
function containsAllInMutFromMut&lt;T&gt;(s: mut {T}, elems: mut [T]) -&gt; boolean;

# Performs the given action for each element.
consumer forEach&lt;T&gt;(s: {T}, action: consumer&lt;T&gt;);
consumer forEachInMut&lt;T&gt;(s: mut {T}, action: consumer&lt;T&gt;);

# This method returns true if the first set is a superset of the second set. Note, this procedure returns true if the
# two sets are equal.
function isSuperset&lt;T&gt;(s: {T}, other: {T}) -&gt; boolean;
function isSupersetOfMut&lt;T&gt;(s: {T}, other: mut {T}) -&gt; boolean;
function isMutSuperset&lt;T&gt;(s: mut {T}, other: {T}) -&gt; boolean;
function isMutSupersetOfMut&lt;T&gt;(s: mut {T}, other: mut {T}) -&gt; boolean;

# This method returns true if the first set is a subset of the second set. Note, this procedure returns true if the two
# sets are equal.
function isSubset&lt;T&gt;(s: {T}, other: {T}) -&gt; boolean;
function isSubsetOfMut&lt;T&gt;(s: {T}, other: mut {T}) -&gt; boolean;
function isMutSubset&lt;T&gt;(s: mut {T}, other: {T}) -&gt; boolean;
function isMutSubsetOfMut&lt;T&gt;(s: mut {T}, other: mut {T}) -&gt; boolean;

# Returns true if this set contains no elements.
function isEmpty&lt;T&gt;(s: {T}) -&gt; boolean;
function isEmptyForMut&lt;T&gt;(s: mut {T}) -&gt; boolean;

# Removes the specified element from this set if it is present.
function removeElem&lt;T&gt;(s: mut {T}, elem: T) -&gt; boolean;

# Removes from this set all of its elements that are contained in the specified list.
#
# Returns: true if this set changed as a result of the call.
function removeAll&lt;T&gt;(s: mut {T}, elems: [T]) -&gt; boolean;
function removeAllFromMut&lt;T&gt;(s: mut {T}, elems: mut [T]) -&gt; boolean;
# Removes from the first set all of its elements that are contained in the second set. This operation effectively
# modifies the first set so that its value is the asymmetric set difference of the two sets.
#
# Returns: true if this set changed as a result of the call.
function removeAllFromSet&lt;T&gt;(s: mut {T}, elems: {T}) -&gt; boolean;
function removeAllFromMutSet&lt;T&gt;(s: mut {T}, elems: mut {T}) -&gt; boolean;

# Removes all of the elements of this collection that satisfy the given predicate.
#
# Returns: true if any elements were removed.
function removeIf&lt;T&gt;(s: mut {T}, predicate: function&lt;T -&gt; boolean&gt;) -&gt; boolean;

# Retains only the elements in this set that are contained in the specified list. In other words, removes from this set
# all of its elements that are not contained in the specified list.
#
# Returns: true if this set changed as a result of the call.
function retainAll&lt;T&gt;(s: mut {T}, elems: [T]) -&gt; boolean;
function retainAllFromMut&lt;T&gt;(s: mut {T}, elems: mut [T]) -&gt; boolean;
# Retains only the elements in the first set that are contained in the second set. In other words, removes from the
# first set all of its elements that are not contained in the second set. This operation effectively modifies this set
# so that its value is the intersection of the two sets.
#
# Returns: true if this set changed as a result of the call.
function retainAllFromSet&lt;T&gt;(s: mut {T}, elems: {T}) -&gt; boolean;
function retainAllFromMutSet&lt;T&gt;(s: mut {T}, elems: mut {T}) -&gt; boolean;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="std"><a class="header" href="#std">std</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">########################################################################################################################
# This file contains simple definitions of builtin types that come as part of Claro's stdlib. Very likely this will get
# reorganized over time, for now it's a single centralized dumping ground.
########################################################################################################################

atom Nothing

atom OK
newtype Error&lt;T&gt; : T

newtype ParsedJson&lt;T&gt; : struct {
  result: oneof&lt;T, Error&lt;string&gt;&gt;,
  rawJson: string
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">strings</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro"># Simply exposing the functionality documented at the links below to Claro programs:
#   - https://docs.oracle.com/javase/8/docs/api/java/lang/String.html
#   - https://guava.dev/releases/31.1-jre/api/docs/com/google/common/base/Strings.html
# TODO(steving) Make this api safe so that nothing can throw a runtime exception.

atom NOT_FOUND

function fromChar(c: char) -&gt; string;

function charAt(s: string, i: int) -&gt; char;

function commonPrefix(s: string, other: string) -&gt; string;
function commonSuffix(s: string, other: string) -&gt; string;

function compareTo(s: string, other: string) -&gt; int;
function compareToIgnoreCase(s: string, other: string) -&gt; int;

function concat(s: string, other: string) -&gt; string;

function contains(s: string, other: string) -&gt; boolean;

function endsWith(s: string, other: string) -&gt; boolean;

function equalsIgnoreCase(s: string, other: string) -&gt; boolean;

function indexOf(s: string, of: string) -&gt; oneof&lt;int, NOT_FOUND&gt;;
function indexOfFromIndex(s: string, of: string, from: int) -&gt; oneof&lt;int, NOT_FOUND&gt;;

function isEmpty(s: string) -&gt; boolean;

function join(delimiter: string, parts: [string]) -&gt; string;

function lastIndexOf(s: string, of: string) -&gt; oneof&lt;int, NOT_FOUND&gt;;
function lastIndexOfFromIndex(s: string, of: string, from: int) -&gt; oneof&lt;int, NOT_FOUND&gt;;

function matches(s: string, regex: string) -&gt; boolean;

# TODO(steving) Revisit this once Claro has support for chars. Should support configurable padding char.
function padEnd(s: string, minLength: int) -&gt; string;
function padStart(s: string, minLength: int) -&gt; string;

function regionMatches(s: string, s_offset: int, other: string, o_offset: int, regionLen: int) -&gt; boolean;
function regionMatchesIgnoreCase(ignoreCase: boolean, s: string, s_offset: int, other: string, o_offset: int, regionLen: int) -&gt; boolean;

function repeated(s: string, count: int) -&gt; string;

function replace(s: string, target: string, replacement: string) -&gt; string;
function replaceAll(s: string, regex: string, replacement: string) -&gt; string;
function replaceFirst(s: string, regex: string, replacement: string) -&gt; string;

function split(s: string, regex: string) -&gt; [string];
function splitWithLimit(s: string, regex: string, limit: int) -&gt; [string];
function splitChars(s: string) -&gt; [char];

function startsWith(s: string, other: string) -&gt; boolean;
function startsWithFromIndex(s: string, other: string, from: int) -&gt; boolean;

function substring(s: string, beginInclusive: int, endExclusive: int) -&gt; string;
function suffix(s: string, beginInclusive: int) -&gt; string;

function toLowerCase(s: string) -&gt; string;
function toUpperCase(s: string) -&gt; string;

function trim(s: string) -&gt; string;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[0.002s][warning][perf,memops] Cannot use file /tmp/hsperfdata_runner/3 because it is locked by another process (errno = 11)</p>
<h1 id="string_builder"><a class="header" href="#string_builder">string_builder</a></h1>
<div class="warning">
<p><strong>Claro's StdLib Module Documentation Generation Is Still a WIP</strong>.</p>
<p><em>This is currently just a placeholder to at least ensure that all the StdLib Modules are represented here so that you 
don't have to dig into the GitHub repo to find this. But, expect this to improve and become more interactive over time.</em></p>
</div>
<pre><code class="language-claro">
opaque newtype StringBuilder

provider create() -&gt; StringBuilder;

# Add anything to the end of the StringBuilder. It will be converted to its string representation automatically.
function add&lt;T&gt;(sb: StringBuilder, toAdd: T) -&gt; StringBuilder;
function build(sb: StringBuilder) -&gt; string;

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid@10.6.1.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
